interface SantaClausR
begin with ReinDeer
  op backFromHoliday
end

interface SantaClausE
begin with Elf
  op haveProblem
end

interface SantaClaus inherits SantaClausR, SantaClausE
begin
end

interface Reindeer
begin with SantaClausR
  op harness
  op unharness
end

interface Elf
begin with SantaClausE
  op enterOffice
  op leaveOffice
end



class SantaClausC implements SantaClaus
begin
  var ctRreindeers: Nat := 0
  var waitRreindeers:List := nil
  var harnessedReindeers:List := nil
  var ctElves: Nat := 0
  var waitElves:List := nil
  var inofficeElves:List := nil

  op run == !loop()

  op loop == begin await ctReindeers = 5; deliverToys(;) []
              await  3 <= ctElves && ~ ctReindeers = 9; talkToElves(;) end ;
             !loop()

  op deliverToys ==
	ctReindeers := 0;
	t1!first(waitReindeers).harness(); 
	harnessedReindeers := plus(harnessedReindeers, first(waitReindeers)); 
	waitReindeers := rest(waitReindeers);
	// ....;
	t5!first(waitReindeers).harness(); 
	harnessedReindeers := plus(harnessedReindeers, first(waitReindeers)); 
	waitReindeers := rest(waitReindeers);
	await t1? & t2? & t3? & t4? & t5?;
	// <Deliver Toys>;
	!first(harnessedReindeers).unharness();
	harnessedReindeers := rest(harnessedReindeers);
	// ....;
	!first(harnessedReindeers).unharness();
	harnessedReindeers := rest(harnessedReindeers)


  op talkToelves ==
	ctElves := ctElves - 3; 
	t1!first(waitElves).showIn();
	inofficeElves := plus(inofficeElves, first(waitElves));
	waitElves := rest(waitElves);
	t2!first(waitElves).showIn();
	inofficeElves := plus(inofficeElves, first(waitElves));
	waitElves := rest(waitElves);
	t3!first(waitElves).showIn();
	inofficeElves := plus(inofficeElves, first(waitElves));
	waitElves := rest(waitElves);
	await t1? & t2? & t3?;
	// <Talk to elves>;
	t1!first(inoffcieElves).showOut();
	inofficeElves := rest(inofficeElves);
	t2!first(inoffcieElves).showOut();
	inofficeElves := rest(inofficeElves);
	t3!first(inoffcieElves).showOut();
	inofficeElves := rest(inofficeElves);
	await t1? & t2? & t3?

with Reindeer
  op backFromHoliday ==
	ctReindeers := ctReindeers + 1; 
	waitReindeers := plus(waitReindeers, caller)

with Elf
  op haveProblem ==
	ctElves := ctElves + 1; 
	waitElves := plus(waitElves, caller)
end


class ReindeerC(sc: ReinDeer) implements Reindeer
begin
  op run == !holiday()
  op holiday == // <go on holiday>;
	!sc.backFromHoliday()
  op deliverToys == skip // <deliver Toys>

with SantaClausR
  op harness == !deliverToys()
  op unharness == !holiday()
end



class ElfC(sc:SantaClaus) implements Elf
begin 
  op run == !work()
  op work == // <do work>;
		!sc.haveProblem()
  op talkToSanta == skip // <talk to Santa>

with SantaClausE
  op showIn == !talkToSanta()
  op showOut == !work()
end

class LeaderElfC(sc:SantaClaus, elves: List)
	inherits ElfC
	implements Elf
begin
  op run == run@ElfC(;)
  op work ==
	// (<Lead elves> ||| <Make toys>);
	!sc.haveProblem()
end

class Christmas
begin
  op run == 
	var sc:SantaC;
	var r:Reindeer;
	var e:Elf;
	sc := new SantaClausClass();
	r := new Reindeer(sc);
	r := new Reindeer(sc);
	r := new Reindeer(sc);
	r := new Reindeer(sc);
	r := new Reindeer(sc);
	e := new Elf(sc);
	e := new Elf(sc);
	e := new Elf(sc);
	e := new Elf(sc);
	e := new Elf(sc);
	e := new Elf(sc);
	e := new Elf(sc)
end

//	#COMMENTS:
//
//	Local synchronous calls: m(...;...) is same as t!m(...;..); t?() //-
//	an abbrevation. 
//
//	!m(..)  || with no arguments  !m  starts the method call m but does
//	~ wait for any answer...
