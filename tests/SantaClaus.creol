interface SantaClausR
begin with ReinDeer
  op backFromHoliday
end

interface SantaClausE
begin with Elf
  op haveProblem
end

interface SantaClaus inherits SantaClausR, SantaClausE
begin
end

interface Reindeer
begin with SantaClausR
  op harness
  op unharness
end

interface Elf
begin with SantaClausE
  op enterOffice
  op leaveOffice
end



class SantaClausC implements SantaClaus
begin
  var ct_reindeers:nat := 0
  var wait_reindeers:List := nil
  var harnessed_reindeers:List := nil
  var ct_elves:nat := 0
  var wait_elves:List := nil
  var inoffice_elves:List := nil

  op run == !loop()

  op loop == (await ct_reindeers = 5; deliverToys() []
              await ct_elves >= 3 and not ct_reindeers = 9; talkToElves()); 
             !loop()

  op deliverToys ==
	var t1:Label;
  	var t2: Label;
  	var t3: Label;
  	var t4: Label;
  	var t5:Label;
	ct_reindeers := 0;
	t1!first(wait_reindeers).harness(); 
	harnessed_reindeers := harnessed_reindeers :: first(wait_reindeers); 
		wait_reindeers := rest(wait_reindeers);
	-- ....;
		t5!first(wait_reindeers).harness(); 
		harnessed_reindeers := harnessed_reindeers :: first(wait_reindeers); 
	wait_reindeers := rest(wait_reindeers);
	await t1? and t2? and t3? and t4? and t5?;
	-- <Deliver Toys>;
	!first(harnessed_reindeers).unharness();
	harnessed_reindeers := rest(harnessed_reindeers);
	-- ....;
	!first(harnessed_reindeers).unharness();
	harnessed_reindeers := rest(harnessed_reindeers)


	op talkToelves ==
		var t1:Label;
		var t2:Label;
		var t3:Label;
		ct_elves := ct_elves - 3; 
		t1!first(wait_elves).showIn();
		inoffice_elves := inoffice_elves :: first(wait_elves);
		wait_elves := rest(wait_elves);
		t2!first(wait_elves).showIn();
		inoffice_elves := inoffice_elves :: first(wait_elves);
		wait_elves := rest(wait_elves);
		t3!first(wait_elves).showIn();
		inoffice_elves := inoffice_elves :: first(wait_elves);
		wait_elves := rest(wait_elves);
		await t1? and t2? and t3?;
		-- <Talk to elves>;
		t1!first(inoffcie_elves).showOut();
		inoffice_elves := rest(inoffice_elves);
		t2!first(inoffcie_elves).showOut();
		inoffice_elves := rest(inoffice_elves);
		t3!first(inoffcie_elves).showOut();
		inoffice_elves := rest(inoffice_elves);
		await t1? and t2? and t3?

with Reindeer
	op backFromHoliday ==
		ct_reindeers := ct_reindeers + 1; 
		wait_reindeers := wait_reindeers :: caller

with Elf
	op haveProblem ==
		ct_elves := ct_elves + 1; 
		wait_elves := wait_elves :: caller
end


class ReindeerC(sc:toReinDeer) implements Reindeer
begin
	op run == !holiday()
	op holiday == -- <go on holiday>;
		!sc.backFromHoliday()
	op deliverToys == skip -- <deliver Toys>

  with SantaClausR
	op harness == !deliverToys()
	op unharness == !holiday()
end



class ElfC(sc:SantaClaus) implements Elf
begin 
	op run == !work()
	op work == -- <do work>;
		!sc.haveProblem()
	op talkToSanta == skip -- <talk to Santa>

  with SantaClausE
	op showIn == !talkToSanta()
	op showOut == !work()
end

class LeaderElfC(sc:SantaClaus, elves:List)
     implements Elf inherits ElfC
begin
  op run == run@ElfC()
  op work ==
	-- (<Lead elves> ||| <Make toys>);
	!sc.haveProblem()
end

class Christmas
begin
  op run == 
	var sc:SantaC;
	var r:Reindeer;
	var e:Elf;
	sc := new SantaClausClass;
	r := new Reindeer(sc);
	r := new Reindeer(sc);
	r := new Reindeer(sc);
	r := new Reindeer(sc);
	r := new Reindeer(sc);
	e := new Elf(sc);
	e := new Elf(sc);
	e := new Elf(sc);
	e := new Elf(sc);
	e := new Elf(sc);
	e := new Elf(sc);
	e := new Elf(sc)
end

--	#COMMENTS:
--
--	Local synchronous calls: m(...;...) is same as t!m(...;..); t?() ---
--	an abbrevation. 
--
--	!m(..)  or with no arguments  !m  starts the method call m but does
--	not wait for any answer...
