load interpreter
mod PROGRAM is
pr INTERPRETER .
op init : -> Configuration [ctor] .
eq init =
< "Philosopher" : Cl | Inh: noInh, Par: "butler", Att: "butler" |-> null , "hungry" |-> null , "chopstick" |-> null , "neighbor" |-> null , "history" |-> null, Mtds: 
  < "init" : Mtdname | Param: noAid, Latt: noSubst, Code: "history" ::= str("") ; "chopstick" ::= bool(true) ; "hungry" ::= bool(false) ; "butler" . "getNeighbor" ( emp ; "neighbor" ) ; return ( emp ) > *
  < "run" : Mtdname | Param: noAid, Latt: noSubst, Code: ( "Dummy" ! "this" . "think" ( emp ) ||| "Dummy" ! "this" . "eat" ( emp ) ||| "Dummy" ! "this" . "digest" ( emp ) ) ; return ( emp ) > *
  < "digest" : Mtdname | Param: noAid, Latt: noSubst, Code: ( await wait ) ; "hungry" ::= bool(true) ; "history" ::= "plus" ( "history" # str("d") ) ; ( await wait ) ; "Dummy" ! "this" . "digest" ( emp ) ; return ( emp ) > *
  < "eat" : Mtdname | Param: noAid, Latt: noSubst, Code: ( await "hungry" ) ; "l" ! "neighbor" . "borrowStick" ( emp ) ; ( await ( "l" ?? ) ) ; ( await "chopstick" ) ; "history" ::= "plus" ( "history" # str("e") ) ; "hungry" ::= bool(false) ; "Dummy" ! "neighbor" . "returnStick" ( emp ) ; ( await wait ) ; "Dummy" ! "this" . "eat" ( emp ) ; return ( emp ) > *
  < "think" : Mtdname | Param: noAid, Latt: noSubst, Code: ( await "not" ( "hungry" ) ) ; "history" ::= "plus" ( "history" # str("t") ) ; ( await wait ) ; "Dummy" ! "this" . "think" ( emp ) ; return ( emp ) > *
  < "borrowStick" : Mtdname | Param: noAid, Latt: noSubst, Code: ( await "chopstick" ) ; "chopstick" ::= bool(false) ; return ( emp ) > *
  < "returnStick" : Mtdname | Param: noAid, Latt: noSubst, Code: "chopstick" ::= bool(true) ; return ( emp ) >, Ocnt: 0 >

< "Butler" : Cl | Inh: noInh, Par: noAid, Att: "p1" |-> null , "p2" |-> null , "p3" |-> null , "p4" |-> null , "p5" |-> null, Mtds: 
  < "init" : Mtdname | Param: noAid, Latt: noSubst, Code: skip ; return ( emp ) > *
  < "run" : Mtdname | Param: noAid, Latt: noSubst, Code: "p1" ::= new "Philosopher" ( "this" ) ; "p2" ::= new "Philosopher" ( "this" ) ; "p3" ::= new "Philosopher" ( "this" ) ; "p4" ::= new "Philosopher" ( "this" ) ; "p5" ::= new "Philosopher" ( "this" ) ; return ( emp ) > *
  < "getNeighbor" : Mtdname | Param: noAid, Latt: "neighbor" |-> null, Code: if "equal" ( "caller" # "p1" ) th "neighbor" ::= "p2" el if "equal" ( "caller" # "p2" ) th "neighbor" ::= "p3" el if "equal" ( "caller" # "p3" ) th "neighbor" ::= "p4" el if "equal" ( "caller" # "p4" ) th "neighbor" ::= "p5" el "neighbor" ::= "p1" fi fi fi fi ; return ( "neighbor" ) >, Ocnt: 0 >

.
endm
