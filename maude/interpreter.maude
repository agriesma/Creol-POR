*** Reimplementation of the CREOL interpreter, 2007 ***

load datatypes .

load signature .

*** AUXILIARY FUNCTIONS ***
fmod AUX-FUNCTIONS is
pr CONFIG .
protecting CONVERSION .

*** Signatures
op inqueue  : Nat MMsg -> Bool . *** checks if  Msg is in the queue

op enabledGuard : Guard   Subst MMsg -> Bool .
op enabled      : StmList Subst MMsg -> Bool . *** eval guard 
op ready        : StmList Subst MMsg -> Bool . *** eval guard 

*** Variables
vars N N' : Nat .
vars E E' : Expr .
var EL : ExprList .
var A : Aid .
var Q : Qid .
vars G1 G2 : Guard .
var S : Subst .
var MM : MMsg .
var C : Cid .

*************************** Names of new objects ********************
op newId : Cid Nat -> Oid .
eq newId(Q, N)  = ob(qid(string(Q) + string(N,10))) .
***** some code to make string/qid total 
*** Don't think we need this ?
*** op string : Nat    -> String  .
*** op string : Cid    -> String [ditto] .
*** op string : Oid    -> String [ditto] .
*** op string : Rat NzNat -> String [ditto] .
*** op qid    : Qid    -> Qid .
*** op qid    : String -> Qid [ditto] .
*** eq string(N)      = string(N,10) . 
*** eq qid(Q)         = Q .
*** eq qid(string(Q)) = Q .  
*** eq qid(string(C)) = qid(C) .  
*** eq qid(S:String)  = 'invalid [owise] . 



eq inqueue(N, noMsg) = false .
*** eq inqueue(N, comp(N', E)) = if N == N' then true else false fi .
eq inqueue(N, comp(N', EL) + MM) = 
     if N == N' then true else inqueue(N, MM) fi .


eq enabledGuard(noGuard, S, MM)   = true .
eq enabledGuard(wait, S, MM)      = false .       *** Note: no wait in PrQ!
eq enabledGuard(E, S, MM)         = evalB(E, S) .
eq enabledGuard((A ?), S, MM)     = inqueue(evalN(A, S), MM) .
eq enabledGuard((N ?), S, MM)     = inqueue(N, MM) .
***(eq enabledGuard((G1 & G2), S, MM) = enabledGuard(G1, S, MM) and enabledGuard(G2, S, MM) . *** may skip termination problems! due to Id: noguard
)
*** red enabledGuard((int(5) > int(7)), noSub, noMsg) .
*** red int(4) add int(5) .
*** red (int(4) add int(5)) > (int(7) add int(19)) .
*** red upTerm((int(4) add int(5)) > (int(7) add int(19))) .
*** red downTerm(upTerm((int(4) add int(5)) > (int(7) add int(19))), (int(0)).Expr) .

vars  ST ST' : Stm . 
vars SL SL' : StmList . 
var NeSL : NeStmList .

eq enabled(SL [] SL',  S, MM) = enabled(SL, S, MM) or enabled(SL', S, MM) .
eq enabled(SL ||| SL', S, MM) = enabled(SL, S, MM) or enabled(SL', S, MM) .
eq enabled(await G1,   S, MM) = enabledGuard(G1,S,MM) .
eq enabled((ST ; ST' ; SL),S, MM) = enabled(ST, S, MM) . 
eq enabled(ST,    S, MM) = true [owise] . 

eq ready(SL [] SL',  S, MM) = ready(SL, S, MM) or ready(SL', S, MM) .
eq ready(SL ||| SL', S, MM) = ready(SL, S, MM) or ready(SL', S, MM) .
eq ready(A ?(E),     S, MM) = inqueue(evalN(A, S), MM) . 
eq ready(N ?(E),     S, MM) = inqueue(N, MM) . 
eq ready((ST ; ST' ; SL), S, MM) = ready(ST, S, MM) . 
eq ready(ST,         S, MM) = enabled(ST, S, MM) [owise] .

***( transform wait guards when active code is suspended. remove all waits.
op clear : Guard  -> Guard . 
eq clear(noGuard) = noGuard .
eq clear(wait)    = noGuard . 
eq clear(E)       = E .
eq clear((Q ?))   = (Q ?) .
eq clear((N ?))   = (N ?) .
eq clear(G1 & G2) = clear(G1) & clear(G2) .  *** term. problems!

op clear : StmList -> StmList . 
*** eq clear(nil)     = nil . 
eq clear(await G1)   = await(clear(G1)) .
eq clear(SL [] SL')  = clear(SL) [] clear(SL') .
eq clear(SL ||| SL') = clear(SL) ||| clear(SL') .
eq clear(SL ; NeSL)  = clear(SL) ; NeSL .
eq clear(SL)         = SL [owise] .
)

endfm

*** THE MACHINE ***
mod INTERPRETER is
pr AUX-FUNCTIONS .

vars O O' : Oid .
vars C C' : Cid .
vars A A' : Aid .
var AL : AidList .
var D : Data .
var DL : DataList .
vars E E' : Expr .
vars EL EL' : ExprList .
var ST : Stm .
vars SL SL' SL'' : StmList .
vars SL1 SL2 : NeStmList .
var P : Process .
var W : MProc .
vars S S' L L' : Subst .
vars N F : Nat .
vars I I' : InhList .
var MS : MMtd .
var NS : NatS .
var MM : MMsg .
var G : Guard .
var M : Mid .
var Q : Qid .
var MsgBody : Body .

*** multiple assignment
eq
  < O : C | Att: S, Pr: (L,((A ,, A' ,, AL) ::= (E # E' # EL)); SL),
	    PrQ: W, Lcnt: N >
  =
  < O : C | Att: S, Pr: (L,((A ::= eval(E, (S # L))); 
                            ((A' ,, AL) ::= evalList(E' # EL, (S # L))); SL)), 
	    PrQ: W, Lcnt: N > .

*** assignment

rl *** Avoid evaluating expressions twice in case of data .
  < O : C | Att: S, Pr: (L,( (A ::= D) ; SL)), PrQ: W, Lcnt: N >
  =>
  if dom(A,S) then
    < O : C | Att: insert(A, D, S), Pr: (L, SL), PrQ: W, Lcnt: N > 
  else
    < O : C | Att: S, Pr: (insert(A, D, L), SL), PrQ: W, Lcnt: N > 
  fi
  [label assign] .


crl
  < O : C | Att: S, Pr: (L,( (A ::= E) ; SL)), PrQ: W, Lcnt: N >
  =>
  if dom(A,S) then
    < O : C | Att: insert(A, D , S), Pr: (L, SL), PrQ: W, Lcnt: N > 
  else
    < O : C | Att: S, Pr: (insert(A, D, L), SL), PrQ: W, Lcnt: N > 
  fi
  if D :=  eval(E, (S # L))
  [label assign] .

rl [skip] :
  < O : C | Att: S, Pr: (L, skip ; SL), PrQ: W, Lcnt: N >
  =>
  < O : C | Att: S, Pr: (L, SL), PrQ: W, Lcnt: N > .


*** if_then_else ***
rl [if-el] :
< O : C | Att: S, Pr: (L, if E th SL' el SL'' fi ; SL), PrQ: W, Lcnt: N >
=>
if eval(E, (S # L)) asBool then
< O : C | Att: S, Pr: (L, SL' ; SL), PrQ: W, Lcnt: N >
else
< O : C | Att: S, Pr: (L, SL'' ; SL), PrQ: W, Lcnt: N >
fi .

*** while ***
rl [while] :
< O : C | Att: S, Pr: (L, while E do SL1 od ; SL2), PrQ: W, Lcnt: N >
=>
< O : C | Att: S, 
          Pr: (L, (if E th (SL1 ; while E do SL1 od) el skip fi); SL2),
          PrQ: W, Lcnt: N > .


*** OBJECT CREATION
rl [new-object] :
< O : C | Att: S,Pr: (L, (A ::= new C' (EL)); SL),PrQ: W, Lcnt: N > 
< C' : Cl | Inh: I , Par: AL, Att: S' , Mtds: MS , Ocnt: F >
=> 
< O : C | Att: S, Pr: (L, (A ::= newId(C', F)); SL), PrQ: W, Lcnt: N >
< C' : Cl | Inh: I , Par: AL, Att: S' , Mtds: MS , Ocnt: (F + 1) >
< newId(C',F) : C' | Att: S, Pr: idle, PrQ: noProc, Lcnt: 1 >
< newId(C',F) : Qu | Dealloc: noDealloc, Ev: noMsg > 
findAttr(newId(C',F), I, S', 
    (AL ::= evalList(EL, (S # L))), ('init (emp ; noAid)) ; ('run (emp ; noAid))) .

*** ATTRIBUTE inheritance with multiple inheritance
*** CMC assumes that all attributes names are (globally) different

op findAttr  : Oid InhList Subst StmList StmList -> Msg [ctor] . *** collect attributes
op foundAttr : Oid Subst  StmList StmList        -> Msg [ctor] . *** resulting Subst
*** look in InhList, collect attributes in Subst, give result to Oid
*** SL SL' SL''

eq findAttr(O, noInh, S, SL, SL')  *** collection completed.
       = foundAttr(O, S, SL, SL') .

eq findAttr(O,((C < EL >) ## I),S, SL, SL') 
< C : Cl | Inh: I', Par: AL, Att: L, Mtds: MS, Ocnt: F >
 = findAttr(O, I ## I',(L # S), (AL ::= EL) ; SL, 
              ('init @ C(emp ; emp)) ; SL') 
   < C : Cl | Inh: I', Par: AL, Att: L, Mtds: MS, Ocnt: F > .

eq foundAttr(O, S', SL, SL') 
< O : C | Att: S, Pr: idle, PrQ: W, Lcnt: N >
 = < O : C | Att: ('this |-> O, S'), Pr: (noSub, SL ; SL'), PrQ: W, Lcnt: N > .

*** Non-deterministic choice ***
*** Choice is comm, so [nondet] considers both SL1 and SL2.
crl [nondet] :
< O : C | Att: S, Pr: (L, (SL1 [] SL2); SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: NS, Ev: MM >
=>
< O : C | Att: S, Pr: (L, (SL1 ; SL)), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: NS, Ev: MM >
if ready(SL1, (S # L), MM) .  

*** crl [nondet-p2] :
*** < O : C | Att: S, Pr: ((SL1 [] SL2); SL,L), PrQ: W, Lcnt: N >
*** < O : Qu | Dealloc: NS, Ev: MM >
*** =>
*** < O : C | Att: S, Pr: ((SL2 ; SL),L), PrQ: W, Lcnt: N >
*** < O : Qu | Dealloc: NS, Ev: MM >
*** if ready(SL2, (S # L), MM) .  

*** Merge ***
*** Merge is comm, so [merge] considers both SL1 and SL2.
crl [merge] :
< O : C | Att: S, Pr: (L, (SL1 ||| SL2); SL), PrQ: W, Lcnt: N >  
< O : Qu | Dealloc: NS, Ev: MM >
=>
< O : C | Att: S, Pr: (L, (SL1 MERGER SL2); SL), PrQ: W, Lcnt: N >  
< O : Qu | Dealloc: NS, Ev: MM >
if ready(SL1,(S # L), MM) . 

rl [merge-aux] :
< O : C | Att: S,  Pr:  (L, ((ST ; SL') MERGER SL2); SL), PrQ: W, Lcnt: N >   
< O : Qu | Dealloc: NS, Ev: MM >
=>
< O : Qu | Dealloc: NS, Ev: MM >
if enabled(ST,(S # L), MM) then
< O : C | Att: S, Pr: (L, ((ST ; (SL' MERGER SL2)); SL)), PrQ: W, Lcnt: N >   
else
< O : C | Att: S, Pr: (L, ((ST ; SL') ||| SL2); SL), PrQ: W, Lcnt: N >   
fi .

rl [continue2] :
< O : C | Att: S, Pr: (L, (cont(N) MERGER SL'); SL''), 
          PrQ: (L', ((N ?(A)); SL)) ++ W, Lcnt: F >
=>
< O : C | Att: S, Pr: (L',((((N ?(A)) ; SL) MERGER SL'); SL'')), 
          PrQ: W, Lcnt: F > .

*** local call 
ceq boundMtd(O, (L', SL')) 
< O : C | Att: S,Pr: (L, ((N ?(AL)); SL)),PrQ: W,Lcnt: F >
= 
< O : C | Att: S,Pr: (L', SL' ; cont(N)),PrQ: (L,((await N ?) ; (N ?(AL)); SL)) ++ W,
          Lcnt: F > 
if (L'['label] == int(N))
[label local-call] .

*** local call within merge
ceq boundMtd(O, (L', SL')) 
< O : C | Att: S,Pr: (L,(((N ?(AL)); SL) MERGER SL'')),PrQ: W,Lcnt: F >
= 
< O : C | Att: S,Pr: (L', SL'),
          PrQ: (L, (((await N ?) ; (N ?(AL)); SL) MERGER SL'')) ++ W,Lcnt: F > 
if (L'['label] == int(N))
[label local-call-in-merge] .

*** Suspension ***

crl [suspend] :  *** all kinds of code P 
< O : C | Att: S, Pr: (L,SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: NS, Ev: MM >
=>
< O : C | Att: S, Pr: idle, PrQ: W ++ (L, SL), Lcnt: N > *** clear(SL)
< O : Qu | Dealloc: NS, Ev: MM >
if not enabled(SL, (S # L), MM) . 

*** Guards ***

crl [guard] :
< O : C | Att: S, Pr: (L, await G ; SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: NS, Ev: MM >
=>
< O : C | Att: S, Pr: (L,SL) , PrQ: W, Lcnt: N >
< O : Qu | Dealloc: NS, Ev: MM > 
if enabledGuard(G, (S # L), MM) .

*** Evaluate guards in suspended processes ***

crl [PrQ-ready] :
< O : C | Att: S, Pr: idle, PrQ: (L,SL) ++ W, Lcnt: N > 
< O : Qu | Dealloc: NS, Ev: MM >
=> 
< O : C | Att: S, Pr: (L,SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: NS, Ev: MM >
if ready(SL, (S # L), MM) .


eq < O : C | Att: S, Pr: idle, PrQ: (L, await wait ; SL) ++ W, Lcnt: N >  
 = < O : C | Att: S, Pr: idle, PrQ: (L, SL) ++ W, Lcnt: N > [label wait] .

eq < O : C | Att: S, Pr: idle, PrQ: (L, ((await wait ; SL)[] SL'); SL'')++ W,  
   Lcnt: N >  
 = < O : C | Att: S, Pr: idle, PrQ: (L, (SL [] SL'); SL'') ++ W, Lcnt: N >
[label wait-nondet] .

eq < O : C | Att: S, Pr: idle, PrQ: (L,((await wait ; SL)||| SL'); SL'')++ W,  
   Lcnt: N >  
 = < O : C | Att: S, Pr: idle, PrQ: (L, (SL ||| SL'); SL'') ++ W, Lcnt: N >
[label wait-merge] .

*** Optimization to avoid muiltiple lookups in the message queue for
*** the same guard
eq 
< O : C | Att: S, Pr: P, PrQ: (L, await (N ? & G); SL) ++ W, Lcnt: F > 
< O : Qu | Dealloc: NS, Ev: MM + comp(N, DL) >  
=
< O : C | Att: S,  Pr: P, PrQ: (L, await G ; SL) ++ W, Lcnt: F >    
< O : Qu | Dealloc: NS, Ev: MM + comp(N, DL) > .


*** METHOD CALLS ***

eq   ! Q(EL) =   ! 'this . Q(EL) . *** could alternatively use X@ this class

*** receive invocation message ***
rl [receive-call-req] :
< O : C | Att: S, Pr: P, PrQ: W, Lcnt: N >
< O : Qu | Dealloc: NS, Ev: MM + invoc(O', F, Q, EL) >
=>
< O : C | Att: S, Pr: P, PrQ: W, Lcnt: N >
< O : Qu | Dealloc: NS, Ev: MM > bindMtd(O, O', F, Q, EL, C < emp >) .

*** Method binding with multiple inheritance
ceq bindMtd(O, O',N,Q, EL,noInh) = 
boundMtd(O,(('caller |-> O', 'label |-> int(N)), return(emp)))
if Q == 'run .


eq bindMtd(O, O', N, M, EL, (C < EL' >) ## I')
< C : Cl | Inh: I , Par: AL, Att: S , Mtds: MS , Ocnt: F >
   =  if (M in MS) then boundMtd(O,get(M,MS,O', N, EL)) 
                   else bindMtd(O,O',N,M,EL, I ## I') fi 
< C : Cl | Inh: I , Par: AL, Att: S , Mtds: MS , Ocnt: F > .

rl [receive-call-req] :
< O : Qu | Dealloc: NS, Ev: MM + invoc(O', N, Q @ C, EL) >
=> < O : Qu | Dealloc: NS, Ev: MM >  bindMtd(O, O', N, Q, EL, C < emp >) .

rl [receive-call-bound] : 
boundMtd(O, P) < O : C | Att: S, Pr: idle, PrQ: W, Lcnt: N >
=> < O : C | Att: S, Pr: idle, PrQ: W ++ P, Lcnt: N > .

rl [continue] :
< O : C | Att: S, Pr: (L,cont(N)), PrQ: (L',((N ?(AL)); SL)) ++ W, Lcnt: F >
=>
*** < O : C | Att: S, Pr: (L',SL), PrQ: W, Lcnt: F > .
< O : C | Att: S, Pr: (L',((N ?(AL)); SL)), PrQ: W, Lcnt: F > .

rl [local-async-qualified-req] :
< O : C | Att: S, Pr: (L, ( ! Q @ C'(EL)); SL),PrQ: W, Lcnt: N >
=> 
< O : C | Att: S, Pr: (L, SL), PrQ: W, Lcnt: N + 1 >
invoc(O, N, Q @ C', evalList(EL, (S # L))) from O to O .

*** REMOTE METHOD CALLS ***
eq < O : C | Att: S, Pr: (L, (Q ! M(EL)); SL), PrQ: W, Lcnt: N >
=  < O : C | Att: S, Pr: (L, (Q ::= int(N)); (! M (EL));  SL), 
             PrQ: W,  Lcnt: N > .


rl [remote-async-reply] : 
< O : C | Att: S, Pr: (L, ( ! E . M(EL)); SL), PrQ: W, Lcnt: N >
=>
< O : C | Att: S, Pr: (L,SL), PrQ: W, Lcnt: N + 1 >
invoc(O, N, M , evalList(EL, (S # L))) from O to eval(E, (S # L)) .

*** Reduce sync. call  to async. call with reply 
eq < O : C | Att: S, Pr: (L, (M(EL ; AL)); SL), PrQ: W, Lcnt: N >
  =
  < O : C | Att: S, Pr: (L, (! M(EL)); (N ?(AL)); SL), PrQ: W,  Lcnt: N >  .

*** emit reply message ***
rl [return] :
< O : C |  Att: S, Pr: (L, (return(EL)); SL), PrQ: W, Lcnt: N >
=>
< O : C |  Att: S, Pr: (L, SL), PrQ: W, Lcnt: N > 
comp(evalN('label, L), evalList(EL, (S # L))) from O to eval('caller, L) .

*** Optimization: reduce label to value only once
eq < O : C |  Att: S, Pr: (L, (A ?(AL)); SL), PrQ: W, Lcnt: N > 
= < O : C |  Att: S, Pr: (L, (evalN(A,L) ?(AL)); SL), PrQ: W, Lcnt: N > .

eq
< O : C |  Att: S, Pr: (L, (N ? (AL)); SL), PrQ: W, Lcnt: F > 
< O : Qu | Dealloc: NS, Ev: MM + comp(N, DL) >
= 
< O : C |  Att: S, Pr: (L, (AL ::= DL); SL), PrQ: W, Lcnt: F > 
< O : Qu | Dealloc: NS, Ev: MM >
. 

*** We may here get (emp ::= emp), which should be reduced to skip .
eq (noAid ::= emp) = skip .

*** Transport rule: include new message in queue
rl [invoc-msg] :
< O : Qu | Dealloc: NS, Ev: MM > (MsgBody from O' to O)
=>
< O : Qu | Dealloc: NS, Ev: MM + MsgBody > .

*** generalize to lists of labels AL:
rl [free] :
< O : C | Att: S, Pr: (L, free(A) ; SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: NS, Ev: MM >
=>
< O : C | Att: S, Pr: (L,SL), PrQ: W, Lcnt: N > 
< O : Qu | Dealloc: (evalN(A, (S # L)) ; NS), Ev: MM > .

*** Deallocate
eq < O : Qu | Dealloc: (N ; NS), Ev: comp(N, DL) + MM >
= < O : Qu | Dealloc: NS, Ev: MM > .
endm

eof
