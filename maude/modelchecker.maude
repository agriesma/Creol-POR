***(

  Model checker variant of the interpreter.

)***

load datatypes

load signature-mc

*** AUXILIARY FUNCTIONS ***
fmod AUX-FUNCTIONS is
pr CONFIG .
protecting CONVERSION .

*** Signatures
op inqueue  : Label MMsg -> Bool . *** checks if  Msg is in the queue

op enabledGuard : Guard   Subst MMsg -> Bool .
op enabled      : StmList Subst MMsg -> Bool . *** eval guard 
op ready        : StmList Subst MMsg -> Bool . *** eval guard 

*** Variables
vars N N' : Nat .
vars L L' : Label .
vars E E' : Expr .
var EL : ExprList .
var A : Aid .
vars G1 G2 : Guard .
var S : Subst .
var MM : MMsg .
var C : Cid .
var  Q : Qid .

*************************** Names of new objects ********************
op newId : Cid Nat -> Oid .
eq newId(Q, N)  = ob(qid(string(Q) + string(N,10))) .
***** some code to make string/qid total 
*** Don't think we need this ?
*** op string : Nat    -> String  .
*** op string : Cid    -> String [ditto] .
*** op string : Oid    -> String [ditto] .
*** op string : Rat NzNat -> String [ditto] .
*** op qid    : Qid    -> Qid .
*** op qid    : String -> Qid [ditto] .
*** eq string(N)      = string(N,10) . 
*** eq qid(Q)         = Q .
*** eq qid(string(Q)) = Q .  
*** eq qid(string(C)) = qid(C) .  
*** eq qid(S:String)  = 'invalid [owise] . 



eq inqueue(L, noMsg) = false .
*** eq inqueue(N, comp(N', E)) = if N == N' then true else false fi .
eq inqueue(L, comp(L', EL) + MM) = 
     if L == L' then true else inqueue(L, MM) fi .


eq enabledGuard(noGuard, S, MM)   = true .
eq enabledGuard(wait, S, MM)      = false .       *** Note: no wait in PrQ!
eq enabledGuard(E, S, MM)         = evalB(E, S) .
eq enabledGuard((A ?), S, MM)     = inqueue(eval(A, S), MM) .
eq enabledGuard((L ?), S, MM)     = inqueue(L, MM) .
***(eq enabledGuard((G1 & G2), S, MM) = enabledGuard(G1, S, MM) and enabledGuard(G2, S, MM) . *** may skip termination problems! due to Id: noguard
)
*** red enabledGuard((int(5) > int(7)), noSub, noMsg) .
*** red int(4) add int(5) .
*** red (int(4) add int(5)) > (int(7) add int(19)) .
*** red upTerm((int(4) add int(5)) > (int(7) add int(19))) .
*** red downTerm(upTerm((int(4) add int(5)) > (int(7) add int(19))), (int(0)).Expr) .

  vars  ST ST' : Stm . 
  vars SL SL' SL'' : StmList . 
  var NeSL : NeStmList .

  eq enabled((SL [] SL'); SL'',  S, MM) =
    enabled(SL, S, MM) or enabled(SL', S, MM) .
  eq enabled((SL ||| SL'); SL'', S, MM) =
    enabled(SL, S, MM) or enabled(SL', S, MM) .
  eq enabled((await G1); SL'',   S, MM) = enabledGuard(G1, S, MM) .
  eq enabled(ST ; SL'',    S, MM) = true [owise]. 

  eq ready((SL [] SL'); SL'',  S, MM) = ready(SL, S, MM) or ready(SL', S, MM) .
  eq ready((SL ||| SL'); SL'', S, MM) = ready(SL, S, MM) or ready(SL', S, MM) .
  eq ready((A ?(E)); SL'',     S, MM) = inqueue(eval(A, S), MM) . 
  eq ready((L ?(E)); SL'',     S, MM) = inqueue(L, MM) . 
  eq ready(ST ; SL'',          S, MM) = enabled(ST, S, MM) [owise]. 

***( transform wait guards when active code is suspended. remove all waits.
op clear : Guard  -> Guard . 
eq clear(noGuard) = noGuard .
eq clear(wait)    = noGuard . 
eq clear(E)       = E .
eq clear((Q ?))   = (Q ?) .
eq clear((N ?))   = (N ?) .
eq clear(G1 & G2) = clear(G1) & clear(G2) .  *** term. problems!

op clear : StmList -> StmList . 
*** eq clear(nil)     = nil . 
eq clear(await G1)   = await(clear(G1)) .
eq clear(SL [] SL')  = clear(SL) [] clear(SL') .
eq clear(SL ||| SL') = clear(SL) ||| clear(SL') .
eq clear(SL ; NeSL)  = clear(SL) ; NeSL .
eq clear(SL)         = SL [owise] .
)

endfm

*** THE MACHINE ***
mod INTERPRETER is
pr AUX-FUNCTIONS .

vars O O' : Oid .
vars C C' : Cid .
var A : Aid .
var AL : AidList .
var D : Data .
var DL : DataList .
vars E E' : Expr .
vars EL EL' : ExprList .
var ST : Stm .
vars SL SL' SL'' : StmList .
vars SL1 SL2 : NeStmList .
var P : Process .
var W : MProc .
vars S S' L L' : Subst .
vars N F : Nat .
vars I I' : InhList .
var MS : MMtd .
var LS : Labels .
vars Lab Lab' : Label .
var MM : MMsg .
var G : Guard .
var M : Mid .
var Q : Qid .
var MsgBody : Body .

*** multiple assignment
eq [assign-multiple] :
  < O : C | Att: S, Pr: (L,(AL ::= EL); SL), PrQ: W, Lcnt: N >
  =
  < O : C | Att: S, Pr: (L, (assign(AL, evalList(EL, (S # L))); SL)), 
    PrQ: W, Lcnt: N > .

eq [assign] :
  < O : C | Att: S, Pr: (L, assign((A ,, AL), (D # DL)); SL), PrQ: W, Lcnt: N >
  =
  if dom(A,S) then
    < O : C | Att: insert(A, D, S), Pr: (L, assign(AL, DL); SL), PrQ: W, Lcnt: N > 
  else
    < O : C | Att: S, Pr: (insert(A, D, L), assign(AL, DL); SL), PrQ: W, Lcnt: N > 
  fi .

eq [assign-skip] :
  < O : C | Att: S, Pr: (L, assign(noAid, emp); SL), PrQ: W, Lcnt: N >
  =
  < O : C | Att: S, Pr: (L, SL), PrQ: W, Lcnt: N > .

eq [skip] :
  < O : C | Att: S, Pr: (L, skip ; SL), PrQ: W, Lcnt: N >
  =
  < O : C | Att: S, Pr: (L, SL), PrQ: W, Lcnt: N > .


eq [if-el] :
  < O : C | Att: S, Pr: (L, if E th SL' el SL'' fi ; SL), PrQ: W, Lcnt: N >
  =
  if eval(E, (S # L)) asBool then
    < O : C | Att: S, Pr: (L, SL' ; SL), PrQ: W, Lcnt: N >
  else
    < O : C | Att: S, Pr: (L, SL'' ; SL), PrQ: W, Lcnt: N >
  fi .


***(
  We want to be able to observe what happens here in an infinite loop.
  therefore, each expansion of a while body is done by a rule. )

rl [while] :
  < O : C | Att: S, Pr: (L, while E do SL1 od ; SL2), PrQ: W, Lcnt: N >
  =>
  < O : C | Att: S, 
      Pr: (L, (if E th (SL1 ; while E do SL1 od) el skip fi); SL2),
      PrQ: W, Lcnt: N > .


eq [new-object] :
  < O : C | Att: S,Pr: (L, (A ::= new C' (EL)); SL),PrQ: W, Lcnt: N > 
  < C' : Cl | Inh: I , Par: AL, Att: S' , Mtds: MS , Ocnt: F >
  =
  < O : C | Att: S, Pr: (L, (A ::= newId(C', F)); SL), PrQ: W, Lcnt: N >
  < C' : Cl | Inh: I , Par: AL, Att: S' , Mtds: MS , Ocnt: (F + 1) >
  < newId(C',F) : C' | Att: S, Pr: idle, PrQ: noProc, Lcnt: 1 >
  < newId(C',F) : Qu | Dealloc: noDealloc, Ev: noMsg > 
  findAttr(newId(C',F), I, S', 
    (AL ::= evalList(EL, (S # L))), ('init (emp ; emp)) ; ('run (emp ; emp))) .

*** ATTRIBUTE inheritance with multiple inheritance
*** CMC assumes that all attributes names are (globally) different

op findAttr  : Oid InhList Subst StmList StmList -> Msg [ctor] . *** collect attributes
op foundAttr : Oid Subst  StmList StmList        -> Msg [ctor] . *** resulting Subst
*** look in InhList, collect attributes in Subst, give result to Oid
*** SL SL' SL''

eq findAttr(O, noInh, S, SL, SL')  *** collection completed.
       = foundAttr(O, S, SL, SL') .

eq findAttr(O,((C < EL >) ## I),S, SL, SL') 
< C : Cl | Inh: I', Par: AL, Att: L, Mtds: MS, Ocnt: F >
 = findAttr(O, I ## I',(L # S), (AL ::= EL) ; SL, 
              ('init @ C(emp ; emp)) ; SL') 
   < C : Cl | Inh: I', Par: AL, Att: L, Mtds: MS, Ocnt: F > .

eq foundAttr(O, S', SL, SL') 
< O : C | Att: S, Pr: idle, PrQ: W, Lcnt: N >
 = < O : C | Att: ('this |-> O, S'), Pr: (noSub, SL ; SL'), PrQ: W, Lcnt: N > .

*** Non-deterministic choice ***
*** Choice is comm, so [nondet] considers both SL1 and SL2.
crl [nondet] :
< O : C | Att: S, Pr: (L, (SL1 [] SL2); SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
=>
< O : C | Att: S, Pr: (L, (SL1 ; SL)), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
if ready(SL1, (S # L), MM) .  

*** Merge ***
*** Merge is comm, so [merge] considers both SL1 and SL2.
crl [merge] :
< O : C | Att: S, Pr: (L, (SL1 ||| SL2); SL), PrQ: W, Lcnt: N >  
< O : Qu | Dealloc: LS, Ev: MM >
=>
< O : C | Att: S, Pr: (L, (SL1 MERGER SL2); SL), PrQ: W, Lcnt: N >  
< O : Qu | Dealloc: LS, Ev: MM >
if ready(SL1,(S # L), MM) . 

eq [merge-aux] :
< O : C | Att: S,  Pr:  (L, ((ST ; SL') MERGER SL2); SL), PrQ: W, Lcnt: N >   
< O : Qu | Dealloc: LS, Ev: MM >
=
< O : Qu | Dealloc: LS, Ev: MM >
if enabled(ST,(S # L), MM) then
< O : C | Att: S, Pr: (L, ((ST ; (SL' MERGER SL2)); SL)), PrQ: W, Lcnt: N >   
else
< O : C | Att: S, Pr: (L, ((ST ; SL') ||| SL2); SL), PrQ: W, Lcnt: N >   
fi .

eq [continue2] :
< O : C | Att: S, Pr: (L, (cont(Lab) MERGER SL'); SL''), 
          PrQ: (L', ((Lab ?(A)); SL)) ++ W, Lcnt: F >
=
< O : C | Att: S, Pr: (L',((((Lab ?(A)) ; SL) MERGER SL'); SL'')), 
          PrQ: W, Lcnt: F > .

*** local call 
ceq boundMtd(O, (L', SL')) 
< O : C | Att: S,Pr: (L, ((Lab ?(EL)); SL)),PrQ: W,Lcnt: F >
= 
< O : C | Att: S,Pr: (L', SL' ; cont(Lab)),PrQ: (L,((await Lab ?) ; (Lab ?(EL)); SL)) ++ W,
          Lcnt: F > 
if (L'['label] == Lab) .

*** local call within merge
ceq boundMtd(O, (L', SL')) 
< O : C | Att: S,Pr: (L,(((Lab ?(EL)); SL) MERGER SL'')),PrQ: W,Lcnt: F >
= 
< O : C | Att: S,Pr: (L', SL'),
          PrQ: (L, (((await Lab ?) ; (Lab ?(EL)); SL) MERGER SL'')) ++ W,Lcnt: F > 
if (L'['label] == Lab) .

*** Suspension ***

ceq [suspend] :  *** all kinds of code P 
< O : C | Att: S, Pr: (L,SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
=
< O : C | Att: S, Pr: idle, PrQ: W ++ (L, SL), Lcnt: N > *** clear(SL)
< O : Qu | Dealloc: LS, Ev: MM >
if not enabled(SL, (S # L), MM) . 

*** Guards ***

ceq [guard] :
< O : C | Att: S, Pr: (L, await G ; SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
=
< O : C | Att: S, Pr: (L,SL) , PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM > 
if enabledGuard(G, (S # L), MM) .

*** Evaluate guards in suspended processes ***

crl [PrQ-ready] :
< O : C | Att: S, Pr: idle, PrQ: (L,SL) ++ W, Lcnt: N > 
< O : Qu | Dealloc: LS, Ev: MM >
=>
< O : C | Att: S, Pr: (L,SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
if ready(SL, (S # L), MM) .


*** Evaluation of wait in PrQ *** (avoiding clear)

*** rl [wait] :
eq [wait] :
< O : C | Att: S, Pr: idle, PrQ: (L, await wait ; SL) ++ W, Lcnt: N >  
 =
< O : C | Att: S, Pr: idle, PrQ: (L, SL) ++ W, Lcnt: N > .

eq [wait-nondet] :
< O : C | Att: S, Pr: idle, PrQ: (L, ((await wait ; SL)[] SL'); SL'')++ W,  
   Lcnt: N >  
 = < O : C | Att: S, Pr: idle, PrQ: (L, (SL [] SL'); SL'') ++ W, Lcnt: N > .

eq [wait-merge] : < O : C | Att: S, Pr: idle, PrQ: (L,((await wait ; SL)||| SL'); SL'')++ W,  
   Lcnt: N >  
 = < O : C | Att: S, Pr: idle, PrQ: (L, (SL ||| SL'); SL'') ++ W, Lcnt: N > .

*** Optimization to avoid muiltiple lookups in the message queue for
*** the same guard
eq 
< O : C | Att: S, Pr: P, PrQ: (L, await (Lab ? & G); SL) ++ W, Lcnt: F > 
< O : Qu | Dealloc: LS, Ev: MM + comp(Lab, EL) >  
=
< O : C | Att: S,  Pr: P, PrQ: (L, await G ; SL) ++ W, Lcnt: F >    
< O : Qu | Dealloc: LS, Ev: MM + comp(Lab, EL) > .


*** METHOD CALLS ***

eq   ! Q(EL) =   ! 'this . Q(EL) . *** could alternatively use X@ this class

*** receive invocation message ***
rl [receive-call-req] :
< O : C | Att: S, Pr: P, PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM + invoc(O', Lab, Q, EL) >
=>
< O : C | Att: S, Pr: P, PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM > bindMtd(O, O', Lab, Q, EL, C < emp >) .

*** Method binding with multiple inheritance
ceq bindMtd(O, O',Lab,Q, EL,noInh) = 
boundMtd(O,(('caller |-> O', 'label |-> Lab), return(emp)))
if Q == 'run .


eq bindMtd(O,O', Lab, M,EL,(C < EL' >) ## I') 
< C : Cl | Inh: I , Par: AL, Att: S , Mtds: MS , Ocnt: F >
   =  if (M in MS) then boundMtd(O,get(M,MS,O',  Lab, EL)) 
                   else bindMtd(O,O', Lab,M,EL, I ## I') fi 
< C : Cl | Inh: I , Par: AL, Att: S , Mtds: MS , Ocnt: F > .

rl [receive-call-req] :
< O : Qu | Dealloc: LS, Ev: MM + invoc(O', Lab, Q @ C, EL) >
=>
< O : Qu | Dealloc: LS, Ev: MM >  bindMtd(O, O', Lab, Q, EL, C < emp >) .

eq [receive-call-bound] : 
boundMtd(O, P) < O : C | Att: S, Pr: idle, PrQ: W, Lcnt: N >
=
< O : C | Att: S, Pr: P, PrQ: W, Lcnt: N >
.

eq [continue] :
< O : C | Att: S, Pr: (L,cont(Lab)), PrQ: (L',((Lab ?(EL)); SL)) ++ W, Lcnt: F >
=
< O : C | Att: S, Pr: (L',((Lab ?(EL)); SL)), PrQ: W, Lcnt: F > .

eq [local-async-qualified-req] :
< O : C | Att: S, Pr: (L, ( ! Q @ C'(EL)); SL),PrQ: W, Lcnt: N >
= 
< O : C | Att: S, Pr: (L, SL), PrQ: W, Lcnt: N + 1 >
invoc(O, label(N), Q @ C', evalList(EL, (S # L))) from O to O .

*** REMOTE METHOD CALLS ***
eq [remote-call] :
  < O : C | Att: S, Pr: (L, (Q ! M(EL)); SL), PrQ: W, Lcnt: N >
  =
  < O : C | Att: S, Pr: (L, (Q ::= int(N)); (! M (EL));  SL),
    PrQ: W,  Lcnt: N > .


eq [remote-async-reply] : 
< O : C | Att: S, Pr: (L, ( ! E . M(EL)); SL), PrQ: W, Lcnt: N >
=
< O : C | Att: S, Pr: (L,SL), PrQ: W, Lcnt: N + 1 >
invoc(O, label(N), M , evalList(EL, (S # L))) from O to eval(E, (S # L)) .

*** Reduce sync. call  to async. call with reply 
eq < O : C | Att: S, Pr: (L, (M(EL ; EL')); SL), PrQ: W, Lcnt: N >
  =
< O : C | Att: S, Pr: (L, (! M(EL)); (label(N) ?(EL')); SL), PrQ: W,  Lcnt: N >  .

*** emit reply message ***
eq [return] :
< O : C |  Att: S, Pr: (L, (return(EL)); SL), PrQ: W, Lcnt: N >
=
< O : C |  Att: S, Pr: (L, SL), PrQ: W, Lcnt: N > 
comp(eval('label, L), evalList(EL, (S # L))) from O to eval('caller, L) .

*** Optimization: reduce label to value only once
eq < O : C |  Att: S, Pr: (L, (A ?(EL)); SL), PrQ: W, Lcnt: N > 
= < O : C |  Att: S, Pr: (L, (eval(A,L) ?(EL)); SL), PrQ: W, Lcnt: N > .

*** blocking reply sentence ***
eq [block-sync-reply] :
< O : C |  Att: S, Pr: (L, (Lab ? (EL)); SL), PrQ: W, Lcnt: F > 
< O : Qu | Dealloc: LS, Ev: MM + comp(Lab, EL') >
= 
< O : C |  Att: S, Pr: (L, (EL ::= EL'); SL), PrQ: W, Lcnt: F > 
< O : Qu | Dealloc: LS, Ev: MM > .

*** We may here get (emp ::= emp), which should be reduced to skip .
eq (emp ::= emp) = skip .

*** Transport rule: include new message in queue
eq [invoc-msg] :
< O : Qu | Dealloc: LS, Ev: MM > (MsgBody from O' to O)
=
< O : Qu | Dealloc: LS, Ev: MM + MsgBody > .

*** generalize to lists of labels AL:
eq [free] :
< O : C | Att: S, Pr: (L, free(A) ; SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
=
< O : C | Att: S, Pr: (L,SL), PrQ: W, Lcnt: N > 
< O : Qu | Dealloc: (eval(A, (S # L)) ^ LS), Ev: MM > .

*** Deallocate
eq < O : Qu | Dealloc: (Lab ^ LS), Ev: comp(Lab, EL) + MM >
= < O : Qu | Dealloc: LS, Ev: MM > .
endm

eof
