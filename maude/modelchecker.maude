***(

  Model checker variant of the interpreter.

)***


fmod DATA is 

  protecting META-LEVEL .
  protecting QID .
  protecting STRING .
  protecting INT .
  protecting NAT .
  protecting FLOAT .

  sorts   Aid Oid Data Label Appl Expr .   *** Aid = attribute identifier
  subsort Oid < Data < Expr .              *** Oid = object identifier
  subsort Appl < Expr .                    *** Appl = function application
  subsort Label < Data .
  subsort Qid < Aid < Expr .
  sorts   AidList ExprList DataList .
  subsort Aid < AidList .
  subsort Expr < ExprList .
  subsort Data < DataList  < ExprList .

  op emp : -> DataList [ctor] .
  op _#_ : ExprList ExprList -> ExprList [ctor assoc id: emp prec 25] .
  *** op _#_ : NeExprList ExprList -> NeExprList [ctor ditto] .
  *** op _#_ : ExprList NeExprList -> NeExprList [ctor ditto] .
  op _#_ : DataList  DataList  -> DataList [ctor ditto] .

  op noAid : -> AidList [ctor] .
  op _,,_ : AidList AidList -> AidList [ctor comm assoc id: noAid] .

  op _[[_]] : Qid ExprList -> Appl . *** function application

  *** Basic conversion of data types into sort Data
  op null    :           -> Data [ctor] . *** undef. value/none pointer
  op ob      : Qid       -> Oid  [ctor] .
  op int(_)  : Int       -> Data [ctor format(o o ! o o)] . 
  op float(_): Float     -> Data [ctor format(o o ! o o)] . 
  op str(_)  : String    -> Data [ctor format(o o ! o o)] .
  op bool(_) : Bool      -> Data [ctor format(o o ! o o)] .
  op label   : Nat       -> Label [ctor] . *** label values

  *** Reconversion for evaluation
  op _asInt             : Data -> Int .
  op _asNat             : Data -> Nat .
  op _asBool            : Data -> Bool .
  op _asStr             : Data -> String .
 

  var N : Nat .
  var I : Int .
  var B : Bool .
  var S : String .

  eq int(I)  asInt      = I . 
  eq int(N)  asNat      = N .  *** otherwise error, i.e. irreducible...
  eq bool(B) asBool     = B .
  eq str(S)  asStr      = S .

  *** red int(4) .
  *** red int(4) asInt .

endfm  

fmod DATATYPES is  
  *** may easily keep various data types on separate file(s), 
  *** and plug in upon need.
  protecting DATA .

  op list : ExprList     -> Expr . *** lists
  op list : DataList     -> Data [ctor] . *** lists of data
  op setl : ExprList     -> Expr .        *** set
  op setl : DataList     -> Data [ctor] . *** set
  op pair : Expr Expr    -> Expr .        *** pairs
  op pair : Data Data    -> Data [ctor] . *** pairs

  vars I I'     : Int .
  vars N        : Nat .
  vars F F'     : Float .
  vars S S'     : String . 
  vars D D'     : Data .
  vars E E'     : Expr .
  vars L L' L'' : ExprList .
  
  *** reduction for sets 
  eq  setl(L # E # L' # E # L'') = setl(L # E # L' # L'') .
  ceq setl(D # D' # L) = setl(D' # D # L) if ('less[[D' # D]]) asBool .
  *** ceq setl(L # D # L' # D' # L'') = setl(L # D' # L' # D # L'') 
  *** if (D > D')asBool . *** old

  *** EVALUATION      
  *** eq char(int(I))	= str(char(I)) .
  eq 'neg[[int(I)]]	= int(-(I)) .
  eq 'fst[[pair(E, E')]]   = E . 
  eq 'scd[[pair(E, E')]]   = E' .
  
  *** equal-func for all (!) data types
  eq 'equal[[D # D']]	       = bool(D == D') .
  
  *** bool-functions
  eq 'not[[bool(false)]]    = bool(true) .  
  eq 'not[[bool(true )]]    = bool(false) . 
  eq 'or[[bool(true)#   E]] = bool(true) .
  eq 'or[[bool(false)#  E]] =  E .
  eq 'and[[bool(false)# E]] = bool(false) .
  eq 'and[[bool(true)#  E]] =  E .
  
  *** less-func
  eq 'less  [[int(I)# int(I')]] = bool(I < I') .
  eq 'lessEq[[int(I)# int(I')]] = bool(I <= I') .
  eq 'less  [[float(F)# float(F')]] = bool(F < F') .
  eq 'lessEq[[float(F)# float(F')]] = bool(F <= F') .
  eq 'less  [[str(S)# str(S')]] = bool(S < S') .
  eq 'lessEq[[str(S)# str(S')]] = bool(S <= S') .
  
  *** list-functions
  eq 'head[[list(emp)]]	= null .
  eq 'head[[list(E # L)]]	= E .
  eq 'last[[list(emp)]]	= null .
  eq 'last[[list(L # E)]]	= E .
  eq 'rest[[list(emp)]]	= null .
  eq 'rest[[list(L # E)]]	= list(L) .
  eq 'tail[[list(emp)]]	= null .
  eq 'tail[[list(E # L)]]	= list(L) .

  ***eq 'length[[list(null)]]  = int(0) .
  eq 'length[[list(emp)]]   = int(0) .
  eq 'length[[list(E # L)]] = int(1) + ('length[[list(L)]]) .
  eq 'length[[setl(E # L)]] = int(1) + ('length[[setl(L)]]) .
  
  eq 'isempty[[list(emp)]]  = bool(true) .
  eq 'isempty[[list(E # L)]]= bool(false) .
  
  eq 'remove[[list(E)#   E']]  = if  E == E' then list(emp) else list(E) fi .
  eq 'remove[[list(emp)# E ]]  = list(emp) .
  eq 'remove[[list(E # L)# E']]  = if E == E' then 'remove[[(list(L))# E']] 
			  else 'plus[[list(E)# ('remove[[(list(L))# E']])]] fi .
  eq 'remove[[setl(E)#   E']]  = if  E == E' then setl(emp) else setl(E) fi .
  eq 'remove[[setl(emp)# E ]]  = setl(emp) .
  eq 'remove[[setl(E # L)# E']] = if E == E' then setl(L)
			 else 'plus[[setl(E)#('remove[[(setl(L))# E']])]] fi .
 
  eq 'appendLeft [[list(L)# E]]     = list(E # L) .
  eq 'addFirst   [[list(L)# E]]     = list(E # L) .   *** alias
  eq 'appendRight[[list(L)# E]]     = list(L # E) .
  eq 'add[[list(L)#    E]]          = list(L # E) .    *** alias
  eq 'add[[setl (L)#    E]]         = setl(L # E) .    

  eq 'has[[list(emp)# E ]]	  = bool(false) .
  eq 'has[[list(E # L)# E']]        = if (E' == E) then bool(true)
			      else 'has[[list(L)# E']] fi .
  eq 'has[[setl(emp)#  E ]]	  = bool(false) .
  eq 'has[[setl(E # L)#  E']]       = if (E' == E) then bool(true)
			        else 'has[[setl(L)# E']] fi .
  ***index starts at 1
  eq 'after[[list(emp)# int(N)]]    = null . 
  eq 'after[[list(E # L)# int(0)]]  = list(E # L) .
  eq 'after[[list(E # L)# int(N)]]  =
    'after[[(list(L))# 'minus[[int(N) # int(1) ]] ]] .

  eq 'index[[(list(L))#   int(0)]]  = null .
  eq 'index[[(list(emp))# int(N)]]  = null .
  eq 'index[[(list(E # L))# int(N)]]= if (N == 1) then E else
				  'index[[(list(L))# int( _-_(N,1))]] fi .

  eq 'begwith[[list(E)# E']]        = bool('head[[(list(E))]] == E') .
  eq 'begwith[[list(E # L)# E']]    = bool('head[[(list(E # L))]] == E') .
  eq 'endwith[[list(E)# E']]        = bool('last[[(list(E))]] == E') .
  eq 'endwith[[list(E # L)# E']]    = bool('last[[(list(L))]] == E') .

  eq 'plus  [[list(L)# list(L')]]   = list(L # L').
  eq 'plus  [[setl(L)# setl(L')]]   = setl(L # L').
  eq 'plus  [[str(S)# str(S')]]     = str(S + S').
  eq 'plus  [[int(I)# int(I')]]     = int(I + I').
  eq 'plus  [[float(F)# float(F')]] = float(F + F').

  eq 'minus [[int(I)# int(I')]]     = int( _-_(I, I')).
  eq 'minus [[float(F)# float(F')]] = float(_-_(F, F')).

  eq 'times [[int(I)# int(I')]]     = int(I * I').
  eq 'times [[float(F)# float(F')]] = float(F * F').

  eq 'div   [[int(I)# int(I')]]     = int(I quo I').
  eq 'div   [[float(F)# float(F')]] = float(F / F').

  eq  'setl[[list(L)]] = setl(L).
  eq  'list[[setl(L)]] = list(L).
  ***var Q : Qid .
  ***eq  Q[[setl(L)# setl(L')]] = 'setl[[Q[[list(L)# list(L')]]]].

endfm

view Aid from TRIV to DATA is
  sort Elt to Aid .
endv

view Data from TRIV to DATA is
  sort Elt to Data .
endv


*** Bound variables ***
fmod SUBST is
  *** protecting META-LEVEL .
  protecting DATATYPES .
  protecting MAP{Aid, Data} * (sort Map{Aid, Data} to Subst) .

  op noSub : -> Subst .
  eq noSub = (empty).Subst .

  op dom : Aid Subst -> Bool .

  *** Non-comm composition operator for substitutions
  op _#_ : Subst Subst -> Subst .


  vars A A' : Aid . var D : Data . vars S1 S2  : Subst .

  eq S1 # empty = S1 .
  eq S1 # ((A |-> D), S2) = insert(A,D,S1) # S2 .

  eq dom(A, empty) = false .
  eq dom(A, ((A' |-> D), S1)) = if A == A' then true else dom(A, S1) fi .
  eq dom(A, S1 # S2) = dom(A, S1) or dom(A, S2) .

  ***  eq element(E, emp) = false .
  ***  eq element(E, E' # L) = if E == E' then true else element(E, L) fi .

  *** red insert('var1, str("test"), noSub) .
  *** red insert('var2, int(4), insert('var1, str("test"), noSub)) .
  *** red insert('var2, int(4), insert('var1, str("test"), noSub)) ['var1] .
  *** red upTerm(insert('var1, str("test"), noSub)) .
  *** red downTerm(upTerm(insert('var1, str("test"), noSub)),noSub) .
  *** red downTerm(upTerm(insert('var2, int(4), insert('var1, str("test"), noSub)) ['var1]), null) .
  *** red dom('var1, insert('var2, int(4), insert('var1, str("test"), noSub))) .
endfm

fmod EVAL is
  protecting SUBST . 

  *** Evaluation of expressions
  op eval	    : Expr Subst     -> Data .     *** evaluate expression
  op evalB    : Expr Subst     -> Bool .
  op evalI    : Expr Subst     -> Int .
  op evalS    : Expr Subst     -> String .
  op evalList : ExprList Subst -> ExprList . *** maps list to values

  *** Variables
  var E E' : Expr .     var EL : ExprList .     var D : Data .
  var A : Aid .         var S : Subst .         var Q : Qid .
  var I : Int .         var B : Bool .          var STR : String .

  eq eval(A, S) =  S [A] .
  eq eval(D, S) = D .                                *** data

  eq evalI(E,S) = eval(E,S) asInt .                  *** expressions
  eq evalB(E,S) = eval(E,S) asBool .                 *** expressions
  eq evalS(E,S) = eval(E,S) asStr .                  *** expressions

  *** standard evaluation of expression
  eq eval(pair(E,E'),S) = pair(eval(E,S),eval(E',S)) . 
  eq eval(list(EL), S)  = list(evalList(EL, S)) .       
  eq eval(setl(EL), S)  = setl(evalList(EL, S)) .   
  eq eval(Q [[EL]], S)  = Q [[ evalList(EL, S) ]] .   

  *** lists  
  eq evalList(emp, S)   = emp .
  eq evalList(E # EL, S)= eval(E, S) # evalList(EL, S) .
            *** creol function Q defined directly by functions
  *** eq evalList(E, S)   = eval(E, S) . *** not needed
endfm


fmod GUARDS is
  protecting EVAL .

  sorts     NoGuard Guard Wait Return PureGuard . 
  subsorts  Return Expr < PureGuard .
  subsorts  NoGuard Wait PureGuard < Guard .

  op noGuard : -> NoGuard [ctor] . 
  op wait :    -> Wait [ctor] .           *** suspension
  op _?  : Aid -> Return [ctor] .         *** reply guard
  op _?  : Label -> Return [ctor] .       *** low level reply guard
  op _&_ : Guard Guard -> Guard [ctor id: noGuard assoc comm prec 55] .
  op _&_ : PureGuard PureGuard -> PureGuard [ditto] .

  *** reduction of guards to normalform: [wait &]? [bool &]? return ***
  vars E  E' : Expr . var PG : PureGuard .
  eq   wait & wait = wait .
  eq   PG   & PG   = PG .
  eq   E    & E'   = 'and[[E # E']] .

  *** red int(4) & int(5) .
  *** red upTerm(int(4) & int(5)) .
  *** red upTerm(int(4) & int(5) & wait) .
  *** red downTerm(upTerm(int(4) & int(5) & wait), noGuard) .
  *** red 'test ? .
  *** red int(4) add int(5) & 'label ? & wait & bool(true) & wait .
  *** red upTerm(int(4) add int(5) & 'label ? & wait & bool(true) & wait) .
  *** red downTerm(upTerm(int(4) add int(5) & 'label ? & wait & bool(true) & wait), noGuard) .
endfm

fmod STATEMENTS is
  pr GUARDS .

  sorts Mid Cid Stm .             *** Mid = method identifiers
  subsort Qid < Mid Cid .         *** Cid = class identifiers

  op _._   : Expr Mid -> Mid [ctor] . *** remote call
  op _@_   : Qid  Cid -> Mid [ctor] . *** method qualified by class name (local)
  *** op _@_   : Aid  Cid -> Aid [ctor] . *** attribute qualified by class name (local)

  *** CREOL program syntax
  op skip : -> Stm [ctor] .
  op _::=_  : AidList ExprList -> Stm [ctor] .       *** simple assignment
  op _::= new_(_) : Aid Cid ExprList -> Stm [ctor] . *** object creation
  op _(_;_) : Mid ExprList ExprList -> Stm [ctor] .  *** sync. call
  op !_(_)  : Mid ExprList -> Stm [ctor] .           *** async. call (without label)
  op _!_(_) : Qid Mid ExprList -> Stm [ctor] .       *** async. call (with label)
  op _?(_)  : Qid ExprList -> Stm [ctor] .           *** async. reply statement
  op _?(_)  : Label ExprList -> Stm [ctor] .         *** sync reply
  op cont : Label -> Stm [ctor] .                    *** sync. scheduling
  op await_ : Guard    -> Stm [ctor] .               *** guard statements
  op return : ExprList -> Stm [ctor] .               *** method return
  op free : AidList -> Stm [ctor] .                  *** deallocation for labels
  *** red 'var ::= int(4) .
  *** red 'var ::= new 'C (int(5) # bool(true)) .
  *** red upTerm('var ::= new 'C (null)) .
  *** red downTerm(upTerm('var ::= new 'C (int(5) # bool(true))), skip) .
  *** red await 'test ? .
  *** red await (('test ?) & wait) .
  *** red downTerm(upTerm(await (('test ?) & wait)), skip) .
  *** red ! 'method (null) .
  *** red cont (5) .
  *** red downTerm(upTerm(cont (5)),skip) .
  *** red downTerm(upTerm('getNeighbor(null ; null)), skip) .
  *** red 'label ! ('oid . 'mtd) (noExpr) .
  *** red downTerm(upTerm('label ! ('oid . 'mtd) (noExpr)), skip) .
endfm

view Stm from TRIV to STATEMENTS is
   sort Elt to Stm .
endv

fmod STM-LIST is
  pr STATEMENTS .                
  protecting LIST{Stm} * (sort List{Stm} to StmList,
                          sort NeList{Stm} to NeStmList) .

  op if_th_el_fi : Expr StmList StmList -> Stm [ctor] . 
  op if_th_fi    : Expr StmList -> Stm [ctor] . 
  op while_do_od : Expr StmList -> Stm [ctor] .
  op _[]_  : StmList StmList -> Stm [ctor comm assoc] .          *** choice
  op _|||_ : StmList StmList -> Stm [ctor comm assoc] .          *** merge
  op _MERGER_  : StmList StmList -> Stm [assoc] .                *** aux merge
  op _;_ :   StmList StmList -> StmList [ctor assoc id: nil] . *** seq. comp.

  var SL : StmList .  *** note: SL matches also empty
  var NeSL : NeStmList .
  var EL : ExprList .
  var B : Expr .
  var R : Return .
  var PG : PureGuard .

  *** Some simplifications:
  eq await noGuard ; NeSL = NeSL . *** could be SL
  ***  eq skip ; SL = SL . *** may affect ||| order 
  eq (nil []  SL)  = SL . 
  eq (nil ||| SL)  = SL . 
  eq (nil MERGER SL)      = SL .
  eq (SL MERGER nil)      = SL .
  *** eq (noAid ::= EL); SL   = SL .
  eq (noAid ::= EL)  = skip .

  eq await (wait & PG) = await wait ; await PG .
  *** eq await (R & PG)= await R ; await PG . --- could be rule for confluence!

  eq if B th SL fi = if B th SL el nil fi .  *** compiler stuff

  *** red ('var ::= int(4)) [] ('var ::= new 'C (null)) .
  *** red downTerm(upTerm(('var ::= int(4)) [] ('var ::= new 'C (null))), skip) .
  *** red (('var ::= int(4)) [] ('var ::= new 'C (null))) ||| skip .
  *** red downTerm(upTerm((('var ::= int(4)) [] ('var ::= new 'C (null))) ||| skip),skip) .
  *** red (('var ::= int(4)) [] ('var ::= new 'C (null))) ||| empty ||| skip .
  *** red downTerm(upTerm((('var ::= int(4)) [] ('var ::= new 'C (null))) ||| emp ||| skip), skip) .
  *** red downTerm(upTerm((('var ::= int(4)) [] ('var ::= new 'C (null))) ||| nil ||| skip), nil) .

  sorts Process NeMProc MProc .
  subsort Process < NeMProc < MProc .    *** Multiset of Processes
  op noProc : -> MProc [ctor] .
  op _++_ : NeMProc MProc -> NeMProc [ctor assoc comm id: noProc] .
  op _++_ : MProc NeMProc -> NeMProc [ctor assoc comm id: noProc] .
  op _++_ : MProc MProc   -> MProc   [ctor assoc comm id: noProc] .

  *** A Process is a pair of Prog and bound variables ***
  op idle : -> Process [format (!b o)] .  
  op _,_ : Subst StmList -> Process [ctor format (o r nb o)] . 
  var L : Subst .
  eq (L, nil) = idle . *** if 'label is needed this is dangerous!
  **** eq idle = (noSub, nil).  *** may use in right hand sides, but not left.

  *** red ((('var ::= int(4)) [] ('var ::= new 'C (null))) ||| skip), insert('var2, int(4), insert('var1, str("test"), noSub)) .
  *** red upTerm(((('var ::= int(4)) [] ('var ::= new 'C (null))) ||| skip), insert('var2, int(4), insert('var1, str("test"), noSub))) .
  *** red downTerm(upTerm(((('var ::= int(4)) [] ('var ::= new 'C (null))) ||| skip), insert('var2, int(4), insert('var1, str("test"), noSub))), idle ) .

  *** red (((('var ::= int(4)) [] ('var ::= new 'C (null))) ||| skip), insert('var2, int(4), insert('var1, str("test"), noSub))) ++ idle .

  *** red (('var := bool(true)), noSub) .
endfm

*** CREOL classes ***
fmod CLASS is
  protecting STM-LIST .

  sorts    Class Mtd MMtd Inh InhList . *** inheritance list
  subsorts Inh < Expr .  
  subsorts Inh < InhList .

  op  _<_> : Cid  ExprList -> Inh .     *** initialised superclass
  op noInh : -> InhList [ctor] .
  op  _##_   : InhList InhList -> InhList [ctor assoc id: noInh] .

  var Ih : Inh . 
  var IL : InhList .
  var S : Subst . 
  var SL : StmList . 
  vars Q Q' : Qid . 
  var MM : MMtd .
  var EL : ExprList .
  var O : Oid .
  var N : Nat .
  var AL : AidList .

  eq  Ih ## IL ## Ih = Ih ## IL .

  op <_: Mtdname | Param:_, Latt:_, Code:_> : 
    Qid AidList Subst StmList -> Mtd [ctor
      format (g! g o o o g o o g o o g o g o)] .

  subsort Mtd < MMtd .    *** Multiset of methods

  op noMtd : -> Mtd [ctor] .
  op _*_  : MMtd MMtd -> MMtd [ctor assoc comm id: noMtd format (o o on o)] .

  op <_: Cl | Inh:_, Par:_, Att:_, Mtds:_, Ocnt:_> : 
    Cid InhList AidList Subst MMtd Nat -> Class 
     [format (b! b o o o b o o  b o o  b o o  b on o  b o  b! on )] .

  op emptyClass : -> Class .
  eq emptyClass =
    < 'noClass : Cl | Inh: noInh , Par: noAid, Att: noSub , Mtds: noMtd ,
      Ocnt: 0 > .

  *** Class/method functions ***
  op get : Qid MMtd Oid Label ExprList -> Process .  *** fetches pair (code, vars)
  op _in_ : Qid MMtd -> Bool .  *** checks if Q is a declared 
                                *** method in the method multiset

  eq Q in noMtd = false .
  eq Q in (< Q' : Mtdname | Param: AL, Latt: S, Code: SL > * MM) = 
       if (Q == Q') then true else (Q in MM) fi .

  *** bind call to process
  var Lab : Label .
  eq get(Q, noMtd, O, Lab, EL) = noProc . 
  eq get(Q, < Q' : Mtdname | Param: AL, Latt: S, Code: SL > * MM, O, Lab, EL) = 
    if Q == Q' 
    then (insert('caller, O, insert('label, Lab, S)), (AL ::= EL) ; SL)
    else get(Q, MM, O, Lab, EL) fi .

  *** insert('caller, O, insert('label, int(N), S))
  *** 'caller |-> O, 'label |-> int(N))

  *** red < 'getNeighbor : Mtdname | 
  ***           Latt: ('label |-> null, 'caller |-> null, 'n |-> null), Code: skip > .

  *** red < 'Butler : Cl | Inh: noInh , Att: noSub , Mtds: noMtd , Ocnt: 0 > .
  *** red ('butler . 'getNeighbor)(noExpr ; noExpr) .
  *** red ('butler ! 'getNeighbor(noExpr)) .
  *** red ('run(noExpr ; noExpr)) # ('run(noExpr ; noExpr)) .
  *** red ('butler ! 'getNeighbor(noExpr)) # ('run(noExpr ; noExpr)) .
endfm

*** CREOL objects ***
fmod OBJECT is
  protecting CLASS .

  sort Object .

  op <_:_ | Att:_, Pr:_, PrQ:_, Lcnt:_> : 
       Oid Cid Subst Process MProc Nat -> Object 
         [ctor format (nr! r o o o  r o r  r o r r o r r o r! no)] .

  op noObj : -> Object [ctor] .

  *** red < 'object1 : 'class | Att: noSub, Pr: idle, PrQ: noProc, Lcnt: 0 > .
  *** red downTerm(upTerm(< 'object1 : 'class | Att: noSub, Pr: idle, PrQ: idle, Lcnt: 0 >), noObj) .

endfm

*** CREOL messages and queues ***
fmod COMMUNICATION is
  protecting OBJECT .

  sort Labels . *** list of labels
  subsort Label < Labels .

  sort Body Msg MMsg Kid Queue .
  subsort Body < MMsg .

  op noMsg : -> Body [ctor] .
  op _+_ : MMsg MMsg -> MMsg [ctor assoc comm id: noMsg] . 

  *** INVOCATION and REPLY
  op invoc(_,_,_,_) : *** Nat Oid 
  Oid Label Mid ExprList -> Body [ctor                     *** invocation
        format (! o o o o o o o o o o)] .  
  op comp(_,_) : Label ExprList -> Body [ctor              *** completion
        format (! o o o o o o)] .  

  op _from_to_ : Body Oid Oid -> Msg [ctor format (o ! o ! o on)] .
  op error(_) : String -> Msg [ctor format (nnr r o! or onn)] .     *** error 
  op warning(_) : String -> Msg [ctor format (nnr! r! r! or onn)] .   *** warning 

  *** Method binding messages
  op bindMtd : Oid Oid Label Qid ExprList InhList -> Msg [ctor] . 
  ***Bind method request
  *** Given: caller callee method params (list of classes to look in)
  op boundMtd(_,_) : Oid Process -> Msg 
    [ctor format (!r r o o o !r on)] . *** binding result
  *** CONSIDER the call O.Q(I). bindMtd(O,Q,I,C S) trie to find Q in
  *** class C or superclasses, then in S. boundMtd(O,Mt) is the result.


  *** message queue
  op noDealloc :         -> Labels  [ctor].
  op _^_ : Labels Labels -> Labels [ctor comm assoc id: noDealloc] .

  op noQu : -> Queue [ctor] .
  op <_: Qu | Dealloc:_, Ev:_ > : Oid Labels MMsg -> Queue 
                          [format (nm! m o o o  m o o m o m! no)] . 

  *** red noMsg .
  *** red comp(5, noExpr) .
  *** red invoc('object1, 5, 'method1, noExpr) .
  *** red upTerm(comp(5, noExpr)) .
  *** red downTerm(upTerm(comp(5, noExpr)), noMsg) .
  *** red upTerm(invoc('object1, 5, 'method1, noExpr)) .
  *** red downTerm(upTerm(invoc('object1, 5, 'method1, noExpr)), noMsg) .
  *** red < 'Ob1 : Qu | Dealloc: noDealloc , Ev: noMsg > .
  *** red upTerm(< 'Ob1 : Qu | Dealloc: noDealloc , Ev: noMsg >) .
  *** red downTerm(upTerm(< 'Ob1 : Qu | Dealloc: noDealloc, Ev: noMsg >), noQu) .
endfm

*** STATE CONFIGURATION ***
fmod CONFIG is
  protecting OBJECT .
  protecting COMMUNICATION .

  sort Configuration .

  subsorts Object Msg Queue Class < Configuration .

  op noConf : -> Configuration [ctor] .
  op __ : Configuration Configuration -> Configuration [ctor assoc comm id: noConf] .
  op main : Cid ExprList -> Configuration .

  var C : Cid . var E : ExprList .
  eq main(C,E) = < ob('main) : 'class | Att: noSub, 
                 Pr: (noSub, ('var ::= new C(E))), PrQ: noProc, Lcnt: 0 > 
               < ob('main) : Qu | Dealloc: noDealloc,Ev: noMsg > .

endfm


*** AUXILIARY FUNCTIONS ***
fmod AUX-FUNCTIONS is
pr CONFIG .
protecting CONVERSION .

*** Signatures
op inqueue  : Label MMsg -> Bool . *** checks if  Msg is in the queue

op enabledGuard : Guard   Subst MMsg -> Bool .
op enabled      : StmList Subst MMsg -> Bool . *** eval guard 
op ready        : StmList Subst MMsg -> Bool . *** eval guard 

*** Variables
vars N N' : Nat .
vars L L' : Label .
var E E' : Expr .
var EL : ExprList .
var A : Aid .
vars G1 G2 : Guard .
var S : Subst .
var MM : MMsg .
var C : Cid .
var  Q : Qid .

*************************** Names of new objects ********************
op newId : Cid Nat -> Oid .
eq newId(Q, N)  = ob(qid(string(Q) + string(N,10))) .
***** some code to make string/qid total 
*** Don't think we need this ?
*** op string : Nat    -> String  .
*** op string : Cid    -> String [ditto] .
*** op string : Oid    -> String [ditto] .
*** op string : Rat NzNat -> String [ditto] .
*** op qid    : Qid    -> Qid .
*** op qid    : String -> Qid [ditto] .
*** eq string(N)      = string(N,10) . 
*** eq qid(Q)         = Q .
*** eq qid(string(Q)) = Q .  
*** eq qid(string(C)) = qid(C) .  
*** eq qid(S:String)  = 'invalid [owise] . 



eq inqueue(L, noMsg) = false .
*** eq inqueue(N, comp(N', E)) = if N == N' then true else false fi .
eq inqueue(L, comp(L', EL) + MM) = 
     if L == L' then true else inqueue(L, MM) fi .


eq enabledGuard(noGuard, S, MM)   = true .
eq enabledGuard(wait, S, MM)      = false .       *** Note: no wait in PrQ!
eq enabledGuard(E, S, MM)         = evalB(E, S) .
eq enabledGuard((A ?), S, MM)     = inqueue(eval(A, S), MM) .
eq enabledGuard((L ?), S, MM)     = inqueue(L, MM) .
***(eq enabledGuard((G1 & G2), S, MM) = enabledGuard(G1, S, MM) and enabledGuard(G2, S, MM) . *** may skip termination problems! due to Id: noguard
)
*** red enabledGuard((int(5) > int(7)), noSub, noMsg) .
*** red int(4) add int(5) .
*** red (int(4) add int(5)) > (int(7) add int(19)) .
*** red upTerm((int(4) add int(5)) > (int(7) add int(19))) .
*** red downTerm(upTerm((int(4) add int(5)) > (int(7) add int(19))), (int(0)).Expr) .

var  ST ST' : Stm . 
vars SL SL' : StmList . 
var NeSL : NeStmList .

eq enabled(SL [] SL',  S, MM) = enabled(SL, S, MM) or enabled(SL', S, MM) .
eq enabled(SL ||| SL', S, MM) = enabled(SL, S, MM) or enabled(SL', S, MM) .
eq enabled(await G1,   S, MM) = enabledGuard(G1,S,MM) .
eq enabled((ST ; ST' ; SL),S, MM) = enabled(ST, S, MM) . 
eq enabled(ST,    S, MM) = true [owise]. 

eq ready(SL [] SL',  S, MM) = ready(SL, S, MM) or ready(SL', S, MM) .
eq ready(SL ||| SL', S, MM) = ready(SL, S, MM) or ready(SL', S, MM) .
eq ready(A ?(E),     S, MM) = inqueue(eval(A, S), MM) . 
eq ready(L ?(E),     S, MM) = inqueue(L, MM) . 
eq ready((ST ; ST' ; SL), S, MM) = ready(ST, S, MM) . 
eq ready(ST,         S, MM) = enabled(ST, S, MM) [owise]. 

***( transform wait guards when active code is suspended. remove all waits.
op clear : Guard  -> Guard . 
eq clear(noGuard) = noGuard .
eq clear(wait)    = noGuard . 
eq clear(E)       = E .
eq clear((Q ?))   = (Q ?) .
eq clear((N ?))   = (N ?) .
eq clear(G1 & G2) = clear(G1) & clear(G2) .  *** term. problems!

op clear : StmList -> StmList . 
*** eq clear(nil)     = nil . 
eq clear(await G1)   = await(clear(G1)) .
eq clear(SL [] SL')  = clear(SL) [] clear(SL') .
eq clear(SL ||| SL') = clear(SL) ||| clear(SL') .
eq clear(SL ; NeSL)  = clear(SL) ; NeSL .
eq clear(SL)         = SL [owise] .
)

endfm

*** THE MACHINE ***
mod INTERPRETER is
pr AUX-FUNCTIONS .

var O O' : Oid .
vars C C' : Cid .
var A : Aid .
var AL : AidList .
var E E' : Expr .
var EL EL' : ExprList .
var ST : Stm .
var SL SL' SL'' : StmList .
vars SL1 SL2 : NeStmList .
var P : Process .
var W : MProc .
vars S S' L L' : Subst .
vars N F : Nat .
vars I I' : InhList .
var MS : MMtd .
var LS : Labels .
vars Lab Lab' : Label .
var MM : MMsg .
var G : Guard .
var M : Mid .
var Q : Qid .
var MsgBody : Body .


*** multiple assignment
eq
  < O : C | Att: S, Pr: (L,((A, AL) ::= (E, EL)); SL), PrQ: W, Lcnt: N >
  =
  < O : C | Att: S, Pr: (L,((A ::= eval(E,(S # L))) ; 
                            (AL ::= evalList(EL,(S # L))); SL)), 
    PrQ: W, Lcnt: N > .

*** assignment

eq [assign] :
  < O : C | Att: S, Pr: (L,((A ::= E); SL)), PrQ: W, Lcnt: N >
  =
  if dom(A,L) then
    < O : C | Att: S, Pr: (insert(A,eval(E,(S # L)), L), SL), PrQ: W, Lcnt: N > 
  else
    < O : C | Att: insert(A,eval(E,(S # L)), S), Pr: (L, SL), PrQ: W, Lcnt: N > 
  fi .


  ***( method termination: replaced by : eq (nil, L) = idle .
  rl [idle] :
  < O : C | Att: S, Pr: (L, nil), PrQ: W, Lcnt: N >
  =>
  < O : C | Att: S, Pr: idle, PrQ: W, Lcnt: N > .
  )

eq [skip] :
  < O : C | Att: S, Pr: (L, skip ; SL), PrQ: W, Lcnt: N >
  =
  < O : C | Att: S, Pr: (L, SL), PrQ: W, Lcnt: N > .


eq [if-el] :
  < O : C | Att: S, Pr: (L, if E th SL' el SL'' fi ; SL), PrQ: W, Lcnt: N >
  =
  if eval(E, (S # L)) asBool then
    < O : C | Att: S, Pr: (L, SL' ; SL), PrQ: W, Lcnt: N >
  else
    < O : C | Att: S, Pr: (L, SL'' ; SL), PrQ: W, Lcnt: N >
  fi .


***(
  We want to be able to observe what happens here in an infinite loop.
  therefore, each expansion of a while body is done by a rule. )

rl [while] :
  < O : C | Att: S, Pr: (L, while E do SL1 od ; SL2), PrQ: W, Lcnt: N >
  =
  < O : C | Att: S, 
      Pr: (L, (if E th (SL1 ; while E do SL1 od) el skip fi); SL2),
      PrQ: W, Lcnt: N > .


eq [new-object] :
  < O : C | Att: S,Pr: (L, (A ::= new C' (EL)); SL),PrQ: W, Lcnt: N > 
  < C' : Cl | Inh: I , Par: AL, Att: S' , Mtds: MS , Ocnt: F >
  =
  < O : C | Att: S, Pr: (L, (A ::= newId(C', F)); SL), PrQ: W, Lcnt: N >
  < C' : Cl | Inh: I , Par: AL, Att: S' , Mtds: MS , Ocnt: (F + 1) >
  < newId(C',F) : C' | Att: S, Pr: idle, PrQ: noProc, Lcnt: 1 >
  < newId(C',F) : Qu | Dealloc: noDealloc, Ev: noMsg > 
  findAttr(newId(C',F), I, S', 
    (AL ::= evalList(EL, (S # L))), ('init (emp ; emp)) ; ('run (emp ; emp))) .

*** ATTRIBUTE inheritance with multiple inheritance
*** CMC assumes that all attributes names are (globally) different

op findAttr  : Oid InhList Subst StmList StmList -> Msg [ctor] . *** collect attributes
op foundAttr : Oid Subst  StmList StmList        -> Msg [ctor] . *** resulting Subst
*** look in InhList, collect attributes in Subst, give result to Oid
*** SL SL' SL''

eq findAttr(O, noInh, S, SL, SL')  *** collection completed.
       = foundAttr(O, S, SL, SL') .

eq findAttr(O,((C < EL >) ## I),S, SL, SL') 
< C : Cl | Inh: I', Par: AL, Att: L, Mtds: MS, Ocnt: F >
 = findAttr(O, I ## I',(L # S), (AL ::= EL) ; SL, 
              ('init @ C(emp ; emp)) ; SL') 
   < C : Cl | Inh: I', Par: AL, Att: L, Mtds: MS, Ocnt: F > .

eq foundAttr(O, S', SL, SL') 
< O : C | Att: S, Pr: idle, PrQ: W, Lcnt: N >
 = < O : C | Att: ('this |-> O, S'), Pr: (noSub, SL ; SL'), PrQ: W, Lcnt: N > .

*** Non-deterministic choice ***
*** Choice is comm, so [nondet] considers both SL1 and SL2.
crl [nondet] :
< O : C | Att: S, Pr: (L, (SL1 [] SL2); SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
=>
< O : C | Att: S, Pr: (L, (SL1 ; SL)), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
if ready(SL1, (S # L), MM) .  

*** Merge ***
*** Merge is comm, so [merge] considers both SL1 and SL2.
crl [merge] :
< O : C | Att: S, Pr: (L, (SL1 ||| SL2); SL), PrQ: W, Lcnt: N >  
< O : Qu | Dealloc: LS, Ev: MM >
=>
< O : C | Att: S, Pr: (L, (SL1 MERGER SL2); SL), PrQ: W, Lcnt: N >  
< O : Qu | Dealloc: LS, Ev: MM >
if ready(SL1,(S # L), MM) . 

eq [merge-aux] :
< O : C | Att: S,  Pr:  (L, ((ST ; SL') MERGER SL2); SL), PrQ: W, Lcnt: N >   
< O : Qu | Dealloc: LS, Ev: MM >
=
< O : Qu | Dealloc: LS, Ev: MM >
if enabled(ST,(S # L), MM) then
< O : C | Att: S, Pr: (L, ((ST ; (SL' MERGER SL2)); SL)), PrQ: W, Lcnt: N >   
else
< O : C | Att: S, Pr: (L, ((ST ; SL') ||| SL2); SL), PrQ: W, Lcnt: N >   
fi .

eq [continue2] :
< O : C | Att: S, Pr: (L, (cont(Lab) MERGER SL'); SL''), 
          PrQ: (L', ((Lab ?(A)); SL)) ++ W, Lcnt: F >
=
< O : C | Att: S, Pr: (L',((((Lab ?(A)) ; SL) MERGER SL'); SL'')), 
          PrQ: W, Lcnt: F > .

*** local call 
ceq boundMtd(O, (L', SL')) 
< O : C | Att: S,Pr: (L, ((Lab ?(EL)); SL)),PrQ: W,Lcnt: F >
= 
< O : C | Att: S,Pr: (L', SL' ; cont(Lab)),PrQ: (L,((await Lab ?) ; (Lab ?(EL)); SL)) ++ W,
          Lcnt: F > 
if (L'['label] == Lab) .

*** local call within merge
ceq boundMtd(O, (L', SL')) 
< O : C | Att: S,Pr: (L,(((Lab ?(EL)); SL) MERGER SL'')),PrQ: W,Lcnt: F >
= 
< O : C | Att: S,Pr: (L', SL'),
          PrQ: (L, (((await Lab ?) ; (Lab ?(EL)); SL) MERGER SL'')) ++ W,Lcnt: F > 
if (L'['label] == Lab) .

*** Suspension ***

ceq [suspend] :  *** all kinds of code P 
< O : C | Att: S, Pr: (L,SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
=
< O : C | Att: S, Pr: idle, PrQ: W ++ (L, SL), Lcnt: N > *** clear(SL)
< O : Qu | Dealloc: LS, Ev: MM >
if not enabled(SL, (S # L), MM) . 

*** Guards ***

ceq [guard] :
< O : C | Att: S, Pr: (L, await G ; SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
=
< O : C | Att: S, Pr: (L,SL) , PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM > 
if enabledGuard(G, (S # L), MM) .

*** Evaluate guards in suspended processes ***

crl [PrQ-ready] :
< O : C | Att: S, Pr: idle, PrQ: (L,SL) ++ W, Lcnt: N > 
< O : Qu | Dealloc: LS, Ev: MM >
=>
< O : C | Att: S, Pr: (L,SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
if ready(SL, (S # L), MM) .


*** Evaluation of wait in PrQ *** (avoiding clear)

*** rl [wait] :
eq [wait] :
< O : C | Att: S, Pr: idle, PrQ: (L, await wait ; SL) ++ W, Lcnt: N >  
 =
< O : C | Att: S, Pr: idle, PrQ: (L, SL) ++ W, Lcnt: N > .

eq [wait-nondet] :
< O : C | Att: S, Pr: idle, PrQ: (L, ((await wait ; SL)[] SL'); SL'')++ W,  
   Lcnt: N >  
 = < O : C | Att: S, Pr: idle, PrQ: (L, (SL [] SL'); SL'') ++ W, Lcnt: N > .

eq [wait-merge] : < O : C | Att: S, Pr: idle, PrQ: (L,((await wait ; SL)||| SL'); SL'')++ W,  
   Lcnt: N >  
 = < O : C | Att: S, Pr: idle, PrQ: (L, (SL ||| SL'); SL'') ++ W, Lcnt: N > .

*** Optimization to avoid muiltiple lookups in the message queue for
*** the same guard
eq 
< O : C | Att: S, Pr: P, PrQ: (L, await (Lab ? & G); SL) ++ W, Lcnt: F > 
< O : Qu | Dealloc: LS, Ev: MM + comp(Lab, EL) >  
=
< O : C | Att: S,  Pr: P, PrQ: (L, await G ; SL) ++ W, Lcnt: F >    
< O : Qu | Dealloc: LS, Ev: MM + comp(Lab, EL) > .


*** METHOD CALLS ***

eq   ! Q(EL) =   ! 'this . Q(EL) . *** could alternatively use X@ this class

*** receive invocation message ***
rl [receive-call-req] :
< O : C | Att: S, Pr: P, PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM + invoc(O', Lab, Q, EL) >
=>
< O : C | Att: S, Pr: P, PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM > bindMtd(O, O', Lab, Q, EL, C < emp >) .

*** Method binding with multiple inheritance
ceq bindMtd(O, O',Lab,Q, EL,noInh) = 
boundMtd(O,(('caller |-> O', 'label |-> Lab), return(emp)))
if Q == 'run .


eq bindMtd(O,O', Lab, M,EL,(C < EL' >) ## I') 
< C : Cl | Inh: I , Par: AL, Att: S , Mtds: MS , Ocnt: F >
   =  if (M in MS) then boundMtd(O,get(M,MS,O',  Lab, EL)) 
                   else bindMtd(O,O', Lab,M,EL, I ## I') fi 
< C : Cl | Inh: I , Par: AL, Att: S , Mtds: MS , Ocnt: F > .

rl [receive-call-req] :
< O : Qu | Dealloc: LS, Ev: MM + invoc(O', Lab, Q @ C, EL) >
=>
< O : Qu | Dealloc: LS, Ev: MM >  bindMtd(O, O', Lab, Q, EL, C < emp >) .

eq [receive-call-bound] : 
boundMtd(O, P) < O : C | Att: S, Pr: idle, PrQ: W, Lcnt: N >
=
< O : C | Att: S, Pr: P, PrQ: W, Lcnt: N >
.

eq [continue] :
< O : C | Att: S, Pr: (L,cont(Lab)), PrQ: (L',((Lab ?(EL)); SL)) ++ W, Lcnt: F >
=
< O : C | Att: S, Pr: (L',((Lab ?(EL)); SL)), PrQ: W, Lcnt: F > .

eq [local-async-qualified-req] :
< O : C | Att: S, Pr: (L, ( ! Q @ C'(EL)); SL),PrQ: W, Lcnt: N >
= 
< O : C | Att: S, Pr: (L, SL), PrQ: W, Lcnt: N + 1 >
invoc(O, label(N), Q @ C', evalList(EL, (S # L))) from O to O .

*** REMOTE METHOD CALLS ***
eq [remote-call] :
  < O : C | Att: S, Pr: (L, (Q ! M(EL)); SL), PrQ: W, Lcnt: N >
  =
  < O : C | Att: S, Pr: (L, (Q ::= int(N)); (! M (EL));  SL),
    PrQ: W,  Lcnt: N > .


eq [remote-async-reply] : 
< O : C | Att: S, Pr: (L, ( ! E . M(EL)); SL), PrQ: W, Lcnt: N >
=
< O : C | Att: S, Pr: (L,SL), PrQ: W, Lcnt: N + 1 >
invoc(O, label(N), M , evalList(EL, (S # L))) from O to eval(E, (S # L)) .

*** Reduce sync. call  to async. call with reply 
eq < O : C | Att: S, Pr: (L, (M(EL ; EL')); SL), PrQ: W, Lcnt: N >
  =
< O : C | Att: S, Pr: (L, (! M(EL)); (label(N) ?(EL')); SL), PrQ: W,  Lcnt: N >  .

*** emit reply message ***
eq [return] :
< O : C |  Att: S, Pr: (L, (return(EL)); SL), PrQ: W, Lcnt: N >
=
< O : C |  Att: S, Pr: (L, SL), PrQ: W, Lcnt: N > 
comp(eval('label, L), evalList(EL, (S # L))) from O to eval('caller, L) .

*** Optimization: reduce label to value only once
eq < O : C |  Att: S, Pr: (L, (A ?(EL)); SL), PrQ: W, Lcnt: N > 
= < O : C |  Att: S, Pr: (L, (eval(A,L) ?(EL)); SL), PrQ: W, Lcnt: N > .

*** blocking reply sentence ***
eq [block-sync-reply] :
< O : C |  Att: S, Pr: (L, (Lab ? (EL)); SL), PrQ: W, Lcnt: F > 
< O : Qu | Dealloc: LS, Ev: MM + comp(Lab, EL') >
= 
< O : C |  Att: S, Pr: (L, (EL ::= EL'); SL), PrQ: W, Lcnt: F > 
< O : Qu | Dealloc: LS, Ev: MM > .

*** We may here get (emp ::= emp), which should be reduced to skip .
eq (emp ::= emp) = skip .

*** Transport rule: include new message in queue
eq [invoc-msg] :
< O : Qu | Dealloc: LS, Ev: MM > (MsgBody from O' to O)
=
< O : Qu | Dealloc: LS, Ev: MM + MsgBody > .

*** generalize to lists of labels AL:
eq [free] :
< O : C | Att: S, Pr: (L, free(A) ; SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
=
< O : C | Att: S, Pr: (L,SL), PrQ: W, Lcnt: N > 
< O : Qu | Dealloc: (eval(A, (S # L)) ^ LS), Ev: MM > .

*** Deallocate
eq < O : Qu | Dealloc: (Lab ^ LS), Ev: comp(Lab, EL) + MM >
= < O : Qu | Dealloc: LS, Ev: MM > .
endm

eof

red boundMtd(ob('Philosopher4),('caller |-> ob('Philosopher4), 'l |-> null, 'label |-> int(7)),
await ('not[['hungry]]) ; ('history ::= ('plus[['history # str("t")]])) ; await wait ; ('l ! 'this . 'think(emp)) ; free('l) ; return(emp)) .


fmod MYLIST{X :: TRIV} is
***  protecting NAT .
  sorts MyNeList{X} MyList{X} .
  subsort X$Elt < MyNeList{X} < MyList{X} .

  op emp : -> MyList{X} [ctor] .
  op _#_ : MyList{X} MyList{X} -> MyList{X} [ctor assoc id: emp prec 25] .
  op _#_ : MyNeList{X} MyList{X} -> MyNeList{X} [ctor ditto] .
  op _#_ : MyList{X} MyNeList{X} -> MyNeList{X} [ctor ditto] .

***  vars E E' : X$Elt .
***  vars A L : MyList{X} .
***  var C : Nat .

***  op app : MyList{X} MyList{X} -> MyList{X} .
***  op app : MyNeList{X} MyList{X} -> MyNeList{X} .
***  op app : MyList{X} MyNeList{X} -> MyNeList{X} .
***  eq app(A, L) = A # L .

***  op lt : MyNeList{X} -> X$Elt .
***  eq lt(E # L) = E .

***  op rr : MyNeList{X} -> MyList{X} .
***  eq rr(E # L) = L .

***  op rt : MyNeList{X} -> X$Elt .
***  eq rt(L # E) = E .

***  op lr : MyNeList{X} -> MyList{X} .
***  eq lr(L # E) = L .

***  op element : X$Elt MyList{X} -> Bool .
***  eq element(E, emp) = false .
***  eq element(E, E' # L) = if E == E' then true else element(E, L) fi .

***  op rev : MyList{X} -> MyList{X} .
***  op rev : MyNeList{X} -> MyNeList{X} .
***  eq rev(L) = $rev(L, emp) .

***  op $rev : MyList{X} MyList{X} -> MyList{X} .
***  eq $rev(emp, A) = A .
***  eq $rev(E # L, A) = $rev(L, E # A).

***  op lth : MyList{X} -> Nat .
***  op lth : MyNeList{X} -> NzNat .
***  eq lth(L) = $lth(L, 0) .

***  op $lth : MyList{X} Nat -> Nat .
***  eq $lth(emp, C) = C .
***  eq $lth(E # L, C) = $lth(L, C + 1) .
endfm
