*** This will be the library of Creol's functional datatypes

fmod DATA is 
protecting META-LEVEL .
pr QID .
pr STRING .
pr INT .
pr NAT .
pr FLOAT .
                                    *** Qid = local variable ident
sorts   Aid Oid Data Expr .         *** Aid = attribute identifier
subsort Oid < Data < Expr .         *** Oid = object identifier
subsort Qid < Aid < Expr .

sorts   EmpList AidList ExprList DataList .
subsort Aid < AidList < ExprList .
subsort Expr < ExprList .
subsort Data < DataList  < ExprList .
subsort EmpList < DataList AidList .

op emp  :                     -> EmpList [ctor] .
op _,,_ : ExprList  ExprList  -> ExprList [ctor assoc id: emp prec 25] .
op _,,_ : DataList  DataList  -> DataList [ctor ditto] .
op _,,_ : EmpList   EmpList   -> EmpList [ctor ditto] .
*** op _,,_ : NeExprList ExprList -> NeExprList [ctor ditto] .
*** op _,,_ : ExprList NeExprList -> NeExprList [ctor ditto] .

op noAid : -> AidList .
op _,,_  : AidList AidList -> AidList [ctor ditto] .

eq noAid = emp . *** if ok may remove noAid !

op _[[_]] : Qid ExprList -> Expr . *** function application
op _[[_]] : Qid DataList -> Data . *** function application

*** Basic conversion of data types into sort Data
op null    :           -> Data [ctor] . *** undef. value/none pointer
op ob      : Qid       -> Oid  [ctor] .
op int(_)  : Int       -> Data [ctor format(o o ! o o)] . 
op float(_): Float     -> Data [ctor format(o o ! o o)] . 
op str(_)  : String    -> Data [ctor format(o o ! o o)] .
op bool(_) : Bool      -> Data [ctor format(o o ! o o)] .
op lab     : Nat       -> Data [ctor].             *** label values
*** Reconversion for evaluation
op _asInt             : Data -> Int .
op _asNat             : Data -> Nat .
op _asBool            : Data -> Bool .
op _asStr             : Data -> String .
 

var N : Nat .    var I : Int .
var B : Bool .   var S : String .

eq int(I)  asInt      = I . 
eq int(N)  asNat      = N .  *** otherwise error, i.e. irreducible...
eq bool(B) asBool     = B .
eq str(S)  asStr      = S .

*** PREDEFINED INFIX NOTATION 

ops neg_  not_            : Expr -> Expr . *** removed #_ for length
ops _.fst _.scd           : Expr -> Expr .  *** first and second part of pair
ops _add_ _min_ _mult_ _div_ : Expr Expr -> Expr .
*** ops _+_ _-_ _*_ _/_ : Expr Expr -> Expr . 
ops _<_ _<=_ _>_ _>=_     : Expr Expr -> Expr .
ops _or_ _and_		  : Expr Expr -> Expr .
ops _=/=_ _==_		  : Expr Expr -> Expr .
ops _cat_  _|-|_ 	  : Expr Expr -> Expr . *** alternative notations
ops _|-_  _-|_ 	          : Expr Expr -> Expr .
ops _bw_  _ew_	          : Expr Expr -> Expr .

*** red int(4) .
*** red int(4) asInt .

*** translation from infix to prefix notation
vars E E' : Expr .

eq not E	 = 'not[[E]].
eq neg E	 = 'neg[[E]].
eq E add E'	 = 'plus [[E ,, E']].
eq E min E'	 = 'minus [[E ,, E']].
eq E mult E'	 = 'times [[E ,, E']].
eq E div E'	 = 'div [[E ,, E']].
eq E <  E'	 = 'less[[E ,, E']]. 
eq E <= E'	 = 'lessEq[[E ,, E']].
eq E >  E'	 = 'less[[E' ,, E]].
eq E >= E'	 = 'lessEq[[E' ,, E]].
eq (E ==  E')	 = 'equal[[E ,, E']].
eq (E =/=  E')	 = 'not[['equal[[E ,, E']]]].

eq E and E'	 = 'and[[E ,, E']].
eq E or  E'	 = 'or[[E ,, E']].
eq E .fst	 = 'fst[[E]].      *** pair-functions
eq E .scd	 = 'scd[[E]].
eq E bw E'	 = 'begwith[[E ,, E']] .
eq E ew E'	 = 'endwith[[E ,, E']] .
eq E cat E'      = 'plus [[E ,, E']]. 
eq E |-| E'      = 'plus [[E ,, E']]. 
eq E |- E'       = 'add[[E ,, E']] .      *** appendright
eq E -| E'       = 'addFirst[[E ,, E']] . *** appendleft

endfm  

fmod DATATYPES is  
*** may easily keep various data types on separate file(s), 
*** and plug in upon need.
pr DATA .

op list : ExprList     -> Expr . *** lists
op list : DataList     -> Data [ctor] . *** lists of data
op setl : ExprList     -> Expr .        *** set
op setl : DataList     -> Data [ctor] . *** set
op pair : Expr Expr    -> Expr .        *** pairs
op pair : Data Data    -> Data [ctor] . *** pairs

vars I I'     : Int .
vars N        : Nat .
vars F F'     : Float .
vars S S'     : String . 
vars D D'     : Data .
vars E E'     : Expr .
vars L L' L'' : ExprList .

*** reduction for sets 
eq  setl(L ,, E ,, L' ,, E ,, L'') = setl(L ,, E ,, L' ,, L'') .
ceq setl(D ,, D' ,, L) = setl(D' ,, D ,, L) if (D > D')asBool .
*** ceq setl(L ,, D ,, L' ,, D' ,, L'') = setl(L ,, D' ,, L' ,, D ,, L'') 
*** if (D > D')asBool . *** old

*** EVALUATION      
*** eq char(int(I))	= str(char(I)) .
eq 'neg[[int(I)]]	= int(-(I)) .
eq 'fst[[pair(E, E')]]   = E . 
eq 'scd[[pair(E, E')]]   = E' .

*** equal-func for all (!) data types
eq 'equal[[D ,, D']]	       = bool(D == D') .

*** bool-functions
eq 'not[[bool(false)]]    = bool(true) .  
eq 'not[[bool(true )]]    = bool(false) . 
eq 'or[[bool(true),,   E]] = bool(true) .
eq 'or[[bool(false),,  E]] =  E .
eq 'and[[bool(false),, E]] = bool(false) .
eq 'and[[bool(true),,  E]] =  E .

*** less-func
eq 'less  [[int(I),, int(I')]] = bool(I < I') .
eq 'lessEq[[int(I),, int(I')]] = bool(I <= I') .
eq 'less  [[float(F),, float(F')]] = bool(F < F') .
eq 'lessEq[[float(F),, float(F')]] = bool(F <= F') .
eq 'less  [[str(S),, str(S')]] = bool(S < S') .
eq 'lessEq[[str(S),, str(S')]] = bool(S <= S') .

*** list-functions
eq 'head[[list(emp)]]	= null .
eq 'head[[list(E ,, L)]]	= E .
eq 'last[[list(emp)]]	= null .
eq 'last[[list(L ,, E)]]	= E .
eq 'rest[[list(emp)]]	= null .
eq 'rest[[list(L ,, E)]]	= list(L) .
eq 'tail[[list(emp)]]	= null .
eq 'tail[[list(E ,, L)]]	= list(L) .

***eq 'length[[list(null)]]  = int(0) .
eq 'length[[list(emp)]]   = int(0) .
eq 'length[[list(E ,, L)]] = int(1) + ('length[[list(L)]]) .
eq 'length[[setl(E ,, L)]] = int(1) + ('length[[setl(L)]]) .

eq 'isempty[[list(emp)]]  = bool(true) .
eq 'isempty[[list(E ,, L)]]= bool(false) .

eq 'remove[[list(E),,   E']]  = if  E == E' then list(emp) else list(E) fi .
eq 'remove[[list(emp),, E ]]  = list(emp) .
eq 'remove[[list(E ,, L),, E']]  = if E == E' then 'remove[[(list(L)),, E']] 
			  else 'plus[[list(E),, ('remove[[(list(L)),, E']])]] fi .
eq 'remove[[setl(E),,   E']]  = if  E == E' then setl(emp) else setl(E) fi .
eq 'remove[[setl(emp),, E ]]  = setl(emp) .
eq 'remove[[setl(E ,, L),, E']] = if E == E' then setl(L)
			 else 'plus[[setl(E),,('remove[[(setl(L)),, E']])]] fi .
 
eq 'appendLeft [[list(L),, E]]     = list(E ,, L) .
eq 'addFirst   [[list(L),, E]]     = list(E ,, L) .   *** alias
eq 'appendRight[[list(L),, E]]     = list(L ,, E) .
eq 'add[[list(L),,    E]]          = list(L ,, E) .    *** alias
eq 'add[[setl (L),,    E]]         = setl(L ,, E) .    

eq 'has[[list(emp),, E ]]	   = bool(false) .
eq 'has[[list(E ,, L),, E']]       = if (E' == E) then bool(true)
			      else 'has[[list(L),, E']] fi .
eq 'has[[setl(emp),,  E ]]	   = bool(false) .
eq 'has[[setl(E ,, L),,  E']]      = if (E' == E) then bool(true)
			      else 'has[[setl(L),, E']] fi .
***index starts at 1
eq 'after[[list(emp),, int(N)]]    = null . 
eq 'after[[list(E,, L),, int(0)]]  = list(E ,, L) .
eq 'after[[list(E,, L),, int(N)]]  = 'after[[(list(L)),, (int(N) min int(1))]] .

eq 'index[[(list(L)),,   int(0)]]  = null .
eq 'index[[(list(emp)),, int(N)]]  = null .
eq 'index[[(list(E,, L)),, int(N)]]= if (N == 1) then E else
				  'index[[(list(L)),, int( _-_(N,1))]] fi .

eq 'begwith[[list(E),, E']]        = bool('head[[(list(E))]] == E') .
eq 'begwith[[list(E ,, L),, E']]   = bool('head[[(list(E ,, L))]] == E') .
eq 'endwith[[list(E),, E']]        = bool('last[[(list(E))]] == E') .
eq 'endwith[[list(E ,, L),, E']]   = bool('last[[(list(L))]] == E') .

eq 'plus  [[list(L),, list(L')]]   = list(L ,, L').
eq 'plus  [[setl(L),, setl(L')]]   = setl(L ,, L').
eq 'plus  [[str(S),, str(S')]]     = str(S + S').
eq 'plus  [[int(I),, int(I')]]     = int(I + I').
eq 'plus  [[float(F),, float(F')]] = float(F + F').

eq 'minus [[int(I),, int(I')]]     = int( _-_(I, I')).
eq 'minus [[float(F),, float(F')]] = float(_-_(F, F')).

eq 'times [[int(I),, int(I')]]     = int(I * I').
eq 'times [[float(F),, float(F')]] = float(F * F').

eq 'div   [[int(I),, int(I')]]     = int(I quo I').
eq 'div   [[float(F),, float(F')]] = float(F / F').

eq  'setl[[list(L)]] = setl(L).
eq  'list[[setl(L)]] = list(L).
***var Q : Qid .
***eq  Q[[setl(L),, setl(L')]] = 'setl[[Q[[list(L),, list(L')]]]].

endfm
