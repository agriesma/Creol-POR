@node Creol Prelude
@chapter Creol Prelude

The prelude of Creol provides the standard library of Creol.  It
contains all the data types, functions, and classes defined for all
creol programs.

@menu
* Datatype Data::       Universal super type.
* Datatype Bool::       Truth values.
* Datatype Real::       Real-valued numbers.
@end menu


@node Datatype Data
@section Datatype Data

The type @code{Data} is the implicit super-type of all other types.
Two functions are predefined on all instances of @code{Data}: equality
(written as @code{=}) and inequality (written as @code{/=}).

The semantics of equality is a @emph{structural equality} for all
@emph{datatypes} and @emph{referential equality} for objects.

For data-values, equality is characterised by Leibnitz axiom, that two
values @var{x} and @var{y} are equal if and only if all functions
@var{f} applied to @var{x} and @var{y}, including predicates, return
the same value, i.e., @var{f}(@var{x})=@var{f}(@var{y}).

Two objects are equal if they have the same name.  Objects of
different names may behave exactly the same in all circumstances, but
may still be distinguished by their name.

@example
datatype Data

fun = (a: Data, b: Data): Bool == extern "="
fun /= (a: Data, b: Data): Bool == extern "/="
@end example


@node Datatype Bool
@section Datatype Bool

The type @code{Bool} comprises the truth values.  The literals
@code{true} and @code{false} have the type @code{Bool}.  In addition,
the functions displayed below are defined on values of type
@code{Bool}.

@example
datatype Bool

fun ~ (a: Bool) : Bool == extern "~"
fun && (a: Bool, b: Bool): Bool == extern "&&"
fun || (a: Bool, b: Bool): Bool == extern "||"
fun => (a: Bool, b: Bool): Bool == extern "=>"
fun ^ (a: Bool, b: Bool): Bool == extern "^"
fun <=> (a: Bool, b: Bool): Bool == extern "<=>"
@end example

The function @code{~} represents negation.

The function @code{&&} represents conjunction.

The function @code{||} represents disjunction.

The function @code{=>} represents implication.

The function @code{<=>} represents equivalence or by-implication.  It
is a synonym for equality (@code{=}).

The function @code{^} represent exclusive disjunction.  It
is a synonym for inequality (@code{/=}).

The functions @code{<=>} and @code{^} are provided, because they have
lower precedence than @code{=} and @code{/=}, making it simpler to
write formulae involving equalities and inequalities: @code{(P(a) =
P(b)) = (a = b)} can be written nicelier as @code{P(a) = P(b) <=> a =
b}.



@node Datatype Real
@section Datatype Real

The type @code{Real} is supposed to include all values from the real
number field.

@example
datatype Real

fun - (a: Real): Real == extern "-"
fun + (a: Real, b: Real): Real == extern "+"
fun - (a: Real, b: Real): Real == extern "-"
fun * (a: Real, b: Real): Real == extern "*"
fun / (a: Real, b: Real): Real == extern "/"
fun % (a: Real, b: Real): Real == extern "%"
fun ** (a: Real, b: Real): Real == extern "**"

fun < (a: Real, b: Real): Bool == extern "<"
fun <= (a: Real, b: Real): Bool == extern "<="
fun > (a: Real, b: Real): Bool == extern ">"
fun >= (a: Real, b: Real): Bool == extern ">="
@end example

The compiler encodes literals of type @code{Real} as fractions with
arbitrary precision.



@section Datatype Int

@example
datatype Int of Real

fun - (a: Int): Int == extern "-"
fun - (a: Int): Int == extern "-"
fun + (a: Int, b: Int): Int == extern "+"
fun - (a: Int, b: Int): Int == extern "-"
fun * (a: Int, b: Int): Int == extern "*"
fun / (a: Int, b: Int): Int == extern "/"
fun % (a: Int, b: Int): Int == extern "%"
fun ** (a: Int, b: Int): Int == extern "**"

fun < (a: Int, b: Int): Bool == extern "<"
fun <= (a: Int, b: Int): Bool == extern "<="
fun > (a: Int, b: Int): Bool == extern ">"
fun >= (a: Int, b: Int): Bool == extern ">="
@end example


@section Datatype String

@example
datatype String

fun |- (a: String, b: String): String == extern "|-"
fun -| (a: String, b: String): String == extern "-|"
fun |-| (a: String, b: String): String == extern "|-|"
fun # (a: String): Int == extern "#"

fun < (a: String, b: String): Bool == extern "<"
fun <= (a: String, b: String): Bool == extern "<="
fun > (a: String, b: String): Bool == extern ">"
fun >= (a: String, b: String): Bool == extern ">="
@end example


@section Datatype List

@example
datatype List[`a]

fun head(l: List[`a]): `a == extern "head"
fun tail(l: List[`a]): List[`a] == extern "tail"
fun last(l: List[`a]): `a == extern "last"
fun rest(l: List[`a]): List[`a] == extern "rest"
fun at(l: List[`a], p: Int): `a == extern "at"
fun has(l: List[`a], e: `a): Bool == extern "has"
fun remove(l: List[`a], e: `a): List[`a] == extern "remove"
fun -|(e: `a, l: List[`a]): List[`a] == extern "-|"
fun |-(l: List[`a], e: `a): List[`a] == extern "|-"
fun |-|(l: List[`a], m: List[`a]): List[`a] == extern "|-|"
fun #(l: List[`a]): Int == extern "length"
fun length(l: List[`a]): Int == extern "length"
fun isempty(l: List[`a]): Bool == extern "isempty"
@end example


@section Datatype Set

@example
datatype Set[`a]
@end example


@section Datatype Pair

@example
fun fst (a: [`a, `b]): `a == extern "fst"
fun snd (a: [`a, `b]): `b == extern "snd"
@end example


@section Datatypes Time and Duration

@example
datatype Time

fun <(a: Time, b: Time): Bool == extern "<"
fun <=(a: Time, b: Time): Bool == extern "<="
fun >=(a: Time, b: Time): Bool == extern ">="
fun >(a: Time, b: Time): Bool == extern ">"
@end example

@example
datatype Duration

fun dur(a: Real): Duration == extern "duration"
fun +(a: Time, d: Duration): Time == extern "+"
fun -(a: Time, d: Duration): Time == extern "-"
fun +(a: Duration, d: Duration): Duration == extern "+"
fun -(a: Duration, d: Duration): Duration == extern "-"
fun *(a: Duration, s: Real): Duration == extern "*"
fun *(a: Real, s: Duration): Duration == extern "*"
fun /(a: Duration, s: Real): Duration == extern "/"
fun <(a: Duration, b: Duration): Bool == extern "<"
fun <=(a: Duration, b: Duration): Bool == extern "<="
fun >=(a: Duration, b: Duration): Bool == extern ">="
fun >(a: Duration, b: Duration): Bool == extern ">"
@end example


@section Interface Any

The prelude provides the interface @code{Any}, which each class is
implicitly contracting.  The interface @code{Any} does not provide any
methods and allows every behaviour.  This interface has the following
declaration:

@example
interface Any begin inv true end
@end example
