@node CMC Grammar
@appendix @acronym{CMC} Grammar

For reference, we summarise the grammar of the @acronym{CMC}.  The
grammar of the @acronym{CMC} is LR(1).  @code{@{...@}} means a list of
symbols, where the optional decorator at the end indicates the
separator.  An optional symbol is enclosed in square brackets like this:
@code{[ ... ]}.  Terminal symbols are printed like this:
@strong{terminal}.  Finally, the symbol @var{id}, denoting method names,
functions, and variables, refers to an identifier, which is any string
that matches the regular expression @code{[_a-z][_'0-9A-Za-z]*}, and
@var{cid}, denoting class and type names, refers to any string that
matches the regular expression @code{[A-Z][_0-9A-Za-z]*}.


@section Configuration

A configuration is a multiset of terms.  The different terms are described
below.  It is expected that the kinds of terms and their format is going
to change.  Any program that needs to parse a configuration is advised to
ignore tokens or terms it does not understand.

We specify three classes of terms:  object terms, message terms, and
other terms.

An object term can be identified by the structure
@code{< ... : ... | ... >}.  Object terms may be Creol objects, creol
classes, or any other kind of term.

A message term can be identified by the pattern
@code{... from ... to ...}

Any other term has the format @code{...(...)}.


@section Object Terms

Object terms are described by the grammar below.

@format
object-term ::=
    @code{<} oid @code{:} cid @code{|} attributes @code{>}

attributes ::=
    @code{none}
  | attribute
  | attribute @code{,} attributes

attribute ::=
    attr-name attr-value
@end format



@subsection Attribute

An attribute is a @emph{key} followed by its @code{value}.

The key is a name that always starts with an upper case letter and
that always ends with a colon (:).



@subsection Statements

The grammar of statements is:
@format
merge-stmt ::=
    choice-stmt [ @code{|||} merge-stmt ]
  | choice-stmt [ @code{MERGER} merge-stmt ]

choice-stmt ::=
    sequential-stmt [ @code{[]} choice-stmt ]

sequential-stmt ::=
    basic-stmt [ @code{;} sequential-stmt ]

basic-stmt ::=
    @code{skip}
  | @code{commit}
  | @code{release}
  | @code{await}  expr
  | @code{posit}  expr
  | @code{assert}  expr
  | @code{assign (} vid-list @code{;} expr-list @code{)}
  | @code{new (} vid @code{;} cid @code{;} expr-list @code{)}
  | @code{call (} vid @code{;} expr @code{;} string @code{;} expr-list @code{)}
  | @code{static (} vid @code{;} string @code{;} string @code{;} string @code{;} expr-list @code{)}
  | @code{multicast (} expr @code{;} string @code{;} expr-list @code{)}
  | @code{get (} expr @code{;} vid-list @code{)}
  | @code{return (} expr-list @code{)}
  | @code{free (} vid-list @code{)}
  | @code{tailcall (} expr @code{;} string @code{;} expr-list @code{)}
  | @code{statictail (} string @code{;} string @code{;} string @code{;} expr-list @code{)}
  | @code{(} merge-stmt @code{)}
  | @code{if} expression @code{th} merge-stmt @code{el} merge-stmt @code{fi}
  | @code{while} expression @code{do} merge-stmt @code{od}
  | run-time-stmt

run-time-stmt ::=
    @code{$cont (} label @code{)}
  | @code{$accept (} label @code{)}
  | @code{$assign (}vid-list @code{;} expr-list @code{)}
  | @code{$multicast (} expr @code{;} string @code{;} expr-list @code{)}
  | @code{failure}  expr
@end format
