@c node-name, next, previous, up
@node CMC
@chapter Creol Machine Code

In this chapter we describe the general structure of the machine in
Maude.  The machine is interpreting the Core Creol language, which is
mimicked by Maude terms.

Currently, three different interpreters are provided.  The first
interpreter, defined in file @file{creol-interpreter.maude} is
suitable for fine-grained simulation.  The second interpreter, defined
in the file @file{creol-modelchecker.maude}, is suitable for
coarse-grained simulation and model checking.  The third interpreter,
defined in @file{creol-realtime.maude}, is suitable for simulating
programs using the real-time extension (@pxref{Real-time Creol}).

All interpreters for Creol programs have a similar interface and
accept the same input terms for classes and objects.  The difference
between the Maude based targets of the compiler (@pxref{Target
Options}) are minimal and distinguished by enabling or disabling
certain transformations.  These transformations can be enabled or
disabled on the command-line (@pxref{Pass Options}).

The interpreters differ in the definition of some predicates, as
indicated below.  XXX

@menu
* Datatypes::           Explanation of datatypes.
* Configuration::       Data Structures describing configurations.
* Interpreter::         Creol Interpreter.
* Sort Hierarchy::      Summary of all sorts and how they relate.
* Using CMC::           Some notes on using the model.
@end menu


@node Datatypes
@section Datatypes

The file @file{datatypes.maude} containes the framework for datatype
definitions as well as the definition of the pre-defined datatypes.

The module @code{CREOL-DATA-SIG} defines the basic features of data
types for the machine.  First, it defines the basic sorts of the
expression language:  Attribute names @code{Aid} and so on ...

In addition, it defines the constant @code{null}, object identities
@code{ob(_)} and booleans @code{bool(_)}.

Operations are defined in terms of applications, which are given as
@code{Appl} terms.  They are declared as @c
@code{op _(_) : String ExprList -> Appl}.

@menu
* Datatype Signature::          How datatypes are defined.
* Predefined Datatypes::        Predefined datatypes.
* User Defined Datatypes::      How to define new datatypes.
@end menu


@node Datatype Signature
@subsection Datatype Signature

The module @code{CREOL-DATA-SIG} defines the signature of the
datatypes and expressions, i.e., it defines a kind of abstract syntax.
It also defines the basic functions defined for @emph{all} datatypes.

It defines the following sorts:
@table @code
@item Expr
Values of sort @code{Expr} are expressions.  Expressions are either
literals, which is any ground term of sort @code{Data}, variables,
which are of sort @code{Aid}, or applications, which are of sort
@code{Appl}.

@item Data
Values of sort @code{Data} are literals.  @code{Data} is a subsort of
@code{Expr}.

@item Aid
Values of sort @code{Aid} range over the attribute and variable
names.  While the creol language uses only lower-case variable names,
the interpreter reserves some other strings for its own purposes.

@item Oid
Values of sort @code{Oid} are the object identifiers.  The sort
@code{Oid} is a subsort of @code{Data}.

@item Label
@anchor{Label} Values of sort @code{Label} are the values of the
labels of asynchronous calls.  They are handles that identify the
call, allowing to wait for the result at the callers location, and
allowing to send the result at the receivers location.  This sort is a
subsort of @code{Data}.

@item Appl
Terms of this sort are function applications.  The sort @code{Appl} is
a subsort of term.  The sort @code{Appl} is a supersort of @code{Data}
(see @pxref{Application} for an explanation).
@end table

Lists of expressions and of data values are defined in this module,
too.  These lists are constructed using the @code{#} operator.  
@table @code
@item ExprList
A possibly empty list of expressions with identity @code{emp}.

@item DataList
A possibly empty list of values with identity @code{emp}.  This sort
is a subsort of @code{ExprList}.

@item NeExprList
A non-empty list of expressions.  This sort is a subsort of
@code{ExprList}.  @code{Expr} is a subsort of this sort.

@item NeDataList
A non-empty list of data.  This sort is a subsort of @code{DataList}.
@code{Data} is a subsort of this sort.
@end table

Furthermore, lists of attribute identifiers can be formed using
@code{,} as a constructor, with identity @code{noAid}.  These lists
occur as lists of parameters or as the left-hand side of assignments.

@table @code
@item AidList
A possibly empty list of @code{Aid}.

@item NeAidList
A non-empty list of @code{Aid}.  This sort is a subsort of
@code{AidList}.  The sort @code{Aid} is a subsort of this sort.
@end table

In addition, this module defines the sort @code{Bool} (@pxref{Boolean}).


@anchor{Application}
@subsubsection Application terms

At the core of the expression language is function application.  The
machine will maintain all function applications in prenex form, i.e.,
they are declared by the operators
@example
op _(_) : String DataList -> Data .
op _(_) : String ExprList -> Appl [ctor] .
@end example
In order to have a pre-regular model, the sort @code{Data} has to be a
subsort of @code{Appl}.

It is an error if a term @code{S:String(D:DataList)} cannot be reduced
to a @code{Data} value.  This usually occurs if the term is ill-typed,
i.e., we try to add an integer to a boolean.


@anchor{Reply}
@subsubsection Reply Guard

Guards can be arbitrary boolean expressions or they can test for the
arrival of a single reply with the syntax @code{@var{label} ??}.


@anchor{Equality}
@subsubsection Equality

Equality (and inequality) is defined for all datatypes.

@example
  vars D D' : Data .
  eq "=" (D # D') = bool(D == D') .
  eq "/=" (D # D') = bool(D =/= D') .
@end example


@node Predefined Datatypes
@subsection Predefined Datatypes

In this section we describe the pre-defined datatypes in the virtual
machine, the operations defined on them, and their semantics.

@menu
* Boolean::                     Booleans.
* Integer::                     Integers.
* Float::                       Floats.
* String::                      String.
* List::                        List.
* Set::                         Set.
* Pair::                        Pair.
* Time and Duration::           Time and Duration.
@end menu


@node Boolean
@subsubsection Boolean

The module @code{CREOL-DATA-SIG} defines these functions for booleans.

@example
  vars B B' : Bool .
  vars E E' : Expr .
  eq "||" (bool(true) # E) = bool(true) .
  eq "||" (bool(false) # E) = E .
  eq "&&" (bool(false) # E) = bool(false) .
  eq "&&" (bool(true) #  E) = E .
  eq "=>" (bool(true) # bool(false)) = bool(false) .
  eq "=>" (bool(true) # bool(true)) = bool(true) .
  eq "=>" (bool(false) # E') = bool(true) .
  eq "^" (bool(B) # bool(B')) = bool(B xor B') .
  eq "<=>" (bool(B) # bool(B')') = bool(B == B') .
@end example


@node Integer
@subsubsection Integer

XXX

The integer datatype is defined in the module @code{CREOL-DATA-INT}.
Integer values are constructed with
@example
  op int(_) : Int -> Data [ctor] .
@end example

The functions are defined as:
@example
  eq "-" (int(I)) = int(-(I)) .
  eq "<"  (int(I) # int(I')) = bool(I < I') .
  eq "<=" (int(I) # int(I')) = bool(I <= I') .
  eq ">"  (int(I) # int(I')) = bool(I > I') .
  eq ">=" (int(I) # int(I')) = bool(I >= I') .
  eq "+" (int(I) # int(I')) = int(I + I') .
  eq "-" (int(I) # int(I')) = int( _-_(I, I')) .
  eq "*" (int(I) # int(I')) = int(I * I') .
  eq "/" (int(I) # int(I')) = int(I quo I') .
  eq "%" (int(I) # int(I')) = int(I rem I') .
  eq "**" (int(I) # int(I')) = int(I ^ I') .
@end example


@node Float
@subsubsection Float

XXX

The floating point datatype is defined in the module
@code{CREOL-DATA-FLOAT}.  Integer values are constructed with
@example
  op float(_) : Float -> Data [ctor] .
@end example

The functions are defined as:
@example
  eq "-" (float(I)) = float(-(I)) .
  eq "<"  (float(I) # float(I')) = bool(I < I') .
  eq "<=" (float(I) # float(I')) = bool(I <= I') .
  eq ">"  (float(I) # float(I')) = bool(I > I') .
  eq ">=" (float(I) # float(I')) = bool(I >= I') .
  eq "+" (float(I) # float(I')) = float(I + I') .
  eq "-" (float(I) # float(I')) = float( _-_(I, I')) .
  eq "*" (float(I) # float(I')) = float(I * I') .
  eq "/" (float(I) # float(I')) = float(I quo I') .
  eq "%" (float(I) # float(I')) = float(I rem I') .
  eq "**" (float(I) # float(I')) = float(I ^ I') .
@end example




@node String
@subsubsection String

XXX

Strings are considered to be list of characters.  Strings are defined
in the module @code{CREOL-DATA-STRING}.  Therefore, the same
notation is used as for @code{List} (see @pxref{List}).

Strings are constructed with
@example
  op string(_) : String -> Data [ctor] .
@end example

The defined functions are:
@example
  eq "<" (str(S)# str(S')) = bool(S < S') .
  eq "<=" (str(S)# str(S')) = bool(S <= S') .
  eq ">" (str(S)# str(S')) = bool(S > S') .
  eq ">=" (str(S)# str(S')) = bool(S >= S') .
  eq "-|" (str(S) # str(S')) = str(S + S') .
  eq "|-|" (str(S) # str(S')) = str(S + S') .
  eq "|-" (str(S) # str(S')) = str(S + S') .
@end example


@node List
@subsubsection List

XXX

Lists are defined in the module @code{CREOL-DATA-LIST}.  A list is
constructed by:
@example
  op list(_) : DataList -> Data [ctor] .
@end example

The defined functions are:
@example
  eq "head" (list(emp)) = null .
  eq "head" (list(E # L)) = E .
  eq "last" (list(emp)) = null .
  eq "last" (list(L # E)) = E .
  eq "rest" (list(emp)) = null .
  eq "rest" (list(L # E)) = list(L) .
  eq "tail" (list(emp)) = null .
  eq "tail" (list(E # L)) = list(L) .

  eq "length" (list(emp)) = int(0) .
  eq "length" (list(E # L)) = "+" (int(1) # ("length" (list(L)))) .

  eq "isempty" (list(emp))  = bool(true) .
  eq "isempty" (list(E # L))= bool(false) .

  eq "remove" (list(E) # E')  = if  E == E' then list(emp) else list(E) fi .
  eq "remove" (list(emp)# E )  = list(emp) .
  eq "remove" (list(E # L)# E') =
    if E == E' then "remove" ((list(L))# E')
      else "|-|" (list(E) # ("remove" (list(L) # E'))) fi .

  eq "-|" (D # list(L)) = list(D # L) .
  eq "|-" (list(L) # D) = list(L # D) .

  eq "has" (list(emp)# E ) = bool(false) .
  eq "has" (list(E # L) # E) = bool(true) .
  eq "has" (list(E # L) # E') = "has" (list(L) # E') [otherwise] .

  ***index starts at 1
  eq "after" (list(emp) # int(N))    = null .
  eq "after" (list(E # L) # int(0))  = list(E # L) .
  eq "after" (list(E # L) # int(N))  =
    "after" ((list(L)) # "-" (int(N) # int(1))) .

  eq "index" ((list(L)) # int(0)) = null .
  eq "index" ((list(emp)) # int(N)) = null .
  eq "index" ((list(E # L)) # int(N)) =
    if (N == 1) then E else "index" (list(L) # "-" (int(N) # int(1))) fi .

  eq "begwith" (list(E) # E') = bool("head" (list(E)) == E') .
  eq "begwith" (list(E # L) # E') = bool("head" (list(E # L)) == E') .
  eq "begwith" (list(E) # E') = bool("last" (list(E)) == E') .
  eq "begwith" (list(E # L) # E') = bool("last" (list(L)) == E') .

  eq "|-|" (list(L) # list(L'))   = list(L # L') .
@end example


@node Set
@subsubsection Set

XXX


@node Pair
@subsubsection Pair

Pairs are explained in the next section. @c
@xref{User Defined Datatypes}.


@node Time and Duration
@subsubsection Time and Duration

The module @code{CREOL-DATA-TIME} defines the semantics of the two types
@code{Time} and @code{Duration}.  Currently, it defines an expression
@code{now} for representing the current time.  The type @code{Duration}
is interpreted by real numbers and reuses the module
@code{CREOL-DATA-FLOAT}.

If a model makes use of time, it has to be executed in the timed version
of the interpreter.  The other versions will not advance the value of
@code{now}, leading to deadlocks quickly.


@node User Defined Datatypes
@subsection Creating Your own Datatype

The procedure for creating your own datatype is illustrated with the
pair type.  The first thing to do is to write a functional module
which defines your new datatype as a subsort of @code{Data}.
Actuallly, we do not need to define another sort, but it is sometimes
useful for debugging.

@example
fmod CREOL-DATA-PAIR is
  extending CREOL-DATA-SIG .
  sort Pair .
  subsort Pair < Data .
@end example

Next we need a constructor for describing values of the new data
type.  Because a pair is a pair of values, we define:

@example
  op pair(_,_) : Data Data -> Pair [ctor] .
@end example

Now we need to define constructors and destructors for pairs.  These
are defined in terms of applications:

@example
  eq "pair" (D # D') = pair(D, D') .
  eq "fst" (pair(D, D')) = D .
  eq "snd" (pair(D, D')) = D' .
@end example

Note that we only define equations describing the semantics of the
functions ``pair'', ``fst'', and ``snd''.  This finishes the example.
Other functions can be defined, too, in this way.

@example
endfm
@end example

A future version of the compiler may allow the automatic generation of
Maude modules for user-defined datatypes.


@node Configuration
@section Data Structures Describing Configurations

In this section we explain the data structures forming a state of a
Creol system.

@menu
* Substitution::        Mapping variables to values.
* Statement::           Statements.
* Classes::             Classes.
* Object::              Objects as processors.
* Message::             Messages exchanged by objects.
* Evaluation::          How expressions are evaluated.
* Configurations::      Combining parts to global states.
@end menu


@node Substitution
@subsection Substitutions

The module @code{CREOL-SUBST} defines a mapping from variable
identifiers (of sort @code{Vid}) to values (of sort @code{Data}).  We
call this mapping a @emph{substitution}.  This substitution is defined
using Maude's @code{MAP} module.  In addition, the following operators
are defined:

@table @code
@item dom(A, S)
This predicate tests, whether the attribute name @code{aid} has a
value in the substitution @code{subst}.

@item compose(S1, S2)
This function computes the @emph{union} of the substitutions @code{S1}
and @code{S2}, where the bindings in @code{S2} override the bindings
in @code{S1}.

@item S1 # S2
This function constructs a @emph{union} of @code{S1} and @code{S2},
too.  However, in contrast to @code{compose(S1, S2)}, the union is not
actually computed, but if bindings are accessed, it is first checked,
whether it is defined in @code{S2} and then in @code{S1}.
@end table

Observe, that for all substitutions @code{S1} and @code{S2} and all
attribute identifiers @code{a} we have:
@example
compose(S1, S2)[a] = (S1 # S2)[a]
@end example

The advantage of @code{_#_} over compose is, that more attributes
are looked up from the local environment and the computation of the
union is costly.



@node Statement
@subsection Statements

The module @code{CREOL-STATEMENT} defines the syntax of statements on
the machine level.  Statements are values of the sort @code{Stm}.
Values of the subsort @code{SuspStm} are those statements which can
suspend the current activation (@pxref{Evaluation}).

@table @code
@item skip
This statement does nothing.

@item _::=_
An assignment statement.

@item _::= new_(_)
An object creation statement.

@item _!_(_)
An asynchronous call statement.

@item _?(_)
Receiving a reply.

@item await _
Suspend the process until the expression becomes true.  This form of
await is much more liberal than the one specified for creol, because
it allows the test for an reply to occur anywhere in the expression.
We assume that type checking will ensure that each use of a label is
positive.

@item release
Unconditionally release the processor and allow another process to be
scheduled.
@end table

In addition to these statements, which correspond to the statements of
the programming language, some support statements are defined on the
machine level.  They are not available to the programmer, but are
inserted by the compiler and the run-time system.

@table @code
@item assign
This statement is generated by the run-time system.  It performs the
actual substitution of the values in assignment statements.

@item return
This statement is used to generate the reply message.  It takes a list
of expressions as its argument.  This statement is generated by the
compiler as the last statement of each method.  The argument list is
@emph{always} the list of the method's out-parameters.

@item bury
This statement removes the binding of a variable from the local
environment (see @pxref{Process}).  It is generated by the compiler to
eliminate dead variables from the state.  This only occurs for model
checking.

@item free
This statement is used to notify a queue to discard a reply to a
label, as soon as it arrives.  In addition, the mapping of the label
name may be removed from the local invariant, like with the
@code{bury} statement above.  This only happens while model checking.

@item cont
This statement is generated by the run-time system to handle
self-calls.  If an object tries to receive the reply to a call sent to
itself, the object would usually dead-lock.  Instead, control is given
to the process of which the reply is expected.  The @code{cont}
statement is appended as the @emph{last} statement of the invoked
method, with the label as an argument, to indicate that control must
return to the corresponding reply statement.

@item tailcall
This statement is used to @emph{replace} the current process with a
new process, as indicated by the argument.  The purpose of this
statement is to optimize the number of states in tail-recursive calls
during model checking.

@item accept
The accept statement is a place-holder statement which avoids the
release of the processor during binding a tailcall.
@end table


@anchor{Compound Statements}
@subsubsection Compound Statements

Composed statements are defined in the module
@code{CREOL-STM-LIST}.

@table @code
@item _;_
Sequential composition of statements with identity @code{noStm}.

@item _[]_
Nondeterministic choice of statements.

@item _|||_
Non-deterministc merge of statements.  See @code{_MERGER_} below.

@item if_th_el_fi
The traditional conditional execution.

@item while_do_od
The traditional while loop.
@end table

In addition, the run-time system may introduce the following
statements:
@table @code
@item _MERGER_
A non-associative merge statement.
@end table


@anchor{Process}
@subsubsection Process

A process is a term of sort @code{Process} and is defined to be a pair
@code{(L, S)} of a substitution @code{L} and a (compound) statement
@code{S}.  The terminated process is also represented as @code{idle}.


@subsubsection Process Queue

A process queue is a @emph{multi-set} of processes, constructed by
@code{_++_}.  The empty process queue is represented by @code{noProc}.


@node Classes
@subsection Classes

Classes are the main building blocks of Creol programs, and classes
are represented at the CMC level, too.  A class comprises the super
classes, the attributes of a class, and the methods of a class.

@menu
* Inherit::
* Method::
* Class::
@end menu


@node Inherit
@subsubsection Inherit

Classes enumerate their super-classes, as well as the arguments they
provide to the super class during construction.  A term of the form
@code{"C" < @var{exprs} >} indicates that the contextual class inherits
from class @code{"C"} and provides @code{@var{exprs}} as a list of
actual arguments to @code{"C"}'s constructor.

Observe that the run-time system assumes that the class hierarchy is
acyclic.  If this is not the case, object creation may enter an infinite
loop.  @c See @xref{XXX} for details.


@node Method
@subsubsection Method

A method specifies its name, its formal parameters, its local variables,
and its body, i.e., a (compound) statement to execute if the method is
called.

A class may have a multiset of methods, which are seperated by @code{*}.


@node Class
@subsubsection Class

A class is a term @code{< @var{C} : Cl | Inh: @var{inh}, Par: @var{par},
Att: @var{att}, Mtds: @var{mtds}, Ocnt: @var{n} >}, where @var{C} is the
name of the class, @var{inh} is a list of classes from which the class
inherits (@pxref{Inherit}), where the empty list is represented by
@code{noInh}, @var{par} is a list of variable names which serve as the
constructor arguments, @var{att} is a substitution
(@pxref{Substitution}), collecting the attributes of @var{C}'s
instances, @var{mtds} is a multiset of methods, with the empty multiset
represented by @code{noMtd}, and @var{n} is a number representing the
number of instances of the class currently created in the system.


@node Object
@subsection Objects

An object is an instance of exactly one class.

Usually, an object is represented by a term @code{< @var{id} : @var{cl}
| Att: @var{A}, Pr: @var{P}, PrQ: @var{Ps}, Lcnt: @var{N} >}, where
@var{id} is a unique identity of the object, @var{cl} is the class of
the object, @var{A} is a substitution (@pxref{Substitution})
representing the valuation of the object's attributes, @var{P} is the
currently active processor, @var{Ps} represents the queue of inactive
processes, and @var{N} is a counter used to generate unique label
values.

The @emph{special} object @code{noObj} is unique, does not have an
identity, and no behaviour.  This object could be considered to be the
value of @code{null}.


@node Message
@subsection Messages

The module @code{CREOL-COMMUNICATION} defines messages and message
queues.  A message has sort @code{Msg}.  Message queues have sort
@code{MMsg} and are multi-sets of terms of sort @code{Body}.


@subsubsection Invocation message

An invocation message has the format @code{invoc(_,_,_,_)} and is of
sort @code{Body}, where the first parameter is an @emph{object
identity} representing the sender of the message, the second parameter
is a label, which identifies the call, the third parameter is the name
of the method, and the fourth parameter is a list of values
representing the actual arguments.


@subsubsection Completion message

Conversely, a completion message has the format @code{comp(_,_)} and
is of sort @code{Body}, where the first parameter represents the label
of the call, as supplied by the invocation message, and the second
parameter is a list of values representing the return values.


@subsubsection Messages

Given a message body (a term of sort @code{Body}), a message is formed
as a term @code{_from_to_}, where the first place holds the body, the
second term holds the identity of the sender and the last term holds
the identity of the receiver.


@subsubsection Bind method message

A bind method message is used to ask a class for a method body to an
invocation.  It has the format @code{bindMtd(_,_,_,_,_,_)}, where the
parameters have the following meaning:

@enumerate
@item
The first parameter indicates the caller of the method.  This value
will be used to initialise the variable @code{caller} in the bound
method.

@item
The second parameter indicates the identity of the callee.  The
bound process will be inserted into its process queue.

@item
The this parameter indicates the label of the call.  This value is
used to initialise the hidden variable @code{.label} and is used for
sending the completion message.

@item
The fourth parameter indicates the name of the method to bind to.

@item
The fifth parameter is a list of values which represent the actual
arguments to the call.

@item
The sixth parameter is a list of classes in which the method is to be
searched for.
@end enumerate


@subsubsection Bound method message

This message is created after the method has successfully been bound.
It has the format @code{boundMtd(_,_)}, where the first parameter
represents the identity of the callee and the second parameter
represents the process to execute.


@subsubsection Message queue

A message queue has the sort @code{Queue} and the format @c
@code{<_: Qu | Size:_, Dealloc:_, Ev:_ >}.  The parameters represent
the following:
@enumerate
@item
The first parameter indicates the identity of the owner of the message
queue.

@item
The second parameter indicates its size.  More importantly, it
indicates the number of messages one may still insert into the queue.

@item
The third parameter is a multiset of labels marked for deallocation.
The multiset is constructed with the constructor @code{_^_} and has
the identity @code{noDealloc}.

@item
The fourth parameter is a multiset of invocation and completion
message bodies.  The multiset of invocations and completions is
constructed by @code{_+_} and has the identity @code{noMsg}.
@end enumerate


@node Evaluation
@subsection Evaluation of Expressions

The module @code{CREOL-EVAL} defines expressions and how they are
evaluated, by extending the @code{DATATYPE} module, which defines the
semantics of all (elementary) datatypes (see @pxref{Datatypes}).

The operation @code{eval(e, S)} evaluates an expression @code{e} in
the context @code{S}.  This is essentially done by reducing all
function arguments to data in the hope that an equation defined for
the data types can be applied to obtain the function-application's
value.

The operation @code{evalList} maps eval on expression lists (of sort
@code{ExprList}) to a list of data (of sort @code{DataList}).


@node Configurations
@subsection Configurations

The module @code{CREOL-CONFIG} defines the sort @code{Configuration}
which defines a global state configuration of a Creol model.
Essentially, a configuration is a multiset of messages, message
queues, classes, and objects.  The identity is called @code{noConf}.

This module defines an additional sort @code{State} (or reuses it from
@code{MODEL-CHECKER}), which is a parenthised Configuration, written
@code{@{_@}}.

Finally, the @code{main(_,_)} operation is defined, where the first
parameter is the name of a class, say @var{C}, and the second
parameter is a list of expressions used to initialise the first
instance of the system.  That instance will be an instance of class
@var{C}.


@node Interpreter
@section Creol Interpreter

The interpreter defines the semantics of Creol in terms of rewriting
rules.  We refer the reader to the module @code{INTERPRETER} in the file
@code{creol-interpreter.maude} (@pxref{Setting CMC Up}) for the exact
definition of the rules.  Here, we give an overview of the rules and
equations.  The names given below can be used for tracing the rules
using Maudes trace facility.

@table @code
@item assign
These rules execute assignment statements of the form @code{AL assign
DL}, where @code{AL} and @code{DL} are lists of attributes resp. lists
of data values.  Two auxiluary equations will perform the actual
assignment:  @code{do-static-assign} for assigning to attributes and
@code{do-assign} for 

@item skip
This rule executes a skip statement.

@item if-th
This rule executes an if-then-else statement.

@item while
This rule executes a while statement.

@item new-object
This rule creates a new object, initialises it, and executes its
run-method.

@item nondet
This rule executes a non-deterministic choice statetement.

@item merge
@anchor{Merge}
This rule executes a merge (@code{S1 ||| S2}) statement by choosing an
enabled branch and setting up a @code{S1 MERGER S2} statement, where
@code{S1} is the statement to execute now.

@item merge-aux
This rule executes a @code{S1 MERGER S2} statement.

@item local-call
This rule executes a local call.  More specifically, it moves control
to the called process if the current process is blocking on the reply
of a self-call.  This avoids a deadlock when a process calls itself.
The actual return from a self-call is handled by rule @code{continue},
@pxref{Continue}.

@item local-call-in-merge
This rule executes a local call within a @code{MERGER} statement.

@item suspend
Suspend a process.

@item guard
Execute an await statement if the guard is enabled.

@item PrQ-ready
Wake up a suspended process.

@item tailcall
Execute a @code{tailcall} statement.

@item accept
Execute a @code{accept} statement.

@item receive-call-req
If we receive an invocation message, start binding the method body.
This rule ie used for virtual calls @code{m}.

@item receive-static-call-req
If we receive an invocation message, start binding the method body.
This rule is used for static calls @code{m @ c}.

@item receive-call-bound
If a method is bound, enqueue it into the process queue.


@item continue
@anchor{Continue} Continue execution after a syncrhonous self-call has
terminated.  It replaces the currently active process with its local
caller.  Observe, that the completion message of the call has already
been emitted.

@item continue2
@anchor{Continue2} This rule executes a @code{continue} statement in a
@code{S1 MERGER S2} statement.

@item local-async-reply
Execute a local asynchronous method call.

@item local-async-qualified-req
Execute a local asynchronous method call with a class qualifier.

@item return
Emit a reply statement.

@item invoc-msg
Move an invocation message into the queue.

@item free
Schedule the labels identified in the argument of the @code{free}
statement for deallocation (see the rule @code{deallocate} below).  At
the same time, the value of that label is set to @code{null}.  This is
done to ensure linearity of the use of labels.

@item deallocate
If a label @var{l} has been deallocated by a free statement, and the
completion message to the call with label @var{l} arrives, the
completion message will be removed by this equation.
@end table


@subsection Rules defined for real-time simulation

For simulating timed Creol, the system defined two operators
@code{posit}, which check whether all posit constraints in a given
@code{State} are satisfied.

@table @code
@item tick
This rule is used to advance the clock.  It is enabled, if all posit
constraints in the current state remain valid by advancing the value
of the global clock.
@end table


@node Sort Hierarchy
@section Sort Hierarchy

XXX


@node Using CMC
@section Using the CMC

In this section we describe the necessary steps for setting up the
interpreter and the model checker and to simulate and analyze the
Creol model.

The compiler targets an interpreter which has been formalised in
rewriting logic and which is executable in Maude.  The
@command{creoltools} provide the interpreter and the model checker,
but they do not provide Maude.  Maude has to be obtained and installed
seperately, e.g., from @url{http://maude.cs.uiuc.edu}.  Maude then
needs to be configured for use with the semantics of Creol, as
described in @ref{Setting CMC Up}.

@menu
* Setting CMC Up::
* Simulation::
* Meta Execution::
@end menu


@node Setting CMC Up
@subsection Setting the CMC Up

The Creol Machine described in this chapter runs on top of the Maude
rewriting system, which can be obtained at
@url{http://maude.cs.uiuc.edu}.  The CMC itself is defined in the
files @file{creol-datatypes.maude} and @file{creol-interpreter.maude},
whereas the meta execution strategy (@pxref{Meta Execution}) is
defined in @file{creol-metaexec.maude}.

These data files are distributed in the subdirectory @file{share} of the
distrbution.  They will be installed into
@file{@var{$datadir}/creoltools}, usually
@file{/usr/local/share/creoltools}.  To use the CMC we have to tell
Maude where it can find these support files.  Maude searches in
the environment variable @env{MAUDE_LIB} for its support files.  We
suggest that you append the directory of the CMC files to this variable,
for example, using these commands in @command{bash}:
@example
export CREOL_LIB=@var{/path/to/support/files}
export MAUDE_LIB=$@{MAUDE_LIB:+"$MAUDE_LIB:"@}$CREOL_LIB
@end example

You can append these two lines to your @file{~/.bashrc} to have these
variables set for each login.

Please ask your system administrator for setting up the CMC in different
environments.


@node Simulation
@subsection Simulating Programs

The code generated by the compiler can be executed on the CMC, which we
have described in this chapter.
The program itself is defined as a constant @code{init}.
The generated code does not contain
any objects, therefore an object must be created during initalisation.
The function @code{main(@var{class}, @var{args})} will create a class-less
object which creates an instance of @var{class} with the expression list
@var{args} as argument to the constructor.  For example, the initial
configuration of the Sieve system can be started using the maude command
@code{red init main("Generator", emp) .}

The rewrite command can be used to have the system run.  This is using
Maudes built-in rewrite command.  The parameter in square brackets is
the number of rule-applications to perform, e.g.,
@code{rew[1000] init main("Generator", emp) .} obtains a state after 
1000 rule applications from the intial configuration.

A slightly different state can be obtained using maudes @emph{fair}
execution strategy with
@code{rew[1000] init main("Generator", emp) .}

It is often the case, that these commands will show some state but will
not show the desired behaviour.  For small systems we advise to use
Maude's @code{search} command for checking whether there exists a
computation from the initial configuration to a desired (or undesired)
state exists.

For larger systems, random execution, as described in the next section
(see @pxref{Meta Execution}).


@node Meta Execution
@subsection Strategies for Execution

Because the simulation done by maude often give not the desired results,
a strategy for more random executions is provided.  You can load and use
this strategy from the maude session in which the program is to be
interpreted with @command{load creol-metaexec}.

This provides one additional term @command{simulate}.  It accepts a
@code{Qid} designating the module on the meta-level, usually
@code{'PROGRAM}, the meta-representation of the initial configuration, a
random @var{seed}, and the number of @var{steps}.  Often, the command as
@command{downTerm(simulate('PROGRAM, upTerm(init main(@var{Main},
@var{args})), @var{seed}, @var{steps}))}.

The @var{seed} is used to seed the random generator, which drives the
selection of the successor state.  Different seeds will result in
different runs and configurations, whereas one seed will always produce
the same result.

We encourage you to use @file{creol-metaexec.maude} as a model for
writing your own execution strategies for the CMC.
