@c node-name, next, previous, up
@node CMC
@chapter Creol Machine Code

In this chapter we describe the general structure of the machine in
Maude.  The contents of this chapter assumes familarity with Maude.

@menu
* Datatypes::          Explanation of datatypes.
* Configuration::       Data Structures describing configurations.
* Interpreter::         Creol Interpreter.
* Model Checker::       Creol Model Checker in Maude.
* Sort Hierarchy::      Summary of all sorts and how they relate.
@end menu

@node Datatypes
@section Datatypes

The file @file{datatypes.maude} containes the framework for datatype
definitions as well as the definition of the pre-defined datatypes.

The module @code{CREOL-DATA-SIG} defines the basic features of data
types for the machine.  First, it defines the basic sorts of the
expression language:  Attribute names @code{Aid} and so on ...

In addition, it defines the constant @code{null}, object identities
@code{ob(_)} and booleans @code{bool(_)}.

Operations are defined in terms of applications, which are given as
@code{Appl} terms.  They are declared as @c
@code{op _(_) : String ExprList -> Appl}.

@menu
* Datatype Signature::          How datatypes are defined.
* Predefined Datatypes::        Predefined datatypes.
* User Defined Datatypes::      How to define new datatypes.
@end menu


@node Datatype Signature
@subsection Datatype Signature

The module @code{CREOL-DATA-SIG} defines the signature of the
datatypes and expressions, i.e., it defines a kind of abstract syntax.
It also defines the basic functions defined for @emph{all} datatypes.

It defines the following sorts:
@table @code
@item Expr
Values of sort @code{Expr} are expressions.  Expressions are either
literals, which is any ground term of sort @code{Data}, variables,
which are of sort @code{Aid}, or applications, which are of sort
@code{Appl}.

@item Data
Values of sort @code{Data} are literals.  @code{Data} is a subsort of
@code{Expr}.

@item Aid
Values of sort @code{Aid} range over the attribute and variable
names.  While the creol language uses only lower-case variable names,
the interpreter reserves some other strings for its own purposes.

@item Oid
Values of sort @code{Oid} are the object identifiers.  The sort
@code{Oid} is a subsort of @code{Data}.

@item Label
Values of sort @code{Label} are the values of the labels of
asynchronous calls.  This sort is a subsort of @code{Data}.

@item Appl
Terms of this sort are function applications.  The sort @code{Appl} is
a subsort of term.  The sort @code{Appl} is a supersort of @code{Data}
(see @pxref{Application} for an explanation).
@end table

Lists of expressions and of data values are defined in this module,
too.  These lists are constructed using the @code{#} operator.  
@table @code
@item ExprList
A possibly empty list of expressions with identity @code{emp}.

@item DataList
A possibly empty list of values with identity @code{emp}.  This sort
is a subsort of @code{ExprList}.

@item NeExprList
A non-empty list of expressions.  This sort is a subsort of
@code{ExprList}.  @code{Expr} is a subsort of this sort.

@item NeDataList
A non-empty list of data.  This sort is a subsort of @code{DataList}.
@code{Data} is a subsort of this sort.
@end table

Furthermore, lists of attribute identifiers can be formed using
@code{,} as a constructor, with identity @code{noAid}.  These lists
occur as lists of parameters or as the left-hand side of assignments.

@table @code
@item AidList
A possibly empty list of @code{Aid}.

@item NeAidList
A non-empty list of @code{Aid}.  This sort is a subsort of
@code{AidList}.  The sort @code{Aid} is a subsort of this sort.
@end table

In addition, this module defines the sort @code{Bool} (@pxref{Boolean}).

@anchor{Application}
@subsubsection Application terms

At the core of the expression language is function application.  The
machine will maintain all function applications in prenex form, i.e.,
they are declared by the operators
@example
op _(_) : String DataList -> Data .
op _(_) : String ExprList -> Appl [ctor] .
@end example
In order to have a pre-regular model, the sort @code{Data} has to be a
subsort of @code{Appl}.

It is an error if a term @code{S:String(D:DataList)} cannot be reduced
to a @code{Data} value.  This usually occurs if the term is ill-typed,
i.e., we try to add an integer to a boolean.


@anchor{Equality}
@subsubsection Equality

Equality (and inequality) is defined for all datatypes.

@example
  vars D D' : Data .
  eq "=" (D # D') = bool(D == D') .
  eq "/=" (D # D') = bool(D =/= D') .
@end example


@node Predefined Datatypes
@subsection Predefined Datatypes

In this section we describe the pre-defined datatypes in the virtual
machine, the operations defined on them, and their semantics.

@menu
* Boolean::     Booleans.
* Integer::     Integers.
* Float::       Floats.
* String::      String.
* List::        List.
* Set::         Set.
* Pair::        Pair.
@end menu


@node Boolean
@subsubsection Boolean

The module @code{CREOL-DATA-SIG} defines these functions for booleans.

@example
  vars B B' : Bool .
  vars E E' : Expr .
  eq "||" (bool(true) # E) = bool(true) .
  eq "||" (bool(false) # E) = E .
  eq "&&" (bool(false) # E) = bool(false) .
  eq "&&" (bool(true) #  E) = E .
  eq "=>" (bool(true) # bool(false)) = bool(false) .
  eq "=>" (bool(true) # bool(true)) = bool(true) .
  eq "=>" (bool(false) # E') = bool(true) .
  eq "^" (bool(B) # bool(B')) = bool(B xor B') .
  eq "<=>" (bool(B) # bool(B')') = bool(B == B') .
@end example


@node Integer
@subsubsection Integer

XXX

The integer datatype is defined in the module @code{CREOL-DATA-INT}.
Integer values are constructed with
@example
  op int(_) : Int -> Data [ctor] .
@end example

The functions are defined as:
@example
  eq "-" (int(I)) = int(-(I)) .
  eq "<"  (int(I) # int(I')) = bool(I < I') .
  eq "<=" (int(I) # int(I')) = bool(I <= I') .
  eq ">"  (int(I) # int(I')) = bool(I > I') .
  eq ">=" (int(I) # int(I')) = bool(I >= I') .
  eq "+" (int(I) # int(I')) = int(I + I') .
  eq "-" (int(I) # int(I')) = int( _-_(I, I')) .
  eq "*" (int(I) # int(I')) = int(I * I') .
  eq "/" (int(I) # int(I')) = int(I quo I') .
  eq "%" (int(I) # int(I')) = int(I rem I') .
  eq "**" (int(I) # int(I')) = int(I ^ I') .
@end example


@node Float
@subsubsection Float

XXX

The floating point datatype is defined in the module
@code{CREOL-DATA-FLOAT}.  Integer values are constructed with
@example
  op float(_) : Float -> Data [ctor] .
@end example

The functions are defined as:
@example
  eq "-" (float(I)) = float(-(I)) .
  eq "<"  (float(I) # float(I')) = bool(I < I') .
  eq "<=" (float(I) # float(I')) = bool(I <= I') .
  eq ">"  (float(I) # float(I')) = bool(I > I') .
  eq ">=" (float(I) # float(I')) = bool(I >= I') .
  eq "+" (float(I) # float(I')) = float(I + I') .
  eq "-" (float(I) # float(I')) = float( _-_(I, I')) .
  eq "*" (float(I) # float(I')) = float(I * I') .
  eq "/" (float(I) # float(I')) = float(I quo I') .
  eq "%" (float(I) # float(I')) = float(I rem I') .
  eq "**" (float(I) # float(I')) = float(I ^ I') .
@end example




@node String
@subsubsection String

XXX

Strings are considered to be list of characters.  Strings are defined
in the module @code{CREOL-DATA-STRING}.  Therefore, the same
notation is used as for @code{List} (see @pxref{List}).

Strings are constructed with
@example
  op string(_) : String -> Data [ctor] .
@end example

The defined functions are:
@example
  eq "<" (str(S)# str(S')) = bool(S < S') .
  eq "<=" (str(S)# str(S')) = bool(S <= S') .
  eq ">" (str(S)# str(S')) = bool(S > S') .
  eq ">=" (str(S)# str(S')) = bool(S >= S') .
  eq "-|" (str(S) # str(S')) = str(S + S') .
  eq "|-|" (str(S) # str(S')) = str(S + S') .
  eq "|-" (str(S) # str(S')) = str(S + S') .
@end example


@node List
@subsubsection List

XXX

Lists are defined in the module @code{CREOL-DATA-LIST}.  A list is
constructed by:
@example
  op list(_) : DataList -> Data [ctor] .
@end example

The defined functions are:
@example
  eq "head" (list(emp)) = null .
  eq "head" (list(E # L)) = E .
  eq "last" (list(emp)) = null .
  eq "last" (list(L # E)) = E .
  eq "rest" (list(emp)) = null .
  eq "rest" (list(L # E)) = list(L) .
  eq "tail" (list(emp)) = null .
  eq "tail" (list(E # L)) = list(L) .

  eq "length" (list(emp)) = int(0) .
  eq "length" (list(E # L)) = "+" (int(1) # ("length" (list(L)))) .

  eq "isempty" (list(emp))  = bool(true) .
  eq "isempty" (list(E # L))= bool(false) .

  eq "remove" (list(E) # E')  = if  E == E' then list(emp) else list(E) fi .
  eq "remove" (list(emp)# E )  = list(emp) .
  eq "remove" (list(E # L)# E') =
    if E == E' then "remove" ((list(L))# E')
      else "|-|" (list(E) # ("remove" (list(L) # E'))) fi .

  eq "-|" (D # list(L)) = list(D # L) .
  eq "|-" (list(L) # D) = list(L # D) .

  eq "has" (list(emp)# E ) = bool(false) .
  eq "has" (list(E # L) # E) = bool(true) .
  eq "has" (list(E # L) # E') = "has" (list(L) # E') [otherwise] .

  ***index starts at 1
  eq "after" (list(emp) # int(N))    = null .
  eq "after" (list(E # L) # int(0))  = list(E # L) .
  eq "after" (list(E # L) # int(N))  =
    "after" ((list(L)) # "-" (int(N) # int(1))) .

  eq "index" ((list(L)) # int(0)) = null .
  eq "index" ((list(emp)) # int(N)) = null .
  eq "index" ((list(E # L)) # int(N)) =
    if (N == 1) then E else "index" (list(L) # "-" (int(N) # int(1))) fi .

  eq "begwith" (list(E) # E') = bool("head" (list(E)) == E') .
  eq "begwith" (list(E # L) # E') = bool("head" (list(E # L)) == E') .
  eq "begwith" (list(E) # E') = bool("last" (list(E)) == E') .
  eq "begwith" (list(E # L) # E') = bool("last" (list(L)) == E') .

  eq "|-|" (list(L) # list(L'))   = list(L # L') .
@end example


@node Set
@subsubsection Set

XXX


@node Pair
@subsubsection Pair

Pairs are explained in the next section. @c
@xref{User Defined Datatypes}.




@node User Defined Datatypes
@subsection Creating Your own Datatype

The procedure for creating your own datatype is illustrated with the
pair type.  The first thing to do is to write a functional module
which defines your new datatype as a subsort of @code{Data}.
Actuallly, we do not need to define another sort, but it is sometimes
useful for debugging.

@example
fmod CREOL-DATA-PAIR is
  extending CREOL-DATA-SIG .
  sort Pair .
  subsort Pair < Data .
@end example

Next we need a constructor for describing values of the new data
type.  Because a pair is a pair of values, we define:

@example
  op pair(_,_) : Data Data -> Pair [ctor] .
@end example

Now we need to define constructors and destructors for pairs.  These
are defined in terms of applications:

@example
  eq "pair" (D # D') = pair(D, D') .
  eq "fst" (pair(D, D')) = D .
  eq "snd" (pair(D, D')) = D' .
@end example

Note that we only define equations describing the semantics of the
functions ``pair'', ``fst'', and ``snd''.  This finishes the example.
Other functions can be defined, too, in this way.

@example
endfm
@end example

A future version of the compiler may allow the automatic generation of
Maude modules for user-defined datatypes.


@node Configuration
@section Data Structures Describing Configurations

In this section we explain the data structures forming a state of a
Creol system.

@menu
* Substitution::        Mapping variables to values.
* Guard::               Expressions used as guards.
* Statement::           Statements.
* Classes::             Classes.
* Object::              Objects as processors.
* Message::             Messages exchanged by objects.
* Configurations::      Combining parts to global states.
@end menu


@node Substitution
@subsection Substitutions

The module @code{CREOL-SUBST} defines a mapping from attribute names
(of sort @code{Aid}) to values (of sort @code{Data}).  We call this
mapping a @emph{substitution}.  This substitution is defined using
Maude's @code{MAP} module.  In addition, the following operators are
defined:

@table @code
@item dom(aid, subst)
This predicate tests, whether the attribute name @code{aid} has a
value in the substitution @code{subst}.

@item compose(S1, S2)
This function computes the @emph{union} of the substitutions @code{S1}
and @code{S2}, where the bindings in @code{S2} override the bindings
in @code{S1}.

@item S1 # S2
This function constructs a @emph{union} of @code{S1} and @code{S2},
too.  However, in contrast to @code{compose(S1, S2)}, the union is not
actually computed, but if bindings are accessed, it is first checked,
whether it is defined in @code{S2} and then in @code{S1}.
@end table

Observe, that for all substitutions @code{S1} and @code{S2} and all
attribute identifiers @code{a} we have:
@example
compose(S1, S2)[a] = (S1 # S2)[a]
@end example

The advantage of @code{_#_} over compose is, that more attributes
are looked up from the local environment and the computation of the
union is costly.


@subsection Evaluation of Expressions

The module @code{CREOL-EVAL} defines expressions and how they are
evaluated, by extending the @code{DATATYPE} module, which defines the
semantics of all (elementary) datatypes (see @pxref{Datatypes}).

The operation @code{eval(e, S)} evaluates an expression @code{e} in
the context @code{S}.  This is essentially done by reducing all
function arguments to data in the hope that an equation defined for
the data types can be applied to obtain the function-application's
value.

The operation @code{evalList} maps eval on expression lists (of sort
@code{ExprList}).


@node Guard
@subsection Guards

The module @code{CREOL-GUARD} defines the syntax of guard
expressions on the machine level.

Guards can be arbitrary boolean expressions or thet can test for the
arrival of a reply with the syntax @code{@var{label} ??}.

More complex guards may be constructed by conjunction, represented by
the binary operator @code{&}.  This ability will be removed once the
compiler can split conjunctions of guards into individual await
statements.


@node Statement
@subsection Statements

The module @code{CREOL-STATEMENT} defines the syntax of statements on
the machine level.

@table @code
@item skip
This statement does nothing.

@item _::=_
An assignment statement.

@item _::= new_(_)
An object creation statement.

@item _!_(_)
An asynchronous call statement.

@item _?(_)
Receiving a reply.

@item await _
Awaiting a condition.

@item release
Unconditionally release the processor and allow another process to be
scheduled.
@end table

In addition to these statements, which correspond to the statements of
the programming language, some support statements are defined on the
machine level.  They are not available to the programmer, but are
inserted by the compiler and the run-time system.

@table @code
@item assign
This statement is generated by the run-time system.  It performs the
actual substitution of the values in assignment statements.

@item return
This statement is used to generate the reply message.  It takes a list
of expressions as its argument.  This statement is generated by the
compiler as the last statement of each method.  The argument list is
@emph{always} the list of the method's out-parameters.

@item bury
This statement removes the binding of a variable from the local
environment (see @pxref{Process}).  It is generated by the compiler to
eliminate dead variables from the state.  This only occurs for model
checking.

@item free
This statement is used to notify a queue to discard a reply to a
label, as soon as it arrives.  In addition, the mapping of the label
name may be removed from the local invariant, like with the
@code{bury} statement above.  This only happens while model checking.

@item cont
This statement is generated by the run-time system to handle
self-calls.  If an object tries to receive the reply to a call sent to
itself, the object would usually dead-lock.  Instead, control is given
to the process of which the reply is expected.  The @code{cont}
statement is appended as the @emph{last} statement of the invoked
method, with the label as an argument, to indicate that control must
return to the corresponding reply statement.

@item tailcall
This statement is used to @emph{replace} the current process with a
new process, as indicated by the argument.  The purpose of this
statement is to optimize the number of states in tail-recursive calls
during model checking.

@item accept
The accept statement is a place-holder statement which avoids the
release of the processor during binding a tailcall.
@end table


@anchor{Compound Statements}
@subsubsection Compound Statements

Composed statements are defined in the module
@code{CREOL-STM-LIST}.

@table @code
@item _;_
Sequential composition of statements with identity @code{noStm}.

@item _[]_
Nondeterministic choice of statements.

@item _|||_
Non-deterministc merge of statements.  See @code{_MERGER_} below.

@item if_th_el_fi
The traditional conditional execution.

@item while_do_od
The traditional while loop.
@end table

In addition, the run-time system may introduce the following
statements:
@table @code
@item _MERGER_
A non-associative merge statement.
@end table


@anchor{Process}
@subsubsection Process

A process is a term of sort @code{Process} and is defined to be a pair
@code{(L, S)} of a substitution @code{L} and a (compound) statement
@code{S}.  The terminated process is also represented as @code{idle}.


@subsubsection Process Queue

A process queue is a @emph{multi-set} of processes, constructed by
@code{_++_}.  The empty process queue is represented by @code{noProc}.


@node Classes
@subsection Classes

XXX

@menu
* Inherit::
* Method::
* Class::
@end menu


@node Inherit
@subsubsection Inherit

XXX


@node Method
@subsubsection Method

XXX


@node Class
@subsubsection Class

XXX


@node Object
@subsection Objects

XXX


@node Message
@subsection Messages

XXX


@node Configurations
@subsection Configurations

XXX



@node Interpreter
@section Creol Interpreter

The interpreter defines the semantics of Creol in terms of rewriting
rules.  We refer the reader to the module @code{INTERPRETER} for the
exact definition of the rules.  Here, we give an overview of the rules
and equations.  The names given below can be used for tracing the
rules using Maudes trace facility.

@table @code
@item assign
These rules execute assignment statements of the form @code{AL assign
DL}, where @code{AL} and @code{DL} are lists of attributes resp. lists
of data values.

@item skip
This rule executes a skip statement.

@item if-th
This rule executes an if-then-else statement.

@item while
This rule executes a while statement.

@item new-object
This rule creates a new object, initialises it, and executes its
run-method.

@item nondet
This rule executes a non-deterministic choice statetement.

@item merge
This rule executes a merge (@code{S1 ||| S2}) statement by choosing an
enabled branch and setting up a @code{S1 MERGER S2} statement, where
@code{S1} is the statement to execute now.

@item merge-aux
This rule executes a @code{S1 MERGER S2} statement.

@item continue2
This rule executes a continue statement in a @code{S1 MERGER S2}
statement.

Can this actually happen?

@item local-call
This rule executes a local call statement.

XXX: See also above for continue.

@item local-call-in-merge
This rule executes a local call within a @code{MERGER} statement.

@item suspend
Suspend a process.

@item guard
Execute an await statement if the guard is enabled.

@item PrQ-ready
Wake up a suspended process.

@item tailcall
Execute a @code{tailcall} statement.

@item accept
Execute a @code{accept} statement.

@item receive-call-req
If we receive an invocation message, start binding the method body.
@code{m} and @code{m @ c}.

@item receive-call-bound
If a method is bound, enqueue it into the process queue.

@item continue
Continue from a self call.

@item local-async-reply
Execute a local asynchronous method call.

@item local-async-qualified-req
Execute a local asynchronous method call with a class qualifier.

@item return
Emit a reply statement.

@item invoc-msg
Move an invocation message into the queue.

@item free
Schedule a label such that the corresponding reply can be removed.

@item deallocate
If the reply arrives, remove it immediately.

@item bury
Bury a variable, i.e., remove it from the local bindings.
@end table


@node Model Checker
@section Creol Model Checker

XXX


@node Sort Hierarchy
@section Sort Hierarchy

