@node Creol
@chapter Creol

CREOL: An exciting mix of the best ingredients from many cultures!


CREOL: A formal framework for reflective component modelling

 The CREOL project is an ongoing research project 2004 - 2008, funded
by the Research Council of Norway through the strategic programme
IKT-2010. The goal of the project is to develop a formal framework and
tool for reasoning about dynamic and reflective modifications in
object-oriented open distributed systems, ensuring reliability and
correctness of the overall system.

@menu
* Overview::    A short overview to Creol and its ideas.
* Features::    What Creol provides and why it is different.
* Syntax::      A short guide to the language.
* Grammar::     Creol grammar in EBNF.
@end menu


@node Overview 
@section Short project overview

Open distributed systems consist of geographically spread system
components subject to run-time modifications. These systems are
becoming increasingly important in modern society, for instance for
safety-critical infrastructure. A major challenge for safety-critical
open distributed systems is to ensure the reliability and correctness
of the overall system when components are dynamically modified, so
that development, maintenance, and upgrade of system components happen
in a controlled manner.

The CREOL project is a research project to investigate programming
constructs and reasoning control in the context of open distributed
systems, and in particular the issue of maintenance control, taking an
object-oriented approach. The project focuses on support for component
adaptability, combined with a platform for executable specification
and analysis of system models. This allows an investigation at two
levels: a theoretical framework for reasoning about software and
software updates, and a tool for practical experimentation with the
consequences and possibilities of the theoretical choices. The goal of
the project is to develop a formal framework and tool for reasoning
about dynamic and reflective modifications in open distributed
systems, ensuring reliability and correctness of the overall system.

These issues will be investigated in the context of Creol, an
experimental high-level object-oriented language for distributed
objects. The name is an acronym for Concurrent Reflective
Object-oriented Language. The language is based on concurrent objects
communicating by means of asynchronous method calls, and is formally
defined with an operational semantics expressed in rewriting
logic. The basic communication mechanisms and operational semantics of
the language are described in [9, 2]. The inclusion of multiple
inheritance in the language and the operational semantics is described
in [7]. A type and effect system for the language is given in [1].

Specifications in rewriting logic are executable in the rewriting
logic tool Maude. A prototype Maude interpreter for the communication
basis of the Creol language has been developed and extended with a
pseudo-deterministic rewrite strategy in order to better simulate the
non-determinism of a distributed environment [11].

The language and the interpreter will gradually be extended to
incorporate facilities for reflective programming, dynamic updates,
and a coordination language based on viewpoint specifications (or
behavioral interfaces) [12, 17]. An extension of the language and the
interpreter with a dynamic class construct is presented in [5]. A
binding strategy for method calls which is adapted to dynamic class
extensions is presented in [4]. A type system for runtime class
updates is presented in [3].


@node Features
@section Features

Creol is a @emph{strongly typed} language, in the sense that it is
type safe.  Function and method calls which disregard data types
are rejected.

Creol is a @emph{statically typed} language.  The compiler tries to
infer, whether a function call or a method call is safe in the sense
that it will succeed.  Programs in which a call cannot succeed because
of the type of an operation or a method are rejected.

Message dispatch in Creol is based not only on the type of the receiver
of the message, but also on the arguments (multiple dispatch @cite{XXX}),
especially the type of the caller (which is constrained by the
@emph{co-interface} and available in any method body under the name
@code{caller}.

The @code{caller} mechanism is similar to @code{context} in Smalltalk-80,
but it does not, e.g., provide information on the call-chain.




@node Syntax
@section Syntax of Creol

In this section we describe the syntax of Creol and sketch the
informal semantics of Creol programs.

@subsection Literals and Expressions

Creol assumes a functional sub-language, which we describe in this
section.

@subsubsection Boolean Expressions

TBD

@subsubsection Integers, Reals, and Arithmetic Expressions

TBD

@subsubsection Strings

TBD


@subsubsection Object Expressions and Literals

Object expressions and literals are expressions whose value is a
reference to an object.  The only literal is @code{null}, representing
the null-pointer.

@subsubsection Function Application

Generally, applying a function is written as
@code{@var{f}[@var{e},@var{d},...,@var{c}]}, where @var{f} is the name
of a function and @var{e},@var{d},@dots{} refers to expressions
representing the actual arguments.


@subsection Basic Statements

In this section we describe the statements of Creol programs.


@subsubsection Assignments

A single assignment may be written as @code{@var{x} := @var{e}}, where
@var{x} is the name of an attribute or a local variable and @var{e}
is an expression.

A multiple assingment is written as
@code{@var{x},@var{y},...,@var{z} := @var{e},@var{f},...,@var{g}},
where the left hand side is a tuple of variable names and the right
hand side is a tuple of expressions.  Both tuples should have the same
length.


@subsubsection Object Creation

The creation of an object is written as @code{@var{v}:= new
@var{C}(@var{e},...)}.  @var{v} is the variable which will hold the
reference to the new object.  @var{C} is the name of the class of the
new object.  @var{e}, @dots{} are the arguments to the constructor.
Note that @var{C} has to implement an interface which is a subtype of
the interface type of @var{v}.

@subsubsection Synchronous Method Calls

A @emph{local} synchronous method call is written as
@code{@var{m}(@var{ins};@var{outs})}, where @var{m} is the name of a
method, @var{ins} is a possibly empty list of expressions describing
the actual arguments to the call and @var{outs} is a possibly empty
list of variable or attribute names used to store the result values.

A @emph{remote} synchronous method call is written as
@code{@var{e}.@var{m}(@var{ins};@var{outs})}, where @var{e} is an
object expression describing the receiver, @var{m} is the name of a
method, @var{ins} is a possibly empty list of expressions describing
the actual arguments to the call and @var{outs} is a possibly empty
list of variable or attribute names used to store the result values.


@subsubsection Asynchronous Method Calls

A @emph{asynchronous} method call is written as
@code{@var{l}!@var{e}.@var{m}(@var{ins})}, where @var{l} is the name
of a label, @var{m} is the name of a method, @var{ins} is a possibly
empty list of expressions describing the actual arguments to the call.

Results are received by the statement @code{?(@var{outs})}, where
@var{l} is a label name used for invoking the method, and @var{outs}
is a list of variable names used to store the result.


@subsubsection Blocks

Groups of statements are formed using braces, i.e., any statement or
compound statement inside braces @code{@{ ... @}} form a basic
statement.


@subsection Compound Statements

These are the operators available for combining statements in Creol.


@subsubsection Conditional Statement

The usual @code{if ... then ... else ... fi} statement.


@subsubsection Loop Statements

Loops should be avoided in Creol programs.  Creol provides to variants
of loops:

The ``for''-loop is guaranteed to terminate.  Its syntax is @code{for
@var{i} := @var{lower} to @var{upper} by @var{stride} do
@var{statement} od}.  First, the expressions denoted by @var{lower}
and @var{upper} are evaluated.  Then @var{i} assumes each value which
is greater or equal to @var{lower} until it is greater or equal to
@var{upper}.  Furthermore, the variable @var{i} is @emph{read-only} in
@var{statement}.

Essentially, a for-statement can be transformed to the following
pseudo-program using a while loop:
@verbatim
let l = lower in
  let u = upper in
    let st = stride in
      i := l;
      while i <= u do s; i := i + st done
@end verbatim

Analogously, Creol programs may contain while loops.  Use of while
loops is @emph{strongly} discouraged, because they may make
class-updates impossible.  The syntax is @code{while @var{c} do
@var{s} od}.

Both variants of loops may be annotated by a @emph{loop invariant}.
The invariant is a proof obligation which must hoold at the beginning
of a loop, the end of a loop, @emph{and} every processor release-point
within the loop body.  It is therefore advisable, that the loop
invariant restricted to instance variables is @emph{implied} by the
class invariant.

The statement @code{while true inv @var{i} do s; await wait od} is an
infinite loop which allows class updates.  The invariant @var{i}
should be implied by the class invariant, because during the release
in @code{await wait}, only the class invariant is guaranteed to hold
(and, of course, the local state of the method remains invariant).


@subsubsection Sequential Composition

Statements can be composed sequentially using the @code{;} operator.

Note that contrary to Java and C @code{;} is a @emph{binary operator}
on statements, i.e., it is not a statement terminator.


@subsubsection Non-deterministic merge

TBD


@subsubsection Non-deterministic choice

The statement @code{S1 [] S2} chooses either @code{S1} or @code{S2}
for execution.

If both statements are @emph{guarded} by an @code{await} statement,
then execution is suspended, if both await statements are not enabled.
If exactly one of the await statements is enabled, then this one will
be chosen and the process will not be suspended.  If both guards are
enabled, one of the statements is chosen non-deterministically.

Observe, that @code{S1 [] S2} is semantically equivalent to @code{S2
[] S1}.  Also, the statement @code{skip; S1 [] await b; S2} is
semantically equivalent to @code{S1} if @code{b} is false.

External choice can be implemented as
@code{await b1; S1 [] await b2; S2}
and internal choice as
@code{skip; await b1; S1 [] skip; await b2; S2}.


@subsubsection Precedence of Statement Composition

The operators @code{;}, @code{[]}, and @code{|||} are binary operators
on statements.  All of them are @emph{left-associative}, @code{;}
binds strongest and @code{|||} binds weakest.  Braces may be omitted
in @code{@{ S; T @} [] U} but not in @code{S; @{ T [] U @}}.

@subsection Interface Declarations

TBD


@subsection Class Declarations

TBD


@node Grammar
@section Creol Grammar

For reference, we summarize the grammar of Creol.  The grammar of
Creol is LR(1) and is used by the compiler.  @code{@{...@}} means a
list of symbols, where the optional decorator at the end indicates the
separator.  An optional symbol is enclosed in square brackets like
this: @code{[ ... ]}.  Terminal symbols are enclosed in quotes:
``...'' Finally, the symbol @var{id}, denoting method names,
functions, and variables, refers to an identifier, which is any string
that matches the regular expression @code{[a-z][_0-9A-Za-z]*}, and
@var{cid}, denoting class and type names, refers to any string that
matches the regular expression @code{[A-Z][_0-9A-Za-z]*}.


@subsection Reserved Keywords

The following are reserved as keywords and cannot be used for
variable or method names in programs.

@c 45678901 34567890123 56789012345 78901234567 90123456789 12345678901
@verbatim
and         await       begin       by          caller      class
contracts   do          else        end         ensures     exception
false       fi          for         history     iff         if
implements  inherits    interface   inv         in          new
nil         null        not         od          op          or
out         raise       requires    self        skip        system
then        this        to          true        try         var          
wait        while       with        xor         History     Label          
System
@end verbatim

The following symbols are used as operator symbols.  They are listed
in the order of their precedence.  Operators on any line bind stronger
than ones on the lines above.

@verbatim
and or xor iff
not
= /=
<= < > >=
|- |-| -|
+ -
* /
-
@end verbatim


@subsection Grammar

@format
unit ::=
    @{ declaration @}

declaration ::=
    class-decl
  | interface-decl
  | exception-decl

class-decl ::=
    ``class'' cid [ ``('' @{ var-decl-no-init ``,'' @} ``)'']
    [``inherits'' @{ cid [``('' @{ expr ``,'' @} ``)''] , @} ]
    [``implements'' @{ cid ``,'' @} ]
    [``contracts'' @{ cid ``,'' @} ]
    ``begin'' @{ var-decl @} @{ op-def @} @{ invariant @} @{ with-def @} ``end''
interface-decl ::=
    ``interface'' id [``inherits'' @{ id ``,'' @}]
    ``begin'' ``with'' cid @{ op-decl @} @{ invariant @} ``end''

exception.decl ::=
    ``exception'' cid [ ``('' @{ var-decl-no-init ``,'' @} ``)'' ]

var-decl-no-init ::=
    ``var'' @{ id ``,'' @} ``:'' type

var-decl ::=
    var-decl-no-init ``:='' @{ expr ``,'' @}

op-decl ::=
    ``op'' id ``('' ``in'' @{ var-decl-no-init ``,'' @} [ ``;''
    ``out'' @{ var-decl-no-init ``,'' @} ] ``)''
    [``requires'' assertion] [``ensures'' assertion]

with-def ::=
    ``with'' cid @{ op-def @} @{ invariant @} 

op-def ::=
    op-decl ``=='' @{ var-decl ``;'' @} statement

statement ::=
    choice-statement [ ``|||'' statement ]

choice-statement ::=
    seq-statement [ ``[]'' choice-statement ]

seq-statement ::=
    @{ basic-statement ``;'' @}

basic-statement ::=
    ``skip''
  | @{ id ``,'' @} ``:='' @{ expr-or-new ``,'' @}
  | ``await'' guard
  | [ id ] ``!'' expr ``.'' id ``('' @{ expr ``,'' @} ``)''
  | [ id ] ``!'' id [``@'' cid] ``('' @{ expr ``,'' @} ``)''
  | id ``?'' ``(''  @{ id ``,'' @} ``)''
  | expr ``.'' id ``('' @{ expr ``,'' @} ``;'' @{ id ``,'' @} ``)''
  | id [``@'' cid] ``('' @{ expr ``,'' @} ``;'' @{ id ``,'' @} ``)''
  | ``@{'' statement ``@}''
  | ``if'' expr ``then'' statement [``else'' statement] ``fi''
  | ``for'' id ``:='' expression ``to'' expression
      [ ``by'' expression ] [ ``inv'' assertion ] ``do'' statement ``od''
  | ``while'' expression [ ``inv'' assertion ] ``do'' statement ``od''
  | ``raise'' cid [ ``('' @{ expr ``,'' @} ``)'' ]
  | ``try'' statement catchers ``end''

catchers ::=
    @{ ``with'' cid [ ``(`` @{ id ``,'' @} ``)'' ] ``do'' statement @}
    [ ``else'' statement ]

expr-or-new ::=
    ``new'' cid ``('' @{ expr ``,'' @} ``)''
  | expr

expr ::=
    integer | float | string | ``true'' | ``false'' | ``nil'' |
    ``null''
  | id | ``not'' expr | ``-'' expr | expr binop expr
  | id ``('' @{ expr ``,'' @} ``)''
  | ``(`` expr ``)''

binop ::= ``+'' | ``-'' | ``*'' | ``/'' | ``='' | ``<'' | ``>'' |
          ``<='' | ``>='' | ``and'' | ``or'' 

assertion ::=
    expr
  | ``forall'' var-decl-no-init ``:'' assertion
  | ``exists'' var-decl-no-init ``:'' assertion
@end format
