@node Creol
@chapter Creol

This chapter describes the concrete syntax of Creol.  It also gives an
informal semantics.

This chapter is not yet finished.  Some constructs described in this
chapter need not be implemented by the compiler or the Maude
semantics, yet.


@menu
* Comments::                    Comments in Creol.
* Types::                       Type specifications.
* Literals and Expression::     The functional sub-language.
* Statements::                  The object-oriented sub-language.
* Variable Declaration::        Declaring variables and attributes.
* Method Declaration::          Declaring and defining behavior.
* Interface Declaration::       Types for objects.
* Class Declaration::           Implementation for types.
* Datatype Declaration::        Declaring data types.
* Exception Declaration::       Declaring exceptions.
* Grammar::                     Creol grammar in EBNF.
* Parse Errors::                A note on parse errors.
@end menu


@node Comments
@section Comments

Creol supports too kinds of comments, both have been inspired by C++
and Java.

The first kind begins with @code{//} and extends until the first
following line-break.

The second kind starts with @code{/*} and extends until the first
following @code{*/}.  Comments of this kind do not nest.


@node Types
@section Types

All expressions in Creol are typed.  All variables and attributes must
declare a type.  A type is either a data type, where the types
@code{Int}, @code{Bool}, and @code{String} are pre-defined, a type
variable, written as @code{`@var{a}}, or a type expression.  Type
expressions can be applications, e.g., the type of a list of integers is
denoted by @code{List[Int]}, or the type of a tuple, written as @code{[
@{ @var{type} , @} ]}, e.g., @code{[Int, Int]} for a pair of integers.


@node Literals and Expression
@section Literals and Expressions

Creol assumes a functional sub-language, which we describe in this
section.  The equality symbol


@subsection Literals

The boolean literals of Creol are @code{true} and @code{false}.

The integer literals match the regular expression @code{[0-9]+}.

Floating-point literals match the regular expression
@code{(0|([1-9][0-9]+)).[0-9]*([eE]-?[1-9][0-9]+)?}.

A string literal is a sequence of characters enclosed in quotes:
@code{"}.  The usual escape sequences using backslash, e.g.,
@code{\n}, @code{\"}, @code{\\}, are supported.

The empty list is represented by the literal @code{nil}.

The null-reference is represented by the literal @code{null}.

The self-reference is represented by the keyword @code{this}.

In method bodies, the identity of the caller is represented by the
keyword @code{caller}.


@subsection Variables

Variables are lower-case character-sequences, matching the regular
expression @code{[a-z][a-zA-Z0-9]}.  Variables are typed (see below).


@subsection Boolean Expressions

The boolean expressions are:

@code{@var{expression} = @var{expression}} for equality.

@code{@var{expression} /= @var{expression}} for in-equality.

@code{~ @var{expression}} for negation.

@code{@var{expression} && @var{expression}} for conjunction.

@code{@var{expression} || @var{expression}} for disjunction.

@code{@var{expression} => @var{expression}} for implication.

@code{@var{expression} <=> @var{expression}} for bi-implication.

@code{@var{expression} ^ @var{expression}} for exclusive or.


@subsection Integers, Reals, and Arithmetic Expressions

The arithmetic expressions are:

@code{- @var{expression}} for negation.

@code{@var{expression} ** @var{expression}} for exponentiation.

@code{@var{expression} * @var{expression}} for multiplication.

@code{@var{expression} / @var{expression}} for division.

@code{@var{expression} % @var{expression}} for modulo.

@code{@var{expression} + @var{expression}} for addition.

@code{@var{expression} - @var{expression}} for subtraction.


@subsection Strings

The operations on strings are the same as the ones on sequences.
Single-letter strings are considered to be characters.


@subsection Tuples

The operations on tuples are

@code{( @var{expression} , )} for tuple construction.


@subsection Sequences

The operations on sequences are:

@code{@var{expression} |- @var{expression}} for appending to the right.

@code{@var{expression} -| @var{expression}} for appending to the left.

@code{@var{expression} |-| @var{expression}} for concatenation.

@code{@var{expression} \ @var{expression}} for projection.

Sequences can be constructed by enumerating their elements in order:
@code{[ @{ @var{expression} , @} ]}.


@subsection Sets

The operations on sets are:

@code{@var{expression} \ @var{expression}} for set-difference.

@code{@var{expression} || @var{expression}} for union.

@code{@var{expression} && @var{expression}} for intersection.

@code{@var{expression} in @var{expression}} for testing membership.

@code{@{ @var{id} : @var{expression} | @var{expression} @}}
for set aggregation:

@code{@{ @}} represents the empty set.  Generally, sets can be
constructed by enumerating the elements: @code{@{ @{ @var{expression}
, @} @}}.



@subsection Object Expressions and Literals

Object expressions and literals are expressions whose value is a
reference to an object.  The only literal is @code{null}, representing
the null-pointer.

The keyword @code{this} represents the self-reference and is an
expression.

The keyword @code{caller} represents the identity of the caller within
a method body.  The type of @code{caller} is the method's
co-interface.

The expression @code{@var{expression} as @var{type}} represents
re-typing of the value of @var{expression} to the type (interface)
@var{type}.  If the value of @var{expression} cannot be determined
statically, type conformance is tested during runtime.


@subsection Function Application

Generally, applying a function is written as
@code{@var{f}(@var{e},@var{d},...,@var{c})}, where @var{f} is the name
of a function and @var{e},@var{d},@dots{} refers to expressions
representing the actual arguments.


@node Statements
@section Statements

In this section we describe the statements of Creol programs.


@subsection Assignments

A single assignment may be written as @code{@var{x} := @var{e}}, where
@var{x} is the name of an attribute or a local variable and @var{e}
is an expression.

A multiple assignment is written as
@code{@var{x},@var{y},...,@var{z} := @var{e},@var{f},...,@var{g}},
where the left hand side is a tuple of variable names and the right
hand side is a tuple of expressions.  Both tuples should have the same
length.


@subsection Object Creation

The creation of an object is written as @code{@var{v}:= new
@var{C}(@var{e},...)}.  @var{v} is the variable which will hold the
reference to the new object.  @var{C} is the name of the class of the
new object.  @var{e}, @dots{} are the arguments to the constructor.
Note that @var{C} has to implement an interface which is a subtype of
the interface type of @var{v}.

@subsection Synchronous Method Calls

A @emph{local} synchronous method call is written as
@code{@var{m}[@@@var{C}](@var{ins};@var{outs})}, where @var{m} is the
name of a method, @var{C} is an optional class name, @var{ins} is a
possibly empty list of expressions describing the actual arguments to
the call and @var{outs} is a possibly empty list of variable or
attribute names used to store the result values.

A @emph{remote} synchronous method call is written as
@code{@var{e}.@var{m}(@var{ins};@var{outs})}, where @var{e} is an
object expression describing the receiver, @var{m} is the name of a
method, @var{ins} is a possibly empty list of expressions describing
the actual arguments to the call and @var{outs} is a possibly empty
list of variable or attribute names used to store the result values.


@subsection Asynchronous Method Calls

A @emph{asynchronous} method call is written as
@code{@var{l}!@var{e}.@var{m}(@var{ins})}, where @var{l} is the name
of a label, @var{m} is the name of a method, @var{ins} is a possibly
empty list of expressions describing the actual arguments to the call.

Results are received by the statement @code{@var{l}?(@var{outs})},
where @var{l} is a label name used for invoking the method, and
@var{outs} is a list of variable names used to store the result.

Observe that labels @emph{must} be declared.  @xref{Variable Declaration}.
The type of a label is given by @code{Label[ @{ @var{type} , @} ]}.  For
methods that do not return any value, the type of its label is
@code{Label[ ]}, where the space between @code{[} and @code{]} is
@emph{mandatory} (recall, that @code{[]} is composing statements and
@code{var x: Label} may be parsed as a statement).

It is not possible to define labels for any output arity.
@code{var x: Label[Data]} expresses that x is a label for methods
with @emph{exactly one output parameter}, regardless of its type, just as
@code{var x: Label[Data, Data]} expresses, that the method should have
two output parameters.


@subsection Blocks

Groups of statements are formed using braces, i.e., any statement or
compound statement inside braces @code{begin ... end} form a basic
statement.


@subsection Conditional Statement

The usual @code{if ... then ... else ... end} statement.


@subsection Loop Statements

THE INFORMATION IN THIS SECTION IS SUBJECT TO CHANGE.

Creol supports a while loop, which uses the syntax @code{while @var{c}
[ inv @code{i} ] do @var{s} end}.  As usual, @code{@var{c}} is the
condition and @code{@var{s}} is the statement to execute.

A loop may be annotated by a @emph{loop invariant}, as indicated by
the optional @code{inv @code{i}} part.  The invariant is a proof
obligation which must hold at the beginning of a loop, the end of a
loop, @emph{and} every processor release-point within the loop body.
It is therefore advisable, that the loop invariant restricted to
instance variables is @emph{implied} by the class invariant.

Finally, we advice that each loop used in a program is
@emph{terminating}.  Infinite loops may prohibit class updates and
cause other undesired behaviours.


@subsection Sequential Composition

Statements can be composed sequentially using the @code{;} operator.

Note that contrary to Java and C @code{;} is a @emph{binary operator}
on statements, i.e., it is not a statement terminator.


@subsection Non-deterministic merge

TBD

The non-deterministic merge statement should best be avoided, since it
may cause an exponential increase of the state space to be analysed.
It sometimes triggers exponential space requirements in the compiler.
If the compiler or the interpreter run out of memory, try to replace
non-deterministic merge statements by a sequential composition of
those statements@footnote{Maybe the compiler will be able to perform
such transformations automatically.  This may be an instance of
partial order reduction.}.


@subsection Non-deterministic choice

The statement @code{S1 [] S2} chooses either @code{S1} or @code{S2}
for execution.

If both statements are @emph{guarded} by an @code{await} statement,
then execution is suspended, if both await statements are not enabled.
If exactly one of the await statements is enabled, then this one will
be chosen and the process will not be suspended.  If both guards are
enabled, one of the statements is chosen non-deterministically.

Observe, that @code{S1 [] S2} is semantically equivalent to @code{S2
[] S1}.  Also, the statement @code{skip; S1 [] await b; S2} is
semantically equivalent to @code{S1} if @code{b} is false.

External choice can be implemented as
@code{await b1; S1 [] await b2; S2}
and internal choice as
@code{skip; await b1; S1 [] skip; await b2; S2}.


@subsection Precedence of Statement Composition

The operators @code{;}, @code{[]}, and @code{|||} are binary operators
on statements.  All of them are @emph{left-associative}, @code{;}
binds strongest and @code{|||} binds weakest.  Braces may be omitted
in @code{@{ S; T @} [] U} but not in @code{S; @{ T [] U @}}.


@node Variable Declaration
@section Variable Declaration

All variables and attributes in Creol must be declared.  A variable is
declared using the syntax
@code{var @var{name}: @var{type} [ := @var{init}]}.

The identifier @var{name} is the name of the variable, @var{type} is
the type of the variable and @var{init} is an expression used to
initialize the variable.


@node Method Declaration
@section Method Declaration

An operation definition has the form @code{op @var{name} (in
@var{ins}; out @var{outs}) requires @var{precondition} ensures
@var{postcondition} == @var{variables} @var{statement}}.  @var{ins} is
a list of variable declarations describing the @emph{input}
parameters.  @var{outs} is a list of variables describing the output
parameters.  In principle, one should only read from input parameters
and only write to output parameters.

The precondition and postcondition are optional and their meaning can
be easily defined using invariants.

The body of a method consists of local variable definitions followed
by a statement.


@node Interface Declaration
@section Interface Declarations

All objects in Creol are typed by interface.

Each class is assumed to implement the empty interface @code{Any}.
This interface is the implicit super-interface of all other interfaces.

An interface may inherit from other interfaces, making an instance of
this interface also an instance of all super-interfaces.

An interface has a unique name.  It declares a @emph{co-interface},
which expresses mutual dependencies and constrains the users of this
interface:  Each caller of a method specified in an interface
@emph{must} implement its co-interface.

An interface specifies the signature of a sequence of methods.

@example
interface @var{I} [ inherits @var{@{ cid @}} ]
begin
  [ with @var{I'}
    @var{@{ method-decl @}}
    @var{@{ invariants @}} ]
end
@end example

@subsection Open Issues

With respect to interface declarations, the following ideas may be
considered:
@itemize @bullet
@item
May be we want to allow more than one co-interface declaration in an
interface?  Currently, an interface with two co-interface declarations
has to be constructed by inheriting the block with one interface.  On
the other hand, one might feel that both blocks form a unit and should
not be used separately.

@item
One might be tempted to introduce type-parameterized interfaces or
value-parameterized interfaces.  But a concrete use case is needed,
first.

@item
Why do we use @code{inherits} if the semantics of sub-interfacing is
much closer to @code{contracts}, or is it not?
@end itemize


@node Class Declaration
@section Class Declarations

A class provides the implementation of an object and defines
implementations to interfaces.

@menu
* Class Parameters::    Parameters given to classes.
* Inherits::            Inheriting code from other classes.
* Implements::          Implementing interfaces.
* Contracts::           Contracting interfaces.
* Class Attributes::    Attributes of classes.
* Class Methods::       Methods of classes.
* Class Invariants::    Class invariants.
@end menu


@node Class Parameters
@subsection Class Parameters

A class declaration specifies the name of the class, which must
start with an upper-case letter, and optionally a list of @emph{class
parameters}.  These parameters are like read-only attributes of the
class and provide the signature of the @emph{only} constructor.


@node Inherits
@subsection Inheritance

A class can inherit from a list of super-classes, which are defined in
an @code{inherits} specification.


@node Implements
@subsection Implementing Interfaces

For a class to be able to call other methods and to be called by other
objects it must define the interfaces it implements.  Creol knows
about two distinct ways to implement classes.  The first and weaker
version is by declaring the interfaces using the @code{implements}
keyword.  A class claiming to implement an interface must implement
all methods specified in this interface.  Since interfaces also
specify behavior for methods, the method implementation must
implement the specified behaviour.@footnote{Whether a class implements
an interface cannot be determined statically, therefore the compiler
does not check this}.  Unlike in the Java Programming Language, the
information on implementing interfaces is @emph{not} inherited by
other classes.  This supports code reuse without affecting reasoning
control.


@node Contracts
@subsection Contracting Interfaces

Additionally, a class can @emph{contract} an interface using the
@code{contracts} keyword instead of @code{implements}.  The
differences between implements and contracts are subtle.  Contracts
imposes all obligations on a class that are imposed on the class using
the @code{implements} keyword.  It will place one additional
obligation on the system: All future subclasses of this class are also
contracting (and therefore implementing) that interface.  The
@code{contracts} keyword behaves like the corresponding implements
keyword in the Java Programming Language.

An interface @code{I} needs to be contracted, if the class uses that
interface to satisfy a co-interface requirement.  This means, that a
method in a class is calling a method, which requires @code{I} as a
co-interface.  This requirement is imposed, because a method can call
the caller of a method using the co-interface.  If a class calls a
method of an object it may only do so if it satisfies the co-interface
requirement.  Because that method may be inherited, the class must
contract the interface to keep the method type safe for all
sub-classes.  Consider the following example:

@example
interface Foo begin with Bar op foo end

interface Bar begin with Any op bar end

interface Baz begin with Any op bar end

class Foo implements Foo
begin
  with Bar op foo == caller.bar
end

class Bar implements Bar
begin
  var foo: Foo
  op init == foo := new Foo
  with Any op bar == foo.foo
end

class Baz implements Baz inherits Bar
begin
end

class Main
begin
  var baz: Baz
  op init == baz := new Baz
  op run == baz.bar
end
@end example

This example is @emph{not} type-safe, more specifically, the call
@code{caller.bar} is not well-typed.  The trace which violates the
well-typedness rules of Creol is the following one:
@enumerate
@item
Create an instance of @code{Main}, which will create one instance of
@code{Baz} during the initialization.  In the run method, we can the
@code{bar} method of @code{baz}.  This call is well-typed, since all
instances of @code{Baz} implement the @code{Baz} interface which
exports this method to all objects.

@item
In the @code{bar} method, which the class @code{Baz} inherits from
@code{Bar}, we call the method @code{foo} of @code{Bar}'s @code{foo}
object.

@item
In the @code{foo} method, we call the @code{bar} method of the
@code{caller}.  In this method, the caller is believed to be an
instance of a class implementing the @code{Bar} interface.  But the
caller is really an instance of class @code{Baz}, which does not
implement the @code{Bar} interface, causing a run-time type error.
@end enumerate

What went wrong?  Observe, that the code of the method @code{bar} in
class @code{Bar} is well-typed for classes implementing the interface
@code{Bar}.  This interface is a co-interface requirement of the
method @code{foo} in class @code{Foo}.  But the use of
@code{implements} does @emph{not} imply that future sub-classes of
@code{Bar} have the type @code{Bar} as well.  The way to correct this
error is to @code{contract Bar} in the definition of class @code{Bar}.
This will ensure, that @code{Bar} is also the type of all sub-classes
of @code{Bar}, among others @code{Baz}.



@node Class Attributes
@subsection Class Attributes

A class may specify a list of attributes or class variables.  These
attributes store the persistent state of an object.  An attribute
declaration has the form @code{op @var{name}: @var{type}} and may also
be initialized in that statement, i.e., @code{op @var{name}:
@var{type} := @var{expression}}.

The expression may be any constant expression or it may refer to the
parameters of the current class, the super classes, and the super
classes attributes, but not to the attributes of the current class.

The programmer may not assume any order in which these initializations
are evaluated.  If such an order is necessary, then the initialization
has to be done in the init method.  However, the direct initialization
of class parameters is executed before the body of the init method is
executed.


@node Class Methods
@subsection Methods

A class may then specify a list of private methods.

A class may specify a list of public methods by using a @emph{with
definition}.  A with definition has the format @code{with
@var{interface} @var{operations} @var{invariants}}, where
@code{with @var{interface}} specifies the co-interface.

@node Class Invariants
@subsection Class Invariants

TBD


@node Datatype Declaration
@section Datatype Declarations

TBD


@node Exception Declaration
@section Exception Declarations

Exception have to be declared for type checking.  A declaration has
the form
@example
exception @var{E} [ ( @var{@{ var-decl-no-init @}} ) ]
@end example

This allows a programmer to supply additional information to an
exception.

@itemize @bullet
@item
Actually, only a sequence of types should be sufficient, or we may use
these names as record names.
@end itemize



@node Grammar
@section Creol Grammar

For reference, we summarize the grammar of Creol.  The grammar of
Creol is LR(1) and is used by the compiler.  @code{@{...@}} means a
list of symbols, where the optional decorator at the end indicates the
separator.  An optional symbol is enclosed in square brackets like
this: @code{[ ... ]}.  Terminal symbols are printed like this:
@strong{terminal}.  Finally, the symbol @var{id}, denoting method
names, functions, and variables, refers to an identifier, which is any
string that matches the regular expression @code{[_a-z][_'0-9A-Za-z]*},
and @var{cid}, denoting class and type names, refers to any string
that matches the regular expression @code{[A-Z][_0-9A-Za-z]*}.


@subsection Reserved Keywords

The following are reserved as keywords and cannot be used for
variable or method names in programs.

@c 45678901 34567890123 56789012345 78901234567 90123456789 12345678901
@example
assert      await       begin       by          caller      case
class       contracts   ctor        datatype    do          else
end         ensures     exception   exists      false       for
forall      fun         history     if          implements  inherits
interface   inv         in          new         nil         not
now         null        of          op          out         posit
prove       raise       requires    skip        some        then
this        to          true        try         var         when
with
@end example

The following symbols are used as operator symbols.  They are listed
in the order of their precedence.  Operators on any line bind stronger
than ones on the lines above.

@example
,                               @r{left}
|                               @r{left}
in                              @r{left}
as                              @r{left}
<=>                             @r{left}
=>                              @r{left}
^                               @r{left}
|| \/                           @r{left}
&& /\                           @r{left}
~                               @r{right, unary operator}
= /=                            @r{non-associative}
<= < > >=                       @r{non-associative}
\                               @r{left}
|-|                             @r{left}
-|                              @r{right}
|-                              @r{left}
+ -                             @r{left}
* / %                           @r{left}
**                              @r{left}
- #                             @r{right, unary operators}
@end example


@subsection Grammar

@format
main ::=
    @{ declaration @}

declaration ::=
    class-decl
  | interface-decl
  | datatype-decl
  | exception-decl

class-decl ::=
    @code{class} cid [ @code{(} @{ var-decl-no-init @code{,} @} @code{)}]
    @{ (@code{contracts} | @code{implements} | @code{inherits} )
	@{ cid [@code{(} @{ expr @code{,} @} @code{)}] , @} @}
    @code{begin} @{ @code{var} var-decl @}
    [ internal-with-def ] @{ with-def @}
    @code{end}

interface-decl ::=
    @code{interface} id @{ @code{inherits} @{ id @code{,} @} @}
    @code{begin} @code{with} cid @{ op-decl @} @{ invariant @} @code{end}

datatype-decl ::=
    @code{datatype} cid [ @code{by} @{ cid @code{,} @} ] @code{begin}
    @{ constructor @} @{ function @} @{ invariant @} @code{end}

exception-decl ::=
    @code{exception} cid [ @code{(} @{ var-decl-no-init @code{,} @} @code{)} ]

var-decl-no-init ::=
    @{ id @code{,} @} @code{:} type

var-decl ::=
    var-decl-no-init @code{:=} @{ expr @code{,} @}

op-decl ::=
    @code{op} id @code{(} [ @code{in} @{ var-decl-no-init @code{,} @} ]
    [ @code{;} @code{out} @{ var-decl-no-init @code{,} @} ] @code{)}  
    [@code{requires} assertion] [@code{ensures} assertion]

anon-with-def ::=
    @{ op-def @} @{ invariant @}

with-def ::=
    @code{with} cid @{ op-def @} @{ invariant @}

op-def ::=
    op-decl @code{==} @{ @code{var} var-decl @code{;} @} statement

function ::=
    @code{op} id @code{(} @{ var-decl-no-init @code{,} @} @code{)} @code{:} type @code{==} ( expression | @code{extern} string )

statement ::=
    choice-statement [ @code{|||} statement ]

choice-statement ::=
    seq-statement [ @code{[]} choice-statement ]

seq-statement ::=
    basic-statement [ @code{;} seq-statement ]

basic-statement ::=
    @code{skip}
  | @{ lhs @code{,} @} @code{:=} @{ expr-or-new @code{,} @}
  | @code{release}
  | @code{await} expr
  | [ id ] @code{!} expr @code{.} id @code{(} @{ expr @code{,} @} @code{)} [ @code{as} type ]
  | [ id ] @code{!} id [ @code{<:} cid ] [ @code{:>} cid ] @code{(} @{ expr @code{,} @} @code{)} [ @code{as} type ]
  | id @code{?} @code{(}  @{ lhs @code{,} @} @code{)}
  | [ @code{await} ] expr @code{.} id @code{(} @{ expr @code{,} @} @code{;} @{ lhs @code{,} @} @code{)} [ @code{as} type ]
  | [ @code{await} ] id [@code{<:} cid] [ @code{:>} cid ] @code{(} @{ expr @code{,} @} @code{;} @{ lhs @code{,} @} @code{)} [ @code{as} type ]
  | @code{begin} statement @code{end}
  | @code{if} expr @code{then} statement [@code{else} statement] @code{end}
  | @code{while} expr [ @code{inv} expr ] @code{do} statement @code{end}
  | @code{assert} assertion

expr-or-new ::=
    @code{new} cid @code{(} @{ expr @code{,} @} @code{)}
  | expr

expr ::=
    @code{true} | @code{false} | integer | float | string | @code{nil} | @code{null} | id [ (@code{?} | @code{@@} type) ]
  | @code{(} @{ expr @code{,} @} @code{)}
  | @code{[} @{ expr @code{,} @} @code{]}
  | @code{@{} @{ expr @code{,} @} @code{@}}
  | @code{@{} id @code{:} expr @code{|} expr @code{@}}
  | unaryop expr | expr binop expr | id @code{(} @{ expr @code{,} @} @code{)}
  | @code{if} expr @code{then} expr @code{else} expr @code{end}

unaryop ::= @code{~} | @code{-} | @code{#}

binop ::=
    @code{+} | @code{-} | @code{*} | @code{/} | @code{=} | @code{<} | @code{>} |
    @code{<=} | @code{>=} | @code{&&} | @code{/\} | @code{||} | @code{\/} | @code{|-} |
    @code{|-|} | @code{-|} | @code{\}

type ::=
    cid [ @code{[} @{ type , @} @code{]} ]
  | @code{[} @{ type , @} @code{]}
  | @code{`} id
@end format


@node Parse Errors
@section A Note on Parse Errors

Some errors are quite hard to identify by the parser and a parser
implementing the grammar given above can not identify all causes
of the parse error directly.  In this section we document the most
important misreported parse errors.

@subsection Missind @code{end}

Consider the following class:
@example
class A
  op init == if true then skip
end
@end example

The indentiation of this code snippet suggest that the programmer has
omitted the end of the @code{if} statement.  The parser has a different
view, since it is insensitive to indentiation.  It will use the
@code{end} on the following line to build an @code{if} statement.  It
will then look for a composition operator for continuing to parse a
method body, or for an @code{op} or @code{end} to finish parsing the
method body.  But now the parser encounters @emph{the end of the file}.
It will then report an error for the definition of the method body.


@c  LocalWords:  Creol Datatype
