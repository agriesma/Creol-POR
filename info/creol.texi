@node Creol
@chapter Creol

CREOL: An exciting mix of the best ingredients from many cultures!


CREOL: A formal framework for reflective component modelling

 The CREOL project is an ongoing research project 2004 - 2008, funded
by the Research Council of Norway through the strategic programme
IKT-2010. The goal of the project is to develop a formal framework and
tool for reasoning about dynamic and reflective modifications in
object-oriented open distributed systems, ensuring reliability and
correctness of the overall system.

@menu
* Overview::    A short overview to Creol and its ideas.
* Features::    What Creol provides and why it is different.
* Syntax::      A short guide to the language.
* Grammar::     Creol grammar in EBNF.
@end menu


@node Overview 
@section Short project overview

Open distributed systems consist of geographically spread system
components subject to run-time modifications. These systems are
becoming increasingly important in modern society, for instance for
safety-critical infrastructure. A major challenge for safety-critical
open distributed systems is to ensure the reliability and correctness
of the overall system when components are dynamically modified, so
that development, maintenance, and upgrade of system components happen
in a controlled manner.

The CREOL project is a research project to investigate programming
constructs and reasoning control in the context of open distributed
systems, and in particular the issue of maintenance control, taking an
object-oriented approach. The project focuses on support for component
adaptability, combined with a platform for executable specification
and analysis of system models. This allows an investigation at two
levels: a theoretical framework for reasoning about software and
software updates, and a tool for practical experimentation with the
consequences and possibilities of the theoretical choices. The goal of
the project is to develop a formal framework and tool for reasoning
about dynamic and reflective modifications in open distributed
systems, ensuring reliability and correctness of the overall system.

These issues will be investigated in the context of Creol, an
experimental high-level object-oriented language for distributed
objects. The name is an acronym for Concurrent Reflective
Object-oriented Language. The language is based on concurrent objects
communicating by means of asynchronous method calls, and is formally
defined with an operational semantics expressed in rewriting
logic. The basic communication mechanisms and operational semantics of
the language are described in [9, 2]. The inclusion of multiple
inheritance in the language and the operational semantics is described
in [7]. A type and effect system for the language is given in [1].

Specifications in rewriting logic are executable in the rewriting
logic tool Maude. A prototype Maude interpreter for the communication
basis of the Creol language has been developed and extended with a
pseudo-deterministic rewrite strategy in order to better simulate the
non-determinism of a distributed environment [11].

The language and the interpreter will gradually be extended to
incorporate facilities for reflective programming, dynamic updates,
and a coordination language based on viewpoint specifications (or
behavioral interfaces) [12, 17]. An extension of the language and the
interpreter with a dynamic class construct is presented in [5]. A
binding strategy for method calls which is adapted to dynamic class
extensions is presented in [4]. A type system for runtime class
updates is presented in [3].


@node Features
@section Features

Creol is a @emph{strongly typed} language, in the sense that it is
type safe.  Function and method calls which disregard data types
are rejected.

Creol is a @emph{statically typed} language.  The compiler tries to
infer, whether a function call or a method call is safe in the sense
that it will succeed.  Programs in which a call cannot succeed because
of the type of an operation or a method are rejected.

Message dispatch in Creol is based not only on the type of the receiver
of the message, but also on the arguments (multiple dispatch @cite{XXX}),
especially the type of the caller (which is constrained by the
@emph{co-interface} and available in any method body under the name
@code{caller}.

The @code{caller} mechanism is similar to @code{context} in Smalltalk-80,
but it does not, e.g., provide information on the call-chain.




@node Syntax
@section Syntax of Creol

In this section we describe the syntax of Creol and sketch the
informal semantics of Creol programs.

@menu
* Literals and Expression::     The functional sub-language.
* Statements::                  The object-oriented sub-language.
* Interface Declaration::       Types for objects.
* Class Declaration::           Implementation for types.
* Datatype Declaration::
* Exception Declaration::
@end menu

@node Literals and Expression
@subsection Literals and Expressions

Creol assumes a functional sub-language, which we describe in this
section.

@subsubsection Boolean Expressions

TBD

@subsubsection Integers, Reals, and Arithmetic Expressions

TBD

@subsubsection Strings

TBD


@subsubsection Object Expressions and Literals

Object expressions and literals are expressions whose value is a
reference to an object.  The only literal is @code{null}, representing
the null-pointer.


@subsubsection Function Application

Generally, applying a function is written as
@code{@var{f}[@var{e},@var{d},...,@var{c}]}, where @var{f} is the name
of a function and @var{e},@var{d},@dots{} refers to expressions
representing the actual arguments.


@subsubsection Field Access

While the fields of objects are considered to be private to the
object, the functional sub-language generates automatic projections
for structures.

Structures may arise, e.g., from data type definitions (see below).

@example
datatype Note
begin
  var file: String
  var line: Integer
end
@end example

In this example, an exception e is of type @code{ParseError}, which is
a structure with the two fields @code{file} and @code{line}.  If
Â·@code{n} is a variable of type @code{Note}, then @code{n`file} is the
value of the file component.

@itemize @bullet
@item
Field access expressions should only be valid within the data type
module?  Otherwise we do not adhere to the principles of encapsulation
for abstract data types.
@end itemize


@node Statements
@subsection Statements

In this section we describe the statements of Creol programs.


@subsubsection Assignments

A single assignment may be written as @code{@var{x} := @var{e}}, where
@var{x} is the name of an attribute or a local variable and @var{e}
is an expression.

A multiple assingment is written as
@code{@var{x},@var{y},...,@var{z} := @var{e},@var{f},...,@var{g}},
where the left hand side is a tuple of variable names and the right
hand side is a tuple of expressions.  Both tuples should have the same
length.


@subsubsection Object Creation

The creation of an object is written as @code{@var{v}:= new
@var{C}(@var{e},...)}.  @var{v} is the variable which will hold the
reference to the new object.  @var{C} is the name of the class of the
new object.  @var{e}, @dots{} are the arguments to the constructor.
Note that @var{C} has to implement an interface which is a subtype of
the interface type of @var{v}.

@subsubsection Synchronous Method Calls

A @emph{local} synchronous method call is written as
@code{@var{m}(@var{ins};@var{outs})}, where @var{m} is the name of a
method, @var{ins} is a possibly empty list of expressions describing
the actual arguments to the call and @var{outs} is a possibly empty
list of variable or attribute names used to store the result values.

A @emph{remote} synchronous method call is written as
@code{@var{e}.@var{m}(@var{ins};@var{outs})}, where @var{e} is an
object expression describing the receiver, @var{m} is the name of a
method, @var{ins} is a possibly empty list of expressions describing
the actual arguments to the call and @var{outs} is a possibly empty
list of variable or attribute names used to store the result values.


@subsubsection Asynchronous Method Calls

A @emph{asynchronous} method call is written as
@code{@var{l}!@var{e}.@var{m}(@var{ins})}, where @var{l} is the name
of a label, @var{m} is the name of a method, @var{ins} is a possibly
empty list of expressions describing the actual arguments to the call.

Results are received by the statement @code{?(@var{outs})}, where
@var{l} is a label name used for invoking the method, and @var{outs}
is a list of variable names used to store the result.


@subsubsection Blocks

Groups of statements are formed using braces, i.e., any statement or
compound statement inside braces @code{@{ ... @}} form a basic
statement.


@subsubsection Conditional Statement

The usual @code{if ... then ... else ... fi} statement.


@subsubsection Loop Statements

Loops should be avoided in Creol programs.  Creol provides to variants
of loops:

The @code{for}-loop is guaranteed to terminate.  Its syntax is @code{for
@var{i} := @var{lower} to @var{upper} by @var{stride} do
@var{statement} od}.  First, the expressions denoted by @var{lower}
and @var{upper} are evaluated.  Then @var{i} assumes each value which
is greater or equal to @var{lower} until it is greater or equal to
@var{upper}.  Furthermore, the variable @var{i} is @emph{read-only} in
@var{statement}.

Essentially, a for-statement can be transformed to the following
pseudo-program using a while loop:
@example
let l = lower in
  let u = upper in
    let st = stride in
      i := l;
      while i <= u do s; i := i + st done
@end example

Analogously, Creol programs may contain while loops.  Use of while
loops is @emph{strongly} discouraged, because they may make
class-updates impossible.  The syntax is @code{while @var{c} do
@var{s} od}.

Both variants of loops may be annotated by a @emph{loop invariant}.
The invariant is a proof obligation which must hoold at the beginning
of a loop, the end of a loop, @emph{and} every processor release-point
within the loop body.  It is therefore advisable, that the loop
invariant restricted to instance variables is @emph{implied} by the
class invariant.

The statement @code{while true inv @var{i} do s; await wait od} is an
infinite loop which allows class updates.  The invariant @var{i}
should be implied by the class invariant, because during the release
in @code{await wait}, only the class invariant is guaranteed to hold
(and, of course, the local state of the method remains invariant).


@subsubsection Sequential Composition

Statements can be composed sequentially using the @code{;} operator.

Note that contrary to Java and C @code{;} is a @emph{binary operator}
on statements, i.e., it is not a statement terminator.


@subsubsection Non-deterministic merge

TBD


@subsubsection Non-deterministic choice

The statement @code{S1 [] S2} chooses either @code{S1} or @code{S2}
for execution.

If both statements are @emph{guarded} by an @code{await} statement,
then execution is suspended, if both await statements are not enabled.
If exactly one of the await statements is enabled, then this one will
be chosen and the process will not be suspended.  If both guards are
enabled, one of the statements is chosen non-deterministically.

Observe, that @code{S1 [] S2} is semantically equivalent to @code{S2
[] S1}.  Also, the statement @code{skip; S1 [] await b; S2} is
semantically equivalent to @code{S1} if @code{b} is false.

External choice can be implemented as
@code{await b1; S1 [] await b2; S2}
and internal choice as
@code{skip; await b1; S1 [] skip; await b2; S2}.


@subsubsection Precedence of Statement Composition

The operators @code{;}, @code{[]}, and @code{|||} are binary operators
on statements.  All of them are @emph{left-associative}, @code{;}
binds strongest and @code{|||} binds weakest.  Braces may be omitted
in @code{@{ S; T @} [] U} but not in @code{S; @{ T [] U @}}.


@node Interface Declaration
@subsection Interface Declarations

All objects in Creol are typed by interface.

Each class is assumed to implement the empty interface @code{Any}.
This interface is the implicit superinterface of all other interfaces.

An interace may inherit from other interfaces, making an instance of
this interface also an instance of all super-interfaces.

An interface has a unique name.  It declares a @emph{co-interface},
which expresses mutual dependencies and constrains the users of this
interface:  Each caller of a method specified in an interface
@emph{must} implement its co-interface.

An interface specifies the signature of a sequence of methods.

@example
interface @var{I} [ inherits @var{@{ cid @}} ]
begin
  [ with @var{I'}
    @var{@{ method-decl @}}
    @var{@{ invariants @}} ]
end
@end example

@subsubsection Open Issues

With respect to interface declarations, the following ideas may be
considered:
@itemize @bullet
@item
May be we want to allow more than one co-interface declaration in an
interface?  Currently, an interface with two co-interface declarations
has to be constructed by inheriting the block with one interface.  On
the other hand, one might feel that both blocks form a unit and should
not be used separately.

@item
One might be tempted to introduce type-parameterised interfaces or
value-parameterised interfaces.  But a concrete use case is needed,
first.

@item
Why do we use @code{inherits} if the semantics of sub-interfacing is
much closer to @code{contracts}, or is it not?
@end itemize


@node Class Declaration
@subsection Class Declarations

A class provides the implementation of an object.

A class declaration specifies the name of the class, which must start
with an upper-case letter, and optionally a list of @emph{class
parameters}.  These parameters are like read-only attributes of the
class and provide the signature of the @emph{only} constructor.

A class can inherit from a list of super-classes, which are defined in
an @code{inherits} specification.

A class can declare to @emph{implement} a set of interfaces.  These
interfaces are @emph{not} inherited.

A class can declare to @emph{contract} a set of interfaces.  This
clause is similar to an @code{implements} clause, but in addition it
requires each @emph{sub-class} to implement these interfaces, too.

If an object calls methods of itself, which are specified in an
interface, we suggest that the class should @emph{contract} the
interface, in order to make sure that the call will succeed if the
methods are inherited, and especially, if the subclass overrides the
method's definition.

A class may specify a list of attributes or class variables.

A class may then specify a list of private methods.

A class may specify a list of public methods by using a @emph{with
definition}.  A with deginition has the format @code{with
@var{interface} @var{operations} @var{invariants}}, where
@code{with @var{interface}} specifies the co-interface.

An operation definition has the form @code{op @var{name} (in
@var{ins}; out @var{outs}) requires @var{precondition} ensures
@var{postcondition} == @var{variables} @var{statement}}.  @var{ins} is
a list of variable declarations describing the @emph{input}
parameters.  @var{outs} is a list of variables describing the output
parameters.  In principle, one should only read from input parameters
and only write to output parameters.

The precondition and postcondition are optional and their meaning can
be easily defined using invariants.

The body of a method consists of local variable definitions followed
by a statement.


@node Datatype Declaration
@subsection Datatype Declarations

TBD


@node Exception Declaration
@subsection Exception Declarations

Exception have to be declared for type checking.  A declaration has
the form
@example
exception @var{E} [ ( @var{@{ var-decl-no-init @}} ) ]
@end example

This allows a programmer to supply additional information to an
exception.

@itemize @bullet
@item
Actually, only a sequence of types should be sufficient, or we may use
these names as record names.
@end itemize


@node Grammar
@section Creol Grammar

For reference, we summarize the grammar of Creol.  The grammar of
Creol is LR(1) and is used by the compiler.  @code{@{...@}} means a
list of symbols, where the optional decorator at the end indicates the
separator.  An optional symbol is enclosed in square brackets like
this: @code{[ ... ]}.  Terminal symbols are printed like this:
@strong{terminal}.  Finally, the symbol @var{id}, denoting method
names, functions, and variables, refers to an identifier, which is any
string that matches the regular expression @code{[a-z][_0-9A-Za-z]*},
and @var{cid}, denoting class and type names, refers to any string
that matches the regular expression @code{[A-Z][_0-9A-Za-z]*}.


@subsection Reserved Keywords

The following are reserved as keywords and cannot be used for
variable or method names in programs.

@c 45678901 34567890123 56789012345 78901234567 90123456789 12345678901
@example
and         await       begin       by          caller      class
contracts   do          else        end         ensures     exception
false       fi          for         history     iff         if
implements  inherits    interface   inv         in          new
nil         null        not         od          op          or
out         raise       requires    self        skip        system
then        this        to          true        try         var          
wait        while       with        xor         History     Label          
System      constructor function
@end example

The following symbols are used as operator symbols.  They are listed
in the order of their precedence.  Operators on any line bind stronger
than ones on the lines above.

@example
and or xor iff
not                              @r{unary operator}
= /=
<= < > >=
|- |-| -|
+ -
* /
- #                              @r{unary operators}
@end example

@subsection Grammar

@format
unit ::=
    @{ declaration @}

declaration ::=
    class-decl
  | interface-decl
  | exception-decl
  | datatype-decl

class-decl ::=
    @strong{class} cid [ @strong{(} @{ var-decl-no-init @strong{,} @} @strong{)}]
    [@strong{inherits} @{ cid [@strong{(} @{ expr @strong{,} @} @strong{)}] , @} ]
    [@strong{implements} @{ cid @strong{,} @} ]
    [@strong{contracts} @{ cid @strong{,} @} ]
    @strong{begin} @{ @strong{var} var-decl @} [ anon-with-def ] @{ with-def @}
    @strong{end}

interface-decl ::=
    @strong{interface} id [@strong{inherits} @{ id @strong{,} @}]
    @strong{begin} @strong{with} cid @{ op-decl @} @{ invariant @} @strong{end}

exception.decl ::=
    @strong{exception} cid [ @strong{(} @{ var-decl-no-init @strong{,} @} @strong{)} ]

datatype-decl ::=
    @strong{datatype} cid [ @strong{by} @{ cid @strong{,} @} ] @strong{begin}
    @{ constructor @} @{ function @} @{ invariant @} @strong{end}

var-decl-no-init ::=
    @{ id @strong{,} @} @strong{:} type

var-decl ::=
    var-decl-no-init @strong{:=} @{ expr @strong{,} @}

op-decl ::=
    @strong{op} id @strong{(} @strong{in} @{ var-decl-no-init @strong{,} @} [ @strong{;}
    @strong{out} @{ var-decl-no-init @strong{,} @} ] @strong{)}
    [@strong{requires} assertion] [@strong{ensures} assertion]

anon-with-def ::=
    @{ op-def @} @{ invariant @}

with-def ::=
    @strong{with} cid @{ op-def @} @{ invariant @}

op-def ::=
    op-decl @strong{==} @{ @strong{var} var-decl @strong{;} @} statement

constructor ::=
    @strong{constructor} cid [ @strong{(} @{ type @strong{,} @strong{)} ] @strong{:} cid

function ::=
    @strong{function} id @strong{(} @{ var-decl-no-init @strong{,} @} @strong{)} @strong{==}
    expression

statement ::=
    choice-statement [ @strong{|||} statement ]

choice-statement ::=
    seq-statement [ @strong{[]} choice-statement ]

seq-statement ::=
    @{ basic-statement @strong{;} @}

basic-statement ::=
    @strong{skip}
  | @strong{assert} expression
  | @strong{prove} expression
  | @{ id @strong{,} @} @strong{:=} @{ expr-or-new @strong{,} @}
  | @strong{await} guard
  | [ id ] @strong{!} expr @strong{.} id @strong{(} @{ expr @strong{,} @} @strong{)}
  | [ id ] @strong{!} id [ @strong{@@} cid ] @strong{(} @{ expr @strong{,} @} @strong{)}
  | id @strong{?} @strong{(}  @{ id @strong{,} @} @strong{)}
  | expr @strong{.} id @strong{(} @{ expr @strong{,} @} @strong{;} @{ id @strong{,} @} @strong{)}
  | id [@strong{@@} cid] @strong{(} @{ expr @strong{,} @} @strong{;} @{ id @strong{,} @} @strong{)}
  | @strong{@{} statement @strong{@}}
  | @strong{if} expr @strong{then} statement [@strong{else} statement] @strong{fi}
  | @strong{for} id @strong{:=} expression @strong{to} expression
      [ @strong{by} expression ] [ @strong{inv} assertion ] @strong{do} statement @strong{od}
  | @strong{while} expression [ @strong{inv} assertion ] @strong{do} statement @strong{od}
  | @strong{raise} cid [ @strong{(} @{ expr @strong{,} @} @strong{)} ]
  | @strong{try} statement catchers @strong{end}

catchers ::=
    @{ @strong{with} cid [ @strong{(} @{ id @strong{,} @} @strong{)} ] @strong{do} statement @}
    [ @strong{else} statement ]

expr-or-new ::=
    @strong{new} cid @strong{(} @{ expr @strong{,} @} @strong{)}
  | expr

expr ::=
    integer | float | string | @strong{true} | @strong{false} | @strong{nil} |
    @strong{null}
  | id | unaryop expr |  expr binop expr
  | id @strong{(} @{ expr @strong{,} @} @strong{)} | expr @strong{`} id
  | @strong{(} expr @strong{)}

binop ::= @strong{+} | @strong{-} | @strong{*} | @strong{/} | @strong{=} | @strong{<} | @strong{>} |
          @strong{<=} | @strong{>=} | @strong{and} | @strong{&} | @strong{&&} | @strong{/\} |
          @strong{or} | @strong{|} | @strong{||} | @strong{\/} | @strong{|-} | @strong{|-|} | @strong{-|} | @strong{\}

unaryop ::= @strong{not} | @strong{-} | @strong{#}

assertion ::=
    expr
  | @strong{forall} var-decl-no-init @strong{:} assertion
  | @strong{exists} var-decl-no-init @strong{:} assertion
@end format
