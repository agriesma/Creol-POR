@node Creol
@chapter Creol

This chapter describes the concrete syntax of Creol.  It also gives an
informal semantics.

This chapter is not yet finished.  Some constructs described in this
chapter need not be implemented by the compiler or the maude
semantics, yet.


@menu
* Comments::                    Comments in Creol.
* Literals and Expression::     The functional sub-language.
* Statements::                  The object-oriented sub-language.
* Interface Declaration::       Types for objects.
* Class Declaration::           Implementation for types.
* Datatype Declaration::
* Exception Declaration::
* Grammar::                     Creol grammar in EBNF.
@end menu


@node Comments
@section Comments

Creol supports too kinds of comments, both have been derived from C++
abd Java.

The first kind begins with @code{//} and extends until the first
following linebreak.

The second kind starts with @code{/*} and extends until the first
following @code{*/}.  Comments of this kind do not nest.


@node Literals and Expression
@section Literals and Expressions

Creol assumes a functional sub-language, which we describe in this
section.  The equality symbol


@subsection Literals

The boolean literals of creol are @code{true} and @code{false}.

The integer literals match the regular expression @code{[0-9]+}.

Floating-point literals match the regular expression
@code{(0|([1-9][0-9]+)).[0-9]*([eE]-?[1-9][0-9]+)?}.

A string literal is a sequence of characters enclosed in quotes:
@code{"}.  The usual escape sequences using backslash, e.g.,
@code{\n}, @code{\"}, @code{\\}, are supported.

The empty list is represented by the literal @code{nil}.

The null-reference is represented by the literal @code{null}.

The self-reference is represented by the literal @code{this}.


@subsection Variables

Variables are lower-case character-sequences, matching the regular
expression @code{[a-z][a-zA-Z0-9]}.  Variables are typed (see below).


@subsection Boolean Expressions

The boolean expressions are:

@code{@var{expression} = @var{expression}} for equality.

@code{@var{expression} /= @var{expression}} for in-equality.

@code{~ @var{expression}} for negation.

@code{@var{expression} && @var{expression}} for conjunction.

@code{@var{expression} || @var{expression}} for disjunction.

@code{@var{expression} => @var{expression}} for implication.

@code{@var{expression} <=> @var{expression}} for bi-implication.

@code{@var{expression} ^ @var{expression}} for exclusive or.


@subsection Integers, Reals, and Arithmetic Expressions

The arithmetic expressions are:

@code{- @var{expression}} for negation.

@code{@var{expression} ** @var{expression}} for exponentiation.

@code{@var{expression} * @var{expression}} for multiplication.

@code{@var{expression} / @var{expression}} for division.

@code{@var{expression} % @var{expression}} for modulo.

@code{@var{expression} + @var{expression}} for addition.

@code{@var{expression} - @var{expression}} for substraction.


@subsection Strings

The operations on strings are the same as the ones on sequences.
Single-letter strings are considered to be characters.


@subsection Tuples

The operatopns on tuples are

@code{( @var{expression} , )} for tuple construction.


@subsection Sequences

The operatons on sequences are:

@code{@var{expression} |- @var{expression}} for appending to the right.

@code{@var{expression} -| @var{expression}} for appending to the left.

@code{@var{expression} |-| @var{expression}} for concatenation.

@code{@var{expression} \ @var{expression}} for projection.

Sequences can be constructed by enumerating their elements in order:
@code{[ @{ @var{expression} , @} ]}.


@subsection Sets

The operations on sets are:

@code{@var{expression} \ @var{expression}} for set-difference.

@code{@var{expression} || @var{expression}} for union.

@code{@var{expression} && @var{expression}} for intersection.

@code{@var{expression} in @var{expression}} for testing membership.

@code{@{ @var{id} : @var{expression} | @var{expression} @}}
for set aggregation:

@code{@{ @}} represents the empty set.  Generally, sets can be
constructed by enumerating the elements: @code{@{ @{ @var{expression}
, @} @}}.



@subsection Object Expressions and Literals

Object expressions and literals are expressions whose value is a
reference to an object.  The only literal is @code{null}, representing
the null-pointer.

The expression @code{@var{expression} as @var{type}} represents
re-typing.  This usually involves a run-time check.


@subsection Function Application

Generally, applying a function is written as
@code{@var{f}(@var{e},@var{d},...,@var{c})}, where @var{f} is the name
of a function and @var{e},@var{d},@dots{} refers to expressions
representing the actual arguments.


@subsection Field Access

While the fields of objects are considered to be private to the
object, the functional sub-language generates automatic projections
for structures.

Structures may arise, e.g., from data type definitions (see below).

@example
datatype Note
begin
  var file: String
  var line: Integer
end
@end example

In this example, an exception e is of type @code{ParseError}, which is
a structure with the two fields @code{file} and @code{line}.  If
Â·@code{n} is a variable of type @code{Note}, then @code{n`file} is the
value of the file component.

@itemize @bullet
@item
Field access expressions should only be valid within the data type
module?  Otherwise we do not adhere to the principles of encapsulation
for abstract data types.
@end itemize


@node Statements
@section Statements

In this section we describe the statements of Creol programs.


@subsection Assignments

A single assignment may be written as @code{@var{x} := @var{e}}, where
@var{x} is the name of an attribute or a local variable and @var{e}
is an expression.

A multiple assingment is written as
@code{@var{x},@var{y},...,@var{z} := @var{e},@var{f},...,@var{g}},
where the left hand side is a tuple of variable names and the right
hand side is a tuple of expressions.  Both tuples should have the same
length.


@subsection Object Creation

The creation of an object is written as @code{@var{v}:= new
@var{C}(@var{e},...)}.  @var{v} is the variable which will hold the
reference to the new object.  @var{C} is the name of the class of the
new object.  @var{e}, @dots{} are the arguments to the constructor.
Note that @var{C} has to implement an interface which is a subtype of
the interface type of @var{v}.

@subsection Synchronous Method Calls

A @emph{local} synchronous method call is written as
@code{@var{m}[@@@var{C}](@var{ins};@var{outs})}, where @var{m} is the
name of a method, @var{C} is an optional class name, @var{ins} is a
possibly empty list of expressions describing the actual arguments to
the call and @var{outs} is a possibly empty list of variable or
attribute names used to store the result values.

A @emph{remote} synchronous method call is written as
@code{@var{e}.@var{m}(@var{ins};@var{outs})}, where @var{e} is an
object expression describing the receiver, @var{m} is the name of a
method, @var{ins} is a possibly empty list of expressions describing
the actual arguments to the call and @var{outs} is a possibly empty
list of variable or attribute names used to store the result values.


@subsection Asynchronous Method Calls

A @emph{asynchronous} method call is written as
@code{@var{l}!@var{e}.@var{m}(@var{ins})}, where @var{l} is the name
of a label, @var{m} is the name of a method, @var{ins} is a possibly
empty list of expressions describing the actual arguments to the call.

Results are received by the statement @code{?(@var{outs})}, where
@var{l} is a label name used for invoking the method, and @var{outs}
is a list of variable names used to store the result.


@subsection Blocks

Groups of statements are formed using braces, i.e., any statement or
compound statement inside braces @code{begin ... end} form a basic
statement.


@subsection Conditional Statement

The usual @code{if ... then ... else ... end} statement.


@subsection Type inspection using type cases

Creol does not support casting.  Instead, we use a type case construct
to execute code which depends on the type of an object.

@example
case @var{variable} when
  @var{type} -> @var{statement}
| @var{type} -> @var{statement}
| @var{type} -> @var{statement}
| _ -> @var{statement}
end
@end example

The value of @var{variable} is tested to be an instance of the type
given by the label @var{type} from left to right.  Only the first
match is executed.

Within the code following the type label the value of @var{variable}
is typed by the type label.  Retyping does not happen in the default
case, which is labeled by @code{_}, i.e., the type of @var{variable}
is its declared type.

A compile time error shall occur if a label is used which is not a
subtype of the type of @var{variable}.


@subsection Loop Statements

Loops should be avoided in Creol programs.  Creol provides to variants
of loops:

The @code{for}-loop is guaranteed to terminate.  Its syntax is @code{for
@var{i} := @var{lower} to @var{upper} by @var{stride} do
@var{statement} od}.  First, the expressions denoted by @var{lower}
and @var{upper} are evaluated.  Then @var{i} assumes each value which
is greater or equal to @var{lower} until it is greater or equal to
@var{upper}.  Furthermore, the variable @var{i} is @emph{read-only} in
@var{statement}.

Essentially, a for-statement can be transformed to the following
pseudo-program using a while loop:
@example
let l = lower in
  let u = upper in
    let st = stride in
      i := l;
      while i <= u do s; i := i + st done
@end example

Analogously, Creol programs may contain while loops.  Use of while
loops is @emph{strongly} discouraged, because they may make
class-updates impossible.  The syntax is @code{while @var{c} do
@var{s} od}.

Both variants of loops may be annotated by a @emph{loop invariant}.
The invariant is a proof obligation which must hoold at the beginning
of a loop, the end of a loop, @emph{and} every processor release-point
within the loop body.  It is therefore advisable, that the loop
invariant restricted to instance variables is @emph{implied} by the
class invariant.

The statement @code{while true inv @var{i} do s; await wait od} is an
infinite loop which allows class updates.  The invariant @var{i}
should be implied by the class invariant, because during the release
in @code{await wait}, only the class invariant is guaranteed to hold
(and, of course, the local state of the method remains invariant).


@subsection Sequential Composition

Statements can be composed sequentially using the @code{;} operator.

Note that contrary to Java and C @code{;} is a @emph{binary operator}
on statements, i.e., it is not a statement terminator.


@subsection Non-deterministic merge

TBD


@subsection Non-deterministic choice

The statement @code{S1 [] S2} chooses either @code{S1} or @code{S2}
for execution.

If both statements are @emph{guarded} by an @code{await} statement,
then execution is suspended, if both await statements are not enabled.
If exactly one of the await statements is enabled, then this one will
be chosen and the process will not be suspended.  If both guards are
enabled, one of the statements is chosen non-deterministically.

Observe, that @code{S1 [] S2} is semantically equivalent to @code{S2
[] S1}.  Also, the statement @code{skip; S1 [] await b; S2} is
semantically equivalent to @code{S1} if @code{b} is false.

External choice can be implemented as
@code{await b1; S1 [] await b2; S2}
and internal choice as
@code{skip; await b1; S1 [] skip; await b2; S2}.


@subsection Precedence of Statement Composition

The operators @code{;}, @code{[]}, and @code{|||} are binary operators
on statements.  All of them are @emph{left-associative}, @code{;}
binds strongest and @code{|||} binds weakest.  Braces may be omitted
in @code{@{ S; T @} [] U} but not in @code{S; @{ T [] U @}}.


@node Interface Declaration
@section Interface Declarations

All objects in Creol are typed by interface.

Each class is assumed to implement the empty interface @code{Any}.
This interface is the implicit superinterface of all other interfaces.

An interace may inherit from other interfaces, making an instance of
this interface also an instance of all super-interfaces.

An interface has a unique name.  It declares a @emph{co-interface},
which expresses mutual dependencies and constrains the users of this
interface:  Each caller of a method specified in an interface
@emph{must} implement its co-interface.

An interface specifies the signature of a sequence of methods.

@example
interface @var{I} [ inherits @var{@{ cid @}} ]
begin
  [ with @var{I'}
    @var{@{ method-decl @}}
    @var{@{ invariants @}} ]
end
@end example

@subsection Open Issues

With respect to interface declarations, the following ideas may be
considered:
@itemize @bullet
@item
May be we want to allow more than one co-interface declaration in an
interface?  Currently, an interface with two co-interface declarations
has to be constructed by inheriting the block with one interface.  On
the other hand, one might feel that both blocks form a unit and should
not be used separately.

@item
One might be tempted to introduce type-parameterised interfaces or
value-parameterised interfaces.  But a concrete use case is needed,
first.

@item
Why do we use @code{inherits} if the semantics of sub-interfacing is
much closer to @code{contracts}, or is it not?
@end itemize


@node Class Declaration
@section Class Declarations

A class provides the implementation of an object.

A class declaration specifies the name of the class, which must start
with an upper-case letter, and optionally a list of @emph{class
parameters}.  These parameters are like read-only attributes of the
class and provide the signature of the @emph{only} constructor.

A class can inherit from a list of super-classes, which are defined in
an @code{inherits} specification.

A class can declare to @emph{implement} a set of interfaces.  These
interfaces are @emph{not} inherited.

A class can declare to @emph{contract} a set of interfaces.  This
clause is similar to an @code{implements} clause, but in addition it
requires each @emph{sub-class} to implement these interfaces, too.

If an object calls methods of itself, which are specified in an
interface, we suggest that the class should @emph{contract} the
interface, in order to make sure that the call will succeed if the
methods are inherited, and especially, if the subclass overrides the
method's definition.

A class may specify a list of attributes or class variables.

A class may then specify a list of private methods.

A class may specify a list of public methods by using a @emph{with
definition}.  A with deginition has the format @code{with
@var{interface} @var{operations} @var{invariants}}, where
@code{with @var{interface}} specifies the co-interface.

An operation definition has the form @code{op @var{name} (in
@var{ins}; out @var{outs}) requires @var{precondition} ensures
@var{postcondition} == @var{variables} @var{statement}}.  @var{ins} is
a list of variable declarations describing the @emph{input}
parameters.  @var{outs} is a list of variables describing the output
parameters.  In principle, one should only read from input parameters
and only write to output parameters.

The precondition and postcondition are optional and their meaning can
be easily defined using invariants.

The body of a method consists of local variable definitions followed
by a statement.


@node Datatype Declaration
@section Datatype Declarations

TBD


@node Exception Declaration
@section Exception Declarations

Exception have to be declared for type checking.  A declaration has
the form
@example
exception @var{E} [ ( @var{@{ var-decl-no-init @}} ) ]
@end example

This allows a programmer to supply additional information to an
exception.

@itemize @bullet
@item
Actually, only a sequence of types should be sufficient, or we may use
these names as record names.
@end itemize


@node Grammar
@section Creol Grammar

For reference, we summarize the grammar of Creol.  The grammar of
Creol is LR(1) and is used by the compiler.  @code{@{...@}} means a
list of symbols, where the optional decorator at the end indicates the
separator.  An optional symbol is enclosed in square brackets like
this: @code{[ ... ]}.  Terminal symbols are printed like this:
@strong{terminal}.  Finally, the symbol @var{id}, denoting method
names, functions, and variables, refers to an identifier, which is any
string that matches the regular expression @code{[a-z][_0-9A-Za-z]*},
and @var{cid}, denoting class and type names, refers to any string
that matches the regular expression @code{[A-Z][_0-9A-Za-z]*}.


@subsection Reserved Keywords

The following are reserved as keywords and cannot be used for
variable or method names in programs.

@c 45678901 34567890123 56789012345 78901234567 90123456789 12345678901
@example
assert      await       begin       by          caller      case
class       contracts   ctor        datatype    do          else
end         ensures     exception   exists      false       for
forall      fun         history     if          implements  inherits
interface   inv         in          new         nil         null
not         of          op          out         raise       requires
skip        some        then        this        to          true
try         var         wait        when        while       with
@end example

The following symbols are used as operator symbols.  They are listed
in the order of their precedence.  Operators on any line bind stronger
than ones on the lines above.

@example
,                               @r{left}
|                               @r{left}
in                              @r{left}
as                              @r{left}
<=>                             @r{left}
=>                              @r{left}
^                               @r{left}
|| \/                           @r{left}
&& /\                           @r{right}
~                               @r{right, unary operator}
= /=                            @r{non-associative}
<= < > >=                       @r{left}
\                               @r{left}
|-|                             @r{left}
-|                              @r{right}
|-                              @r{left}
+ -                             @r{left}
* / %                           @r{left}
**                              @r{left}
- #                             @r{right, unary operators}
`                               @r{left}
@end example


@subsection Grammar

@format
unit ::=
    @{ declaration @}

declaration ::=
    class-decl
  | interface-decl
  | exception-decl
  | datatype-decl

class-decl ::=
    @code{class} cid [ @code{(} @{ var-decl-no-init @code{,} @} @code{)}]
    [@code{inherits} @{ cid [@code{(} @{ expr @code{,} @} @code{)}] , @} ]
    [@code{implements} @{ cid @code{,} @} ]
    [@code{contracts} @{ cid @code{,} @} ]
    @code{begin} @{ @code{var} var-decl @} [ anon-with-def ] @{ with-def @}
    @code{end}

interface-decl ::=
    @code{interface} id [@code{inherits} @{ id @code{,} @}]
    @code{begin} @code{with} cid @{ op-decl @} @{ invariant @} @code{end}

exception.decl ::=
    @code{exception} cid [ @code{(} @{ var-decl-no-init @code{,} @} @code{)} ]

datatype-decl ::=
    @code{datatype} cid [ @code{by} @{ cid @code{,} @} ] @code{begin}
    @{ constructor @} @{ function @} @{ invariant @} @code{end}

var-decl-no-init ::=
    @{ id @code{,} @} @code{:} type

var-decl ::=
    var-decl-no-init @code{:=} @{ expr @code{,} @}

op-decl ::=
    @code{op} id @code{(} [ @code{in} @{ var-decl-no-init @code{,} @} ]
    [ @code{;} @code{out} @{ var-decl-no-init @code{,} @} ] @code{)}  
    [@code{requires} assertion] [@code{ensures} assertion]

anon-with-def ::=
    @{ op-def @} @{ invariant @}

with-def ::=
    @code{with} cid @{ op-def @} @{ invariant @}

op-def ::=
    op-decl @code{==} @{ @code{var} var-decl @code{;} @} statement

constructor ::=
    @code{constructor} cid [ @code{(} @{ type @code{,} @code{)} ] @code{:} cid

function ::=
    @code{function} id @code{(} @{ var-decl-no-init @code{,} @} @code{)} @code{==} expression

statement ::=
    choice-statement [ @code{|||} statement ]

choice-statement ::=
    seq-statement [ @code{[]} choice-statement ]

seq-statement ::=
    @{ basic-statement @code{;} @}

basic-statement ::=
    @code{skip}
  | @{ id @code{,} @} @code{:=} @{ expr-or-new @code{,} @}
  | @code{await} guard
  | [ id ] @code{!} expr @code{.} id @code{(} @{ expr @code{,} @} @code{)}
  | [ id ] @code{!} id [ @code{@@} cid ] [ @code{<<} cid ] @code{(} @{ expr @code{,} @} @code{)}
  | id @code{?} @code{(}  @{ id @code{,} @} @code{)}
  | expr @code{.} id @code{(} @{ expr @code{,} @} @code{;} @{ id @code{,} @} @code{)}
  | id [@code{@@} cid] [ @code{<<} cid ] @code{(} @{ expr @code{,} @} @code{;} @{ id @code{,} @} @code{)}
  | @code{begin} statement @code{end}
  | @code{if} expr @code{then} statement [@code{else} statement] @code{end}
  | @code{case} expr @code{of} @{ case-stmt @code{|} @} @code{end}
  | @code{case} id @code{when} @{ type-case-stmt @code{|} @} @code{end}
  | @code{raise} cid [ @code{(} @{ expr @code{,} @} @code{)} ]
  | @code{try} statement @code{with} @{ catch-stmt @code{|} @} @code{end}
  | @code{for} id @code{:=} expression @code{to} expression
      [ @code{by} expression ] [ @code{inv} assertion ] @code{do} statement @code{end}
  | @code{while} expression [ @code{inv} assertion ] @code{do} statement @code{end}
  | @code{assert} assertion

case-stmt ::=
    pattern [ @code{when} expression ] @code{->} statement

type-case-stmt ::=
    (type | @code{_}) @code{->} statement

catch-stmt ::=
    ( ( cid [ @code{(} @{ id @code{,} @} @code{)} ] ) | @code{_} ) @code{->} statement

guard ::=
    @code{wait} | id @code{?} [ @code{&} guard ] | expression

expr-or-new ::=
    @code{new} cid @code{(} @{ expr @code{,} @} @code{)}
  | expr

expr ::=
    @code{true} | @code{false} | integer | float | string | @code{nil} | @code{null} | id
  | @code{(} @{ expr @code{,} @} @code{)}
  | @code{[} @{ expr @code{,} @} @code{]}
  | @code{@{} @{ expr @code{,} @} @code{@}}
  | @code{@{} id @code{:} expr @code{|} expr @code{@}}
  | unaryop expr | expr binop expr | expr @code{as} type
  | id @code{(} @{ expr @code{,} @} @code{)} | expr @code{`} id
  | @code{if} expr @code{then} expr @code{else} expr @code{end}
  | @code{case} expr @code{of} @{ case-expr @code{|} @} @code{end}
  | @code{case} expr @code{when} @{ type-case-expr @code{|} @} @code{end}
  | @code{raise} cid [ @code{(} @{ expr @code{,} @} @code{)} ]
  | @code{try} expr @code{with} @{ catch-expr @} @code{end}

unaryop ::= @code{not} | @code{-} | @code{#}

binop ::=
    @code{+} | @code{-} | @code{*} | @code{/} | @code{=} | @code{<} | @code{>} |
    @code{<=} | @code{>=} | @code{and} | @code{&} | @code{&&} | @code{/\} |
    @code{or} | @code{|} | @code{||} | @code{\/} | @code{|-} | @code{|-|} | @code{-|} | @code{\}

case-expr ::=
    pattern [ @code{when} expression ] @code{->} expression

type-case-expr ::=
    (type | @code{_}) @code{->} expr

catch-expr ::=
    ( ( cid [ @code{(} @{ id @code{,} @} @code{)} ] ) | @code{_} ) @code{->} statement

pattern ::=
    id
  | @code{_}
  | pattern @code{as} id
  | @code{(} pattern @code{)}
  | cid pattern
  | pattern @code{|} pattern
  | pattern @code{,} pattern
  | pattern @code{|-} pattern
  | pattern @code{-|} pattern

assertion ::=
    expr
  | @code{forall} var-decl-no-init @code{:} assertion
  | @code{exists} var-decl-no-init @code{:} assertion
@end format
