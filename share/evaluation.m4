dnl Definition of creol statements.
dnl
dnl Copyright (c) 2007, 2008 by Marcel Kyas <kyas@ifi.uio.no>
dnl
dnl Do NOT edit this file.  This file may be overwritten.  It has been
dnl automatically generated from interpreter.m4 using m4.
dnl
dnl This program is free software; you can redistribute it and/or
dnl modify it under the terms of the GNU General Public License as
dnl published by the Free Software Foundation; either version 3 of the
dnl License, or (at your option) any later version.
dnl
dnl This program is distributed in the hope that it will be useful, but
dnl WITHOUT ANY WARRANTY; without even the implied warranty of
dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
dnl General Public License for more details.
dnl
dnl You should have received a copy of the GNU General Public License
dnl along with this program.  If not, see <http://www.gnu.org/licenses/>.
dnl
*** Definition of the family of evaluation functions.
***
mod `CREOL-EVAL' is

    protecting CREOL-CONFIGURATION .

    vars L L' : Label .
    vars E E' E'' : Expr .
    vars D D' : Data .
    var DL : DataList .
    var EL : ExprList .
    var NeEL : NeExprList .
    var ES : ExprSet .
    var NeES : NeExprSet .
    var DS : DataSet .
    var EM : ExprMap .
    var A : Vid .
    var AL : VidList .
    vars Q C : String .
    vars S S' : Subst .
    var MM : MMsg .
    vars ST ST' : Stmt . 
    vars SL SL1 SL2 : StmtList .

    --- Check if a message is in the queue.
    op inqueue  : Label MMsg -> Bool .
    eq inqueue(L, noMsg) = false .
    eq inqueue(L, comp(L', DL) + MM) =
        if L == L' then true else inqueue(L, MM) fi .

dnl
dnl Macros for dealing with enabledness and readyness in the timed and
dnl untimed cases.
dnl
ifdef(`TIME',dnl
    var T : Float .

    op evalGuard : Expr Subst MMsg Float -> Data .
    op evalGuardList : ExprList Subst MMsg Float -> DataList [strat (1 0 0 0 0)] .
    op evalGuardSet : ExprSet Subst MMsg Float -> DataSet [strat (1 0 0 0 0)] .
    op evalGuardMap : ExprMap Subst MMsg Float -> DataMap [strat (1 0 0 0 0)] .
    op enabled : StmtList Subst MMsg Float -> Bool .
    op ready : StmtList Subst MMsg Float -> Bool .
,dnl Untimed:

    op evalGuard : Expr Subst MMsg -> Data .
    op evalGuardList : ExprList Subst MMsg -> DataList [strat (1 0 0 0)] .
    op evalGuardSet : ExprSet Subst MMsg -> DataSet [strat (1 0 0 0)] .
    op evalGuardMap : ExprMap Subst MMsg -> DataMap [strat (1 0 0 0)] .
    op enabled : StmtList Subst MMsg -> Bool .
    op ready : StmtList Subst MMsg -> Bool .
)dnl

    eq EVALGUARD(D, S, MM, T) = D .
    eq EVALGUARD(now, S, MM, T) = ifdef(`TIME', time(T), time(0.0)) .
    eq EVALGUARD((Q @ C), (S :: S'), MM, T) =  S [Q] .
    eq EVALGUARD(A, S, MM, T) =  S [A] .
    eq EVALGUARD(Q (EL), S, MM, T) = Q ( EVALGUARDLIST(EL, S, MM, T) ) .
    eq EVALGUARD(?(A), S, MM, T) = bool(inqueue(S[A], MM)) .
    eq EVALGUARD(?(L), S, MM, T) = bool(inqueue(L, MM)) .
    eq EVALGUARD(list(EL), S, MM, T) = list(EVALGUARDLIST(EL, S, MM, T)) .
    eq EVALGUARD(set(ES), S, MM, T) = set(EVALGUARDSET(ES, S, MM, T)) .
    eq EVALGUARD(map(EM), S, MM, T) = map(EVALGUARDMAP(EM, S, MM, T)) .
    eq EVALGUARD(if E th E' el E'' fi, S, MM, T) =
      if EVALGUARD(E, S, MM, T) asBool
      then EVALGUARD(E', S, MM, T)
      else EVALGUARD(E'', S, MM, T) fi .

    --- Evaluate guard lists.  This is almost the same as evalList, but we
    --- had to adapt this to guards.
    eq EVALGUARDLIST(emp, S, MM, T) = emp .
    eq EVALGUARDLIST(DL, S, MM, T) = DL .   --- No need to evaluate.
    eq EVALGUARDLIST(E, S, MM, T) = EVALGUARD(E, S, MM, T) .
    eq EVALGUARDLIST(E :: NeEL, S, MM, T) =
      EVALGUARD(E, S, MM, T) :: EVALGUARDLIST(NeEL, S, MM, T) .

    eq EVALGUARDSET(emptyset, S, MM, T) = emptyset .
    eq EVALGUARDSET(DS, S, MM, T) = DS .  ---  No need to evaluate
    eq EVALGUARDSET(E, S, MM, T) = EVALGUARD(E, S, MM, T) .
    eq EVALGUARDSET(E : NeES, S, MM, T) =
    EVALGUARD(E, S, MM, T) : EVALGUARDSET(NeES, S, MM, T) .

    --- Evaluate a map.
    eq EVALGUARDMAP(empty, S, MM, T) = empty .
   eq EVALGUARDMAP((mapentry(D, D'), EM), S, MM, T) =
     (mapentry(D, D') , EVALGUARDMAP(EM, S, MM, T)) .  --- No need to evaluate .
   eq EVALGUARDMAP((mapentry(D, E'), EM), S, MM, T) =
     (mapentry(D, EVALGUARD(E', S, MM, T)) , EVALGUARDMAP(EM, S, MM, T)) .
   eq EVALGUARDMAP((mapentry(E, D'), EM), S, MM, T) =
     (mapentry(EVALGUARD(E, S, MM, T), D') , EVALGUARDMAP(EM, S, MM, T)) .
   eq EVALGUARDMAP((mapentry(E, E'), EM), S, MM, T) =
     (mapentry(EVALGUARD(E, S, MM, T), EVALGUARD(E', S, MM, T)) ,
     EVALGUARDMAP(EM, S, MM, T)) .

    --- Enabledness
    eq ENABLED(await E ; SL, S, MM, T) = EVALGUARD(E, S, MM, T) asBool .
dnl ifdef(`TIME',dnl
dnl  eq ENABLED(posit E ; SL, S, MM, T) = EVALGUARD(E, S, MM, T) asBool .
dnl)dnl
    eq ENABLED((SL1 [] SL2) ; SL,  S, MM, T) =
         ENABLED(SL1, S, MM, T) or ENABLED(SL2, S, MM, T) .
ifdef(`WITH_MERGE',
`    eq ENABLED((SL1 ||| SL2) ; SL, S, MM, T) =
         ENABLED(SL1, S, MM, T) or ENABLED(SL2, S, MM, T) .
    eq ENABLED((SL1 MERGER SL2) ; SL, S, MM, T) = ENABLED(SL1, S, MM, T) .')
    eq ENABLED(SL, S, MM, T) = true [owise] .

    --- The ready predicate holds, if a statement is ready for execution,
    --- i.e., the corresponding process may be waken up.
    eq READY(get(A ; AL) ; SL , S, MM, T) = inqueue(S[A], MM) . 
    eq READY(get(L ; AL) ; SL , S, MM, T) = inqueue(L, MM) . 
    eq READY((SL1 [] SL2) ; SL, S, MM, T) =
          READY(SL1, S, MM, T) or READY(SL2, S, MM, T) .
ifdef(`WITH_MERGE',
`    eq READY((SL1 ||| SL2) ; SL, S, MM, T) =
	  READY(SL1, S, MM, T) or READY(SL2, S, MM, T) .
    eq READY((SL1 MERGER SL2) ; SL, S, MM, T) = READY(SL1, S, MM, T) .')
    eq READY(SL, S, MM, T) = ENABLED(SL, S, MM, T) [owise] .

endm
