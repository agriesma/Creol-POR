***
*** Signature of Creol programs
***
*** Copyright (c) 2007
***
*** This program is free software; you can redistribute it and/or
*** modify it under the terms of the GNU General Public License as
*** published by the Free Software Foundation; either version 2 of the
*** License, or (at your option) any later version.
***
*** This program is distributed in the hope that it will be useful, but
*** WITHOUT ANY WARRANTY; without even the implied warranty of
*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*** General Public License for more details.
***
*** You should have received a copy of the GNU General Public License
*** along with this program; if not, write to the Free Software
*** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
*** 02111-1307, USA.
***

*** Bound variables ***
fmod SUBST is
  protecting EXT-BOOL .
  protecting CREOL-DATA-SIG .
  protecting MAP{Aid, Data} * (sort Map{Aid, Data} to Subst,
                               op empty : -> Map{Aid, Data} to noSubst ) .

  vars A A' : Aid .
  vars D D' : Data .
  vars S1 S2  : Subst .

  *** Non-comm composition operator for substitutions
  op _#_ : Subst Subst -> Subst .
  eq S1 # noSubst = S1 .
  eq S1 # (S2, (A |-> D)) = insert(A, D, S1) # S2 .

  op dom : Aid Subst -> Bool .
  eq dom(A, noSubst) = false .
  eq dom(A, ((A' |-> D), S1)) = (A == A') or-else dom(A, S1) .
  eq dom(A, S1 # S2) = dom(A, S2) or-else dom(A, S1) .
endfm

fmod EVAL is
  protecting DATATYPES .
  protecting SUBST .

  var D : Data .
  var DL : DataList .
  vars E E' : Expr .
  var EL : ExprList .
  var A : Aid .
  var S : Subst .
  var Q : Qid .
  var I : Int .
  var B : Bool .

  op eval : Data Subst -> Data .
  eq eval(D, S) = D .

  *** standard evaluation of expression
  op eval     : Expr Subst     -> Data .
  eq eval(A, S) =  S [A] .
  eq eval(Q [[EL]], S) = Q [[ evalList(EL, S) ]] .
  eq eval(list(EL), S) = list(evalList(EL, S)) .
  eq eval(pair(E,E'),S) = pair(eval(E,S),eval(E',S)) .
  eq eval(setl(EL), S) = setl(evalList(EL, S)) .

  op evalList : DataList Subst -> DataList .
  eq evalList(emp, S) = emp .
  eq evalList(DL, S)= DL .

  op evalList : ExprList Subst -> DataList .
  eq evalList(E # EL, S) = eval(E, S) # evalList(EL, S) .

endfm


fmod GUARDS is
  protecting EVAL .

  sorts NoGuard Guard Wait Return PureGuard . 
  subsorts Return Expr < PureGuard .
  subsorts NoGuard Wait PureGuard < Guard .

  vars E E' : Expr .
  var PG : PureGuard .

  op noGuard : -> NoGuard [ctor format (b o)] .
  op wait :    -> Wait [ctor format (b o)] .
  op _??  : Aid -> Return [ctor] .
  op _??  : Label -> Return [ctor] .
  op _&_ : Guard Guard -> Guard [ctor id: noGuard assoc comm prec 55] .
  op _&_ : PureGuard PureGuard -> PureGuard [ditto] .

  eq wait & wait = wait .
  eq PG & PG = PG .
  eq E & E' = 'and[[E # E']] .

endfm

fmod STATEMENTS is
  pr GUARDS .

  sorts Mid Cid Stm .
  subsort Qid < Mid Cid .

  op _._   : Expr Mid -> Mid [ctor prec 33] .
  op _@_   : Qid  Cid -> Mid [ctor prec 33] .

  op skip : -> Stm [ctor] .
  op _::=_ : AidList ExprList -> Stm [ctor prec 39] .
  op _::= new_(_) : Aid Cid ExprList -> Stm [ctor prec 37 format (d b d o d d d d)] .
  op _(_:_) : Mid ExprList AidList -> Stm [ctor prec 39] .
  *** op !_(_)  : Mid ExprList -> Stm [ctor] .
  op _!_(_) : Aid Mid ExprList -> Stm [ctor prec 39] .
  op _?(_)  : Aid AidList -> Stm [ctor prec 39] .
  op _?(_)  : Label AidList -> Stm [ctor prec 39] .
  op await_ : Guard    -> Stm [ctor] .
  op return : ExprList -> Stm [ctor format (c o)] .
  op free : AidList -> Stm [ctor format (c o)] .
  op bury : AidList -> Stm [ctor format (c o)] .
  op cont : Label -> Stm [ctor format (c o)] .
  op tailcall_(_) : Mid ExprList -> Stm [ctor format (c o c o c o)] .
  op accept : Label -> Stm [ctor format (c o)] .
endfm

view Stm from TRIV to STATEMENTS is
   sort Elt to Stm .
endv

fmod STM-LIST is
  pr STATEMENTS .                
  protecting LIST{Stm} * (sort List{Stm} to StmList,
                          sort NeList{Stm} to NeStmList,
			  op nil : -> List{Stm} to noStm,
			  op __ : List{Stm} List{Stm} -> List{Stm} to _;_) .

  op if_th_el_fi : Expr StmList StmList -> Stm [ctor] . 
  op if_th_fi    : Expr StmList -> Stm [ctor] . 
  op while_do_od : Expr StmList -> Stm [ctor] .
  op _[]_  : StmList StmList -> Stm [ctor comm assoc prec 45] .
  op _|||_ : StmList StmList -> Stm [ctor comm assoc prec 47] .
  op _MERGER_  : StmList StmList -> Stm [assoc] .

  var SL : StmList .
  var NeSL : NeStmList .
  var EL : ExprList .
  var B : Expr .
  var PG : PureGuard .

  *** Some simplifications:
  eq await noGuard ; NeSL = NeSL . *** could be SL
  eq noAid ::= emp = skip [nonexec] .
  ***  eq skip ; SL = SL . *** may affect ||| order 
  eq (noStm []  SL)  = SL . 
  eq (noStm ||| SL)  = SL . 
  eq (noStm MERGER SL)      = SL .
  eq (SL MERGER noStm)      = SL .
  eq if B th SL fi = if B th SL el skip fi .

  eq await (wait & PG) = await wait ; await PG .
  *** eq await (R & PG)= await R ; await PG . --- could be rule for confluence!

  sort Process .
  op idle : -> Process [format (!b o)] .  
  op _,_ : Subst StmList -> Process [ctor format (o r nb o)] . 
  var L : Subst .
  eq (L, noStm) = idle . *** if 'label is needed this is dangerous!
  eq idle = (noSubst, noStm) [nonexec metadata "Will cause infinite loops."] .


  sorts NeMProc MProc .
  subsort Process < NeMProc < MProc .    *** Multiset of Processes
  op noProc : -> MProc [ctor] .
  op _++_ : MProc MProc -> MProc [ctor assoc comm id: noProc prec 41 format (d r os d)] .
  op _++_ : NeMProc MProc -> NeMProc [ctor ditto] .

endfm

*** CREOL classes ***
fmod CLASS is
  protecting STM-LIST .

  sorts    Class Mtd MMtd Inh InhList . *** inheritance list
  subsorts Inh < Expr .  
  subsorts Inh < InhList .

  op  _<_> : Cid  ExprList -> Inh .     *** initialised superclass
  op noInh : -> InhList [ctor] .
  op  _##_   : InhList InhList -> InhList [ctor assoc id: noInh] .

  var Ih : Inh . 
  var IL : InhList .
  var S : Subst . 
  var SL : StmList . 
  vars Q Q' : Qid . 
  var MM : MMtd .
  var EL : ExprList .
  var O : Oid .
  var N : Nat .
  var AL : AidList .

  eq  Ih ## IL ## Ih = Ih ## IL .

  op <_: Mtdname | Param:_, Latt:_, Code:_> : 
    Qid AidList Subst StmList -> Mtd [ctor
      format (g! g o o o g o o g o o g o g o)] .

  subsort Mtd < MMtd .    *** Multiset of methods

  op noMtd : -> Mtd [ctor] .
  op _*_  : MMtd MMtd -> MMtd [ctor assoc comm id: noMtd format (o o on o)] .

  op <_: Cl | Inh:_, Par:_, Att:_, Mtds:_, Ocnt:_> : 
    Cid InhList AidList Subst MMtd Nat -> Class 
     [format (nb! b o o o b o o  b o o  b o o  b on o  b o  b! on )] .

  op emptyClass : -> Class .
  eq emptyClass =
    < 'noClass : Cl | Inh: noInh , Par: noAid, Att: noSubst, Mtds: noMtd ,
      Ocnt: 0 > .

  *** Class/method functions ***
  op get : Qid MMtd Oid Label ExprList -> Process .  *** fetches pair (code, vars)
  op _in_ : Qid MMtd -> Bool .  *** checks if Q is a declared 
                                *** method in the method multiset

  eq Q in noMtd = false .
  eq Q in (< Q' : Mtdname | Param: AL, Latt: S, Code: SL > * MM) = 
       if (Q == Q') then true else (Q in MM) fi .

  *** bind call to process
  var Lab : Label .
  eq get(Q, noMtd, O, Lab, EL) = noProc . 
  eq get(Q, < Q' : Mtdname | Param: AL, Latt: S, Code: SL > * MM, O, Lab, EL) = 
    if Q == Q' 
    then (insert('caller, O, insert('label, Lab, S)), (AL ::= EL) ; SL)
    else get(Q, MM, O, Lab, EL) fi .

endfm

*** CREOL objects ***
fmod OBJECT is
  protecting CLASS .

  sort Object .

  op <_:_ | Att:_, Pr:_, PrQ:_, Lcnt:_> : 
       Oid Cid Subst Process MProc Nat -> Object 
         [ctor format (nr! r o o o  r o r  r o r r o r r o r! no)] .

  op noObj : -> Object [ctor] .

endfm

*** CREOL messages and queues ***
fmod COMMUNICATION is
  protecting OBJECT .

  sort Labels . *** list of labels
  subsort Label < Labels .

  sorts Body Msg MMsg Kid Queue .
  subsort Body < MMsg .

  op noMsg : -> MMsg [ctor] .
  op _+_ : MMsg MMsg -> MMsg [ctor assoc comm id: noMsg] . 

  op size : MMsg -> Nat .
  var M : Body .
  var MB : MMsg .
  eq size(M + MB) = 1 + size(MB) .
  eq size(noMsg) = 0 .

  *** INVOCATION and REPLY
  op invoc(_,_,_,_) : *** Nat Oid 
  Oid Label Mid DataList -> Body [ctor format (! o o o o o o o o o o)] .  
  op comp(_,_) : Label DataList -> Body [ctor format (! o o o o o o)] .  

  op _from_to_ : Body Oid Oid -> Msg [ctor format (o ! o ! o on)] .
  op error(_) : String -> [Msg] [ctor format (nnr r o! or onn)] .     *** error 
  op warning(_) : String -> [Msg] [ctor format (nnr! r! r! or onn)] .   *** warning 

  *** Method binding messages
  op bindMtd : Oid Oid Label Qid ExprList InhList -> Msg [ctor] . 
  ***Bind method request
  *** Given: caller callee method params (list of classes to look in)
  op boundMtd(_,_) : Oid Process -> Msg 
    [ctor format (!r r o o o !r on)] . *** binding result
  *** CONSIDER the call O.Q(I). bindMtd(O,Q,I,C S) trie to find Q in
  *** class C or superclasses, then in S. boundMtd(O,Mt) is the result.


  *** message queue
  op noDealloc :         -> Labels  [ctor] .
  op _^_ : Labels Labels -> Labels [ctor comm assoc id: noDealloc] .

  op noQu : -> Queue [ctor] .
  op <_: Qu | Size:_, Dealloc:_, Ev:_ > : Oid Nat Labels MMsg -> Queue 
                          [format (nm! m o o o  m o o m o o m o m! no)] . 

endfm

*** STATE CONFIGURATION ***
fmod CONFIG is
  protecting OBJECT .
  protecting COMMUNICATION .

  sort Configuration .

  subsorts Object Msg Queue Class < Configuration .

  op noConf : -> Configuration [ctor] .
  op __ : Configuration Configuration -> Configuration [ctor assoc comm id: noConf] .
  op main : Cid ExprList -> Configuration .

  var C : Cid . var E : ExprList .
  eq main(C,E) = < ob('main) : 'Class | Att: noSubst, 
                 Pr: (noSubst, ('var ::= new C(E))), PrQ: noProc, Lcnt: 0 > 
               < ob('main) : Qu | Size: 1, Dealloc: noDealloc,Ev: noMsg > .

endfm

*** AUXILIARY FUNCTIONS ***
fmod AUX-FUNCTIONS is

  protecting CONFIG .
  protecting CONVERSION .

  *** Check if a message is in the queue.
  op inqueue  : Label MMsg -> Bool .

  op enabledGuard : Guard   Subst MMsg -> Bool .
  op enabled      : StmList Subst MMsg -> Bool . *** eval guard 
  op ready        : StmList Subst MMsg -> Bool . *** eval guard 

  vars N N' : Nat .
  vars L L' : Label .
  vars E E' : Expr .
  var EL : ExprList .
  var A : Aid .
  var Q : Qid .
  vars G1 G2 : Guard .
  var S : Subst .
  var MM : MMsg .
  var C : Cid .

  *** Create a new fresh name for an object.
  op newId : Cid Nat -> Oid .
  eq newId(C, N)  = ob(qid(string(C) + string(N,10))) .

  eq inqueue(L, noMsg) = false .
  eq inqueue(L, comp(L', EL) + MM) = 
     if L == L' then true else inqueue(L, MM) fi .

  eq enabledGuard(noGuard, S, MM)   = true .
  eq enabledGuard(wait, S, MM)      = false .       *** Note: no wait in PrQ!
  eq enabledGuard(E, S, MM)         = eval(E, S) asBool .
  eq enabledGuard((A ??), S, MM)     = inqueue(S[A], MM) .
  eq enabledGuard((L ??), S, MM)     = inqueue(L, MM) .

  vars  ST ST' : Stm . 
  vars SL SL' : StmList . 
  var NeSL : NeStmList .

  eq enabled(SL [] SL',  S, MM) = enabled(SL, S, MM) or enabled(SL', S, MM) .
  eq enabled(SL ||| SL', S, MM) = enabled(SL, S, MM) or enabled(SL', S, MM) .
  eq enabled(await G1,   S, MM) = enabledGuard(G1,S,MM) .
  eq enabled((ST ; ST' ; SL),S, MM) = enabled(ST, S, MM) . 
  eq enabled(ST,    S, MM) = true [owise] . 

  eq ready(SL [] SL',  S, MM) = ready(SL, S, MM) or ready(SL', S, MM) .
  eq ready(SL ||| SL', S, MM) = ready(SL, S, MM) or ready(SL', S, MM) .
  eq ready(A ?(E),     S, MM) = inqueue(S[A], MM) . 
  eq ready(L ?(E),     S, MM) = inqueue(L, MM) . 
  eq ready((ST ; ST' ; SL), S, MM) = ready(ST, S, MM) . 
  eq ready(ST,         S, MM) = enabled(ST, S, MM) [owise] .

endfm

eof
