***
*** Signature of Creol programs
***
*** Copyright (c) 2007
***
*** The purpose of this file is to create the files `prelude.creol'
*** and `modelcheck.creol'.  These files have to be processed with
*** m4, with either one of `CREOL' or `MODELCHECK' defined.
***
*** This program is free software; you can redistribute it and/or
*** modify it under the terms of the GNU General Public License as
*** published by the Free Software Foundation; either version 2 of the
*** License, or (at your option) any later version.
***
*** This program is distributed in the hope that it will be useful, but
*** WITHOUT ANY WARRANTY; without even the implied warranty of
*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*** General Public License for more details.
***
*** You should have received a copy of the GNU General Public License
*** along with this program; if not, write to the Free Software
*** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
*** 02111-1307, USA.
***

view Aid from TRIV to CREOL-DATA-SIG is
  sort Elt to Aid .
endv

view Data from TRIV to CREOL-DATA-SIG is
  sort Elt to Data .
endv


*** Bound variables ***
fmod SUBST is
  protecting CREOL-DATA-SIG .
  protecting MAP{Aid, Data} * (sort Map{Aid, Data} to Subst) .

  op dom : Aid Subst -> Bool .

  *** Non-comm composition operator for substitutions
  op _#_ : Subst Subst -> Subst .


  vars A A' : Aid . var D : Data . vars S1 S2  : Subst .

  eq S1 # empty = S1 .
  eq S1 # ((A |-> D), S2) = insert(A,D,S1) # S2 .

  eq dom(A, empty) = false .
  eq dom(A, ((A' |-> D), S1)) = if A == A' then true else dom(A, S1) fi .
  eq dom(A, S1 # S2) = dom(A, S1) or dom(A, S2) .
endfm

fmod EVAL is
  protecting DATATYPES .
  protecting SUBST .

  op eval     : Data Subst     -> Data .
  op eval     : Expr Subst     -> Data .
  op evalList : DataList Subst -> DataList .
  op evalList : ExprList Subst -> DataList .

  var D : Data .
  var DL : DataList .
  vars E E' : Expr .
  var EL : ExprList .
  var A : Aid .
  var S : Subst .
  var Q : Qid .
  var I : Int .
  var B : Bool .

  eq eval(D, S) = D .
  eq eval(A, S) =  S [A] .

  *** standard evaluation of expression
  eq eval(pair(E,E'),S) = pair(eval(E,S),eval(E',S)) .
  eq eval(list(EL), S)  = list(evalList(EL, S)) .
  eq eval(setl(EL), S)  = setl(evalList(EL, S)) .
  eq eval(Q [[EL]], S)  = Q [[ evalList(EL, S) ]] .

  eq evalList(emp, S)   = emp .
  eq evalList(DL, S)= DL .
  eq evalList(E # EL, S)= eval(E, S) # evalList(EL, S) .

endfm


fmod GUARDS is
  protecting EVAL .

  sorts     NoGuard Guard Wait Return PureGuard . 
  subsorts  Return Expr < PureGuard .
  subsorts  NoGuard Wait PureGuard < Guard .

  op noGuard : -> NoGuard [ctor] . 
  op wait :    -> Wait [ctor] .           *** suspension
  op _?  : Aid -> Return [ctor] .         *** reply guard
  op _?  : Label -> Return [ctor] .       *** low level reply guard
  op _&_ : Guard Guard -> Guard [ctor id: noGuard assoc comm prec 55] .
  op _&_ : PureGuard PureGuard -> PureGuard [ditto] .

  *** reduction of guards to normalform: [wait &]? [bool &]? return ***
  vars E  E' : Expr . var PG : PureGuard .
  eq   wait & wait = wait .
  eq   PG   & PG   = PG .
  eq   E    & E'   = 'and[[E # E']] .

endfm

fmod STATEMENTS is
  pr GUARDS .

  sorts Mid Cid Stm .             *** Mid = method identifiers
  subsort Qid < Mid Cid .         *** Cid = class identifiers

  op _._   : Expr Mid -> Mid [ctor prec 33] .
  op _@_   : Qid  Cid -> Mid [ctor prec 33] .
  *** op _@_   : Aid  Cid -> Aid [ctor] . *** attribute qualified by class name (local)

  *** CREOL program syntax
  op skip : -> Stm [ctor] .
  op _::=_  : AidList ExprList -> Stm [ctor prec 39] .

  op _::= new_(_) : Aid Cid ExprList -> Stm [ctor prec 39 format (d b d o d d d d)] .
  op _(_;_) : Mid ExprList AidList -> Stm [ctor prec 37] .
  op !_(_)  : Mid ExprList -> Stm [ctor] .           *** async. call (without label)
  op _!_(_) : Qid Mid ExprList -> Stm [ctor] .       *** async. call (with label)
  op _?(_)  : Qid AidList -> Stm [ctor] .           *** async. reply statement
  op _?(_)  : Label AidList -> Stm [ctor] .         *** sync reply
  op cont : Label -> Stm [ctor] .                    *** sync. scheduling
  op await_ : Guard    -> Stm [ctor] .               *** guard statements
  op return : ExprList -> Stm [ctor] .               *** method return
  op free : AidList -> Stm [ctor] .                  *** deallocation for labels
endfm

view Stm from TRIV to STATEMENTS is
   sort Elt to Stm .
endv

fmod STM-LIST is
  pr STATEMENTS .                
  protecting LIST{Stm} * (sort List{Stm} to StmList,
                          sort NeList{Stm} to NeStmList) .

  op if_th_el_fi : Expr StmList StmList -> Stm [ctor] . 
  op if_th_fi    : Expr StmList -> Stm [ctor] . 
  op while_do_od : Expr StmList -> Stm [ctor] .
  op _[]_  : StmList StmList -> Stm [ctor comm assoc prec 43] .
  op _|||_ : StmList StmList -> Stm [ctor comm assoc prec 45] .
  op _MERGER_  : StmList StmList -> Stm [assoc] .
  op _;_ :   StmList StmList -> StmList [ctor assoc id: nil prec 41] .

  var SL : StmList .  *** note: SL matches also empty
  var NeSL : NeStmList .
  var EL : ExprList .
  var B : Expr .
  var R : Return .
  var PG : PureGuard .

  *** Some simplifications:
  eq await noGuard ; NeSL = NeSL . *** could be SL
  ***  eq skip ; SL = SL . *** may affect ||| order 
  eq (nil []  SL)  = SL . 
  eq (nil ||| SL)  = SL . 
  eq (nil MERGER SL)      = SL .
  eq (SL MERGER nil)      = SL .

  eq await (wait & PG) = await wait ; await PG .
  *** eq await (R & PG)= await R ; await PG . --- could be rule for confluence!

  eq if B th SL fi = if B th SL el nil fi .  *** compiler stuff

  sorts Process NeMProc MProc .
  subsort Process < NeMProc < MProc .    *** Multiset of Processes
  op noProc : -> MProc [ctor] .
  op _++_ : NeMProc MProc -> NeMProc [ctor assoc comm id: noProc] .
  op _++_ : MProc NeMProc -> NeMProc [ctor assoc comm id: noProc] .
  op _++_ : MProc MProc   -> MProc   [ctor assoc comm id: noProc] .

  *** A Process is a pair of Prog and bound variables ***
  op idle : -> Process [format (!b o)] .  
  op _,_ : Subst StmList -> Process [ctor format (o r nb o)] . 
  var L : Subst .
  eq (L, nil) = idle . *** if 'label is needed this is dangerous!
  **** eq idle = (empty, nil).  *** may use in right hand sides, but not left.

endfm

*** CREOL classes ***
fmod CLASS is
  protecting STM-LIST .

  sorts    Class Mtd MMtd Inh InhList . *** inheritance list
  subsorts Inh < Expr .  
  subsorts Inh < InhList .

  op  _<_> : Cid  ExprList -> Inh .     *** initialised superclass
  op noInh : -> InhList [ctor] .
  op  _##_   : InhList InhList -> InhList [ctor assoc id: noInh] .

  var Ih : Inh . 
  var IL : InhList .
  var S : Subst . 
  var SL : StmList . 
  vars Q Q' : Qid . 
  var MM : MMtd .
  var EL : ExprList .
  var O : Oid .
  var N : Nat .
  var AL : AidList .

  eq  Ih ## IL ## Ih = Ih ## IL .

  op <_: Mtdname | Param:_, Latt:_, Code:_> : 
    Qid AidList Subst StmList -> Mtd [ctor
      format (g! g o o o g o o g o o g o g o)] .

  subsort Mtd < MMtd .    *** Multiset of methods

  op noMtd : -> Mtd [ctor] .
  op _*_  : MMtd MMtd -> MMtd [ctor assoc comm id: noMtd format (o o on o)] .

  op <_: Cl | Inh:_, Par:_, Att:_, Mtds:_, Ocnt:_> : 
    Cid InhList AidList Subst MMtd Nat -> Class 
     [format (nb! b o o o b o o  b o o  b o o  b on o  b o  b! on )] .

  op emptyClass : -> Class .
  eq emptyClass =
    < 'noClass : Cl | Inh: noInh , Par: noAid, Att: empty, Mtds: noMtd ,
      Ocnt: 0 > .

  *** Class/method functions ***
  op get : Qid MMtd Oid Label ExprList -> Process .  *** fetches pair (code, vars)
  op _in_ : Qid MMtd -> Bool .  *** checks if Q is a declared 
                                *** method in the method multiset

  eq Q in noMtd = false .
  eq Q in (< Q' : Mtdname | Param: AL, Latt: S, Code: SL > * MM) = 
       if (Q == Q') then true else (Q in MM) fi .

  *** bind call to process
  var Lab : Label .
  eq get(Q, noMtd, O, Lab, EL) = noProc . 
  eq get(Q, < Q' : Mtdname | Param: AL, Latt: S, Code: SL > * MM, O, Lab, EL) = 
    if Q == Q' 
    then (insert('caller, O, insert('label, Lab, S)), (AL ::= EL) ; SL)
    else get(Q, MM, O, Lab, EL) fi .

endfm

*** CREOL objects ***
fmod OBJECT is
  protecting CLASS .

  sort Object .

  op <_:_ | Att:_, Pr:_, PrQ:_, Lcnt:_> : 
       Oid Cid Subst Process MProc Nat -> Object 
         [ctor format (nr! r o o o  r o r  r o r r o r r o r! no)] .

  op noObj : -> Object [ctor] .

endfm

*** CREOL messages and queues ***
fmod COMMUNICATION is
  protecting OBJECT .

  sort Labels . *** list of labels
  subsort Label < Labels .

  sorts Body Msg MMsg Kid Queue .
  subsort Body < MMsg .

  op noMsg : -> Body [ctor] .
  op _+_ : MMsg MMsg -> MMsg [ctor assoc comm id: noMsg] . 

  *** INVOCATION and REPLY
  op invoc(_,_,_,_) : *** Nat Oid 
  Oid Label Mid ExprList -> Body [ctor                     *** invocation
        format (! o o o o o o o o o o)] .  
  op comp(_,_) : Label ExprList -> Body [ctor              *** completion
        format (! o o o o o o)] .  

  op _from_to_ : Body Oid Oid -> Msg [ctor format (o ! o ! o on)] .
  op error(_) : String -> [Msg] [ctor format (nnr r o! or onn)] .     *** error 
  op warning(_) : String -> [Msg] [ctor format (nnr! r! r! or onn)] .   *** warning 

  *** Method binding messages
  op bindMtd : Oid Oid Label Qid ExprList InhList -> Msg [ctor] . 
  ***Bind method request
  *** Given: caller callee method params (list of classes to look in)
  op boundMtd(_,_) : Oid Process -> Msg 
    [ctor format (!r r o o o !r on)] . *** binding result
  *** CONSIDER the call O.Q(I). bindMtd(O,Q,I,C S) trie to find Q in
  *** class C or superclasses, then in S. boundMtd(O,Mt) is the result.


  *** message queue
  op noDealloc :         -> Labels  [ctor] .
  op _^_ : Labels Labels -> Labels [ctor comm assoc id: noDealloc] .

  op noQu : -> Queue [ctor] .
  op <_: Qu | Dealloc:_, Ev:_ > : Oid Labels MMsg -> Queue 
                          [format (nm! m o o o  m o o m o m! no)] . 

endfm

*** STATE CONFIGURATION ***
fmod CONFIG is
  protecting OBJECT .
  protecting COMMUNICATION .

  sort Configuration .

  subsorts Object Msg Queue Class < Configuration .

  op noConf : -> Configuration [ctor] .
  op __ : Configuration Configuration -> Configuration [ctor assoc comm id: noConf] .
  op main : Cid ExprList -> Configuration .

  var C : Cid . var E : ExprList .
  eq main(C,E) = < ob('main) : 'class | Att: empty, 
                 Pr: (empty, ('var ::= new C(E))), PrQ: noProc, Lcnt: 0 > 
               < ob('main) : Qu | Dealloc: noDealloc,Ev: noMsg > .

endfm

*** AUXILIARY FUNCTIONS ***
fmod AUX-FUNCTIONS is

  protecting CONFIG .
  protecting CONVERSION .

  *** Check if a message is in the queue.
  op inqueue  : Label MMsg -> Bool .

  op enabledGuard : Guard   Subst MMsg -> Bool .
  op enabled      : StmList Subst MMsg -> Bool . *** eval guard 
  op ready        : StmList Subst MMsg -> Bool . *** eval guard 

  vars N N' : Nat .
  vars L L' : Label .
  vars E E' : Expr .
  var EL : ExprList .
  var A : Aid .
  var Q : Qid .
  vars G1 G2 : Guard .
  var S : Subst .
  var MM : MMsg .
  var C : Cid .

  *** Create a new fresh name for an object.
  op newId : Cid Nat -> Oid .
  eq newId(C, N)  = ob(qid(string(C) + string(N,10))) .

  eq inqueue(L, noMsg) = false .
  eq inqueue(L, comp(L', EL) + MM) = 
     if L == L' then true else inqueue(L, MM) fi .

  eq enabledGuard(noGuard, S, MM)   = true .
  eq enabledGuard(wait, S, MM)      = false .       *** Note: no wait in PrQ!
  eq enabledGuard(E, S, MM)         = eval(E, S) asBool .
  eq enabledGuard((A ?), S, MM)     = inqueue(S[A], MM) .
  eq enabledGuard((L ?), S, MM)     = inqueue(L, MM) .

  vars  ST ST' : Stm . 
  vars SL SL' : StmList . 
  var NeSL : NeStmList .

  eq enabled(SL [] SL',  S, MM) = enabled(SL, S, MM) or enabled(SL', S, MM) .
  eq enabled(SL ||| SL', S, MM) = enabled(SL, S, MM) or enabled(SL', S, MM) .
  eq enabled(await G1,   S, MM) = enabledGuard(G1,S,MM) .
  eq enabled((ST ; ST' ; SL),S, MM) = enabled(ST, S, MM) . 
  eq enabled(ST,    S, MM) = true [owise] . 

  eq ready(SL [] SL',  S, MM) = ready(SL, S, MM) or ready(SL', S, MM) .
  eq ready(SL ||| SL', S, MM) = ready(SL, S, MM) or ready(SL', S, MM) .
  eq ready(A ?(E),     S, MM) = inqueue(S[A], MM) . 
  eq ready(L ?(E),     S, MM) = inqueue(L, MM) . 
  eq ready((ST ; ST' ; SL), S, MM) = ready(ST, S, MM) . 
  eq ready(ST,         S, MM) = enabled(ST, S, MM) [owise] .

endfm

eof
