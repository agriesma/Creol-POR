
view Aid from TRIV to DATA is
   sort Elt to Aid .
endv

view Data from TRIV to DATA is
   sort Elt to Data .
endv


*** Bound variables ***
fmod SUBST is
*** protecting META-LEVEL .
protecting DATATYPES .
protecting MAP{Aid, Data} * (sort Map{Aid, Data} to Subst) .

op noSub : -> Subst .
eq noSub = (empty).Subst .

op dom : Aid Subst -> Bool .

*** Non-comm composition operator for substitutions
op _#_ : Subst Subst -> Subst .


vars A A' : Aid . var D : Data . vars S1 S2  : Subst .

eq S1 # empty = S1 .
eq S1 # ((A |-> D), S2) = insert(A,D,S1) # S2 .

eq dom(A, empty) = false .
eq dom(A, ((A' |-> D), S1)) = if A == A' then true else dom(A, S1) fi .
eq dom(A, S1 # S2) = dom(A, S1) or dom(A, S2) .

***  eq element(E, emp) = false .
***  eq element(E, E' # L) = if E == E' then true else element(E, L) fi .

*** red insert('var1, str("test"), noSub) .
*** red insert('var2, int(4), insert('var1, str("test"), noSub)) .
*** red insert('var2, int(4), insert('var1, str("test"), noSub)) ['var1] .
*** red upTerm(insert('var1, str("test"), noSub)) .
*** red downTerm(upTerm(insert('var1, str("test"), noSub)),noSub) .
*** red downTerm(upTerm(insert('var2, int(4), insert('var1, str("test"), noSub)) ['var1]), null) .
*** red dom('var1, insert('var2, int(4), insert('var1, str("test"), noSub))) .
endfm

fmod EVAL is
protecting SUBST . 

*** Evaluation of expressions
op eval	    : Expr Subst     -> Data .     *** evaluate expression
op evalB    : Expr Subst     -> Bool .
op evalI    : Expr Subst     -> Int .
op evalN    : Expr Subst     -> Nat .
op evalS    : Expr Subst     -> String .
op evalList : DataList Subst -> ExprList . *** maps list to values

*** Variables
vars E E' : Expr .    var EL : ExprList .     var D : Data .
var A : Aid .         var S : Subst .         var Q : Qid .
var I : Int .         var B : Bool .          var STR : String .

eq eval(A, S) = S [A] .
eq eval(D, S) = D .                                *** data

eq evalI(E,S) = eval(E,S) asInt .                  *** expressions
eq evalN(E,S) = eval(E,S) asNat .                  *** expressions
eq evalB(E,S) = eval(E,S) asBool .                 *** expressions
eq evalS(E,S) = eval(E,S) asStr .                  *** expressions

*** standard evaluation of expression
eq eval(pair(E,E'),S) = pair(eval(E,S),eval(E',S)) . 
eq eval(list(EL), S)  = list(evalList(EL, S)) .       
eq eval(setl(EL), S)  = setl(evalList(EL, S)) .   
eq eval(Q [[EL]], S)  = Q [[ evalList(EL, S) ]] .   

*** lists  
eq evalList(emp, S)   = emp .
eq evalList(E # EL, S)= eval(E, S) # evalList(EL, S) .
            *** creol function Q defined directly by functions
*** eq evalList(E, S)   = eval(E, S) . *** not needed

endfm


fmod GUARDS is
protecting EVAL .

sorts     NoGuard Guard Wait Return PureGuard . 
subsorts  Return Expr < PureGuard .
subsorts  NoGuard Wait PureGuard < Guard .

op noGuard : -> NoGuard [ctor] . 
op wait :    -> Wait [ctor] .           *** suspension
op _?  : Aid -> Return [ctor] .         *** reply guard
op _?  : Nat -> Return [ctor] .         *** low level reply guard
op _&_ : Guard Guard -> Guard [ctor id: noGuard assoc comm prec 55] .
op _&_ : PureGuard PureGuard -> PureGuard [ditto] .

*** reduction of guards to normalform: [wait &]? [bool &]? return ***
vars E  E' : Expr . var PG : PureGuard .
eq   wait & wait = wait .
eq   PG   & PG   = PG .
eq   E    & E'   = 'and[[E # E']] .

*** red int(4) & int(5) .
*** red upTerm(int(4) & int(5)) .
*** red upTerm(int(4) & int(5) & wait) .
*** red downTerm(upTerm(int(4) & int(5) & wait), noGuard) .
*** red 'test ? .
*** red int(4) add int(5) & 'label ? & wait & bool(true) & wait .
*** red upTerm(int(4) add int(5) & 'label ? & wait & bool(true) & wait) .
*** red downTerm(upTerm(int(4) add int(5) & 'label ? & wait & bool(true) & wait), noGuard) .
endfm

fmod STATEMENTS is
pr GUARDS .

sorts Mid Cid Stm .             *** Mid = method identifiers
subsort Qid < Mid Cid .         *** Cid = class identifiers

op _._   : Expr Mid -> Mid [ctor] . *** remote call
op _@_   : Qid  Cid -> Mid [ctor] . *** method qualified by class name (local)
*** op _@_   : Aid  Cid -> Aid [ctor] . *** attribute qualified by class name (local)

*** CREOL program syntax
op skip : -> Stm [ctor] .
op _::=_  : AidList ExprList -> Stm [ctor] .       *** simple assignment
op _::= new_(_) : Aid Cid ExprList -> Stm [ctor] . *** object creation
op _(_;_) : Mid ExprList AidList -> Stm [ctor] .   *** sync. call
op !_(_)  : Mid ExprList -> Stm [ctor] .           *** async. call (without label)
op _!_(_) : Aid Mid ExprList -> Stm [ctor] .       *** async. call (with label)
op _?(_)  : Aid AidList -> Stm [ctor] .            *** async. reply statement
op _?(_)  : Nat AidList -> Stm [ctor] .            *** sync reply
op cont : Nat -> Stm [ctor] .                      *** sync. scheduling
op await_ : Guard    -> Stm [ctor] .               *** guard statements
op return : ExprList -> Stm [ctor] .               *** method return
op free : AidList -> Stm [ctor] .                  *** deallocation for labels
*** red 'var ::= int(4) .
*** red 'var ::= new 'C (int(5) # bool(true)) .
*** red upTerm('var ::= new 'C (null)) .
*** red downTerm(upTerm('var ::= new 'C (int(5) # bool(true))), skip) .
*** red await 'test ? .
*** red await (('test ?) & wait) .
*** red downTerm(upTerm(await (('test ?) & wait)), skip) .
*** red ! 'method (null) .
*** red cont (5) .
*** red downTerm(upTerm(cont (5)),skip) .
*** red downTerm(upTerm('getNeighbor(null ; null)), skip) .
*** red 'label ! ('oid . 'mtd) (noExpr) .
*** red downTerm(upTerm('label ! ('oid . 'mtd) (noExpr)), skip) .
endfm

view Stm from TRIV to STATEMENTS is
   sort Elt to Stm .
endv

fmod STM-LIST is
pr STATEMENTS .                
protecting LIST{Stm} * (sort List{Stm} to StmList,
                        sort NeList{Stm} to NeStmList) .

op if_th_el_fi : Expr StmList StmList -> Stm [ctor] . 
op if_th_fi    : Expr StmList -> Stm [ctor] . 
op while_do_od : Expr StmList -> Stm [ctor] .
op _[]_  : StmList StmList -> Stm [ctor comm assoc] .          *** choice
op _|||_ : StmList StmList -> Stm [ctor comm assoc] .          *** merge
op _MERGER_  : StmList StmList -> Stm [assoc] .                *** aux merge
op _;_ :   StmList StmList -> StmList [ctor assoc id: nil] . *** seq. comp.

var SL : StmList .  *** note: SL matches also empty
var NeSL : NeStmList .
var EL : ExprList .
var B : Expr .
var R : Return .
var PG : PureGuard .

*** Some simplifications:
eq await noGuard ; NeSL = NeSL . *** could be SL
***  eq skip ; SL = SL . *** may affect ||| order 
eq (nil []  SL)  = SL . 
eq (nil ||| SL)  = SL . 
eq (nil MERGER SL)      = SL .
eq (SL MERGER nil)      = SL .
*** eq (noAid ::= EL); SL   = SL .
eq (noAid ::= EL)  = skip .

eq await (wait & PG) = await wait ; await PG .
*** eq await (R & PG)= await R ; await PG . --- could be rule for confluence!

eq if B th SL fi = if B th SL el nil fi .  *** compiler stuff

*** red ('var ::= int(4)) [] ('var ::= new 'C (null)) .
*** red downTerm(upTerm(('var ::= int(4)) [] ('var ::= new 'C (null))), skip) .
*** red (('var ::= int(4)) [] ('var ::= new 'C (null))) ||| skip .
*** red downTerm(upTerm((('var ::= int(4)) [] ('var ::= new 'C (null))) ||| skip),skip) .
*** red (('var ::= int(4)) [] ('var ::= new 'C (null))) ||| empty ||| skip .
*** red downTerm(upTerm((('var ::= int(4)) [] ('var ::= new 'C (null))) ||| emp ||| skip), skip) .
*** red downTerm(upTerm((('var ::= int(4)) [] ('var ::= new 'C (null))) ||| nil ||| skip), nil) .

sorts Process NeMProc MProc .
subsort Process < NeMProc < MProc .    *** Multiset of Processes
op noProc : -> MProc [ctor] .
op _++_ : NeMProc MProc -> NeMProc [ctor assoc comm id: noProc] .
op _++_ : MProc NeMProc -> NeMProc [ctor assoc comm id: noProc] .
op _++_ : MProc MProc   -> MProc   [ctor assoc comm id: noProc] .

*** A Process is a pair of Prog and bound variables ***
op idle : -> Process [format (!b o)] .  
op _,_ : Subst StmList -> Process [ctor format (o r nb o)] . 
var L : Subst .
eq (L, nil) = idle . *** if 'label is needed this is dangerous!
**** eq idle = (noSub, nil).  *** may use in right hand sides, but not left.

*** red ((('var ::= int(4)) [] ('var ::= new 'C (null))) ||| skip), insert('var2, int(4), insert('var1, str("test"), noSub)) .
*** red upTerm(((('var ::= int(4)) [] ('var ::= new 'C (null))) ||| skip), insert('var2, int(4), insert('var1, str("test"), noSub))) .
*** red downTerm(upTerm(((('var ::= int(4)) [] ('var ::= new 'C (null))) ||| skip), insert('var2, int(4), insert('var1, str("test"), noSub))), idle ) .

*** red (((('var ::= int(4)) [] ('var ::= new 'C (null))) ||| skip), insert('var2, int(4), insert('var1, str("test"), noSub))) ++ idle .

*** red (('var := bool(true)), noSub) .
endfm

*** CREOL classes ***
fmod CLASS is
protecting STM-LIST .

sorts    Class Mtd MMtd Inh InhList . *** inheritance list
subsorts Inh < Expr .  
subsorts Inh < InhList .

op  _<_> : Cid  ExprList -> Inh .     *** initialised superclass
op noInh : -> InhList [ctor] .
op  _##_   : InhList InhList -> InhList [ctor assoc id: noInh] .

var Ih : Inh . 
var IL : InhList .
var S : Subst . 
var SL : StmList . 
vars Q Q' : Qid . 
var MM : MMtd .
var EL : ExprList .
var O : Oid .
var N : Nat .
var AL : AidList .

eq  Ih ## IL ## Ih = Ih ## IL .

op <_: Mtdname | Param:_, Latt:_, Code:_> : 
    Qid AidList Subst StmList -> Mtd [ctor
      format (g! g o o o g o o g o o g o g o)] .

subsort Mtd < MMtd .    *** Multiset of methods

op noMtd : -> Mtd [ctor] .
op _*_  : MMtd MMtd -> MMtd [ctor assoc comm id: noMtd format (o o on o)] .

op <_: Cl | Inh:_, Par:_, Att:_, Mtds:_, Ocnt:_> : 
    Cid InhList AidList Subst MMtd Nat -> Class 
   [format (b! b o o o b o o  b o o  b o o  b on o  b o  b! o )] .

op emptyClass : -> Class .
eq emptyClass = < 'noClass : Cl | Inh: noInh , Par: noAid, Att: noSub , Mtds: noMtd , Ocnt: 0 > .

*** Class/method functions ***
op get : Qid MMtd Oid Nat ExprList -> Process .  *** fetches pair (code, vars)
op _in_ : Qid MMtd -> Bool .  *** checks if Q is a declared 
                              *** method in the method multiset

eq Q in noMtd = false .
eq Q in (< Q' : Mtdname | Param: AL, Latt: S, Code: SL > * MM) = 
     if (Q == Q') then true else (Q in MM) fi .

*** bind call to process
eq get(Q, noMtd, O, N, EL) = noProc . 
eq get(Q, < Q' : Mtdname | Param: AL, Latt: S, Code: SL > * MM, O, N, EL) = 
    if Q == Q' 
    then (insert('caller, O, insert('label, int(N), S)), (AL ::= EL) ; SL)
    else get(Q, MM, O, N, EL) fi .

*** insert('caller, O, insert('label, int(N), S))
*** 'caller |-> O, 'label |-> int(N))

*** red < 'getNeighbor : Mtdname | 
***           Latt: ('label |-> null, 'caller |-> null, 'n |-> null), Code: skip > .

*** red < 'Butler : Cl | Inh: noInh , Att: noSub , Mtds: noMtd , Ocnt: 0 > .
*** red ('butler . 'getNeighbor)(noExpr ; noExpr) .
*** red ('butler ! 'getNeighbor(noExpr)) .
*** red ('run(noExpr ; noExpr)) # ('run(noExpr ; noExpr)) .
*** red ('butler ! 'getNeighbor(noExpr)) # ('run(noExpr ; noExpr)) .
endfm

*** CREOL objects ***
fmod OBJECT is
protecting CLASS .

sort Object .

op <_:_ | Att:_, Pr:_, PrQ:_, Lcnt:_> : 
       Oid Cid Subst Process MProc Nat -> Object 
         [ctor format (r! r o o o  r o r  r o r r o r r o r! o)] .

op noObj : -> Object [ctor] .

*** red < 'object1 : 'class | Att: noSub, Pr: idle, PrQ: noProc, Lcnt: 0 > .
*** red downTerm(upTerm(< 'object1 : 'class | Att: noSub, Pr: idle, PrQ: idle, Lcnt: 0 >), noObj) .

endfm

*** CREOL messages and queues ***
fmod COMMUNICATION is
protecting OBJECT .

sort NatS . *** list of nats
subsort Nat < NatS .

sorts Body Msg MMsg Kid Queue .
subsort Body < MMsg .

op noMsg : -> Body [ctor] .
op _+_ : MMsg MMsg -> MMsg [ctor assoc comm id: noMsg] . 

*** INVOCATION and REPLY
op invoc(_,_,_,_) : *** Nat Oid 
Oid Nat Mid ExprList -> Body [ctor                     *** invocation
      format (! o o o o o o o o o o)] .  
op comp(_,_) : Nat DataList -> Body [ctor              *** completion
      format (! o o o o o o)] .  

op _from_to_ : Body Oid Oid -> Msg [ctor format (o ! o ! o on)] .
op error(_) : String -> Msg [ctor format (nnr r o! or onn)] .     *** error 
op warning(_) : String -> Msg [ctor format (nnr! r! r! or onn)] .   *** warning 

*** Method binding messages
op bindMtd : Oid Oid Nat Qid ExprList InhList -> Msg [ctor] . 

*** Bind method request
*** Given: caller callee method params (list of classes to look in)

op boundMtd(_,_) : Oid Process -> Msg 
    [ctor format (!r r o o o !r on)] . *** binding result
*** CONSIDER the call O.Q(I). bindMtd(O,Q,I,C S) trie to find Q in
*** class C or superclasses, then in S. boundMtd(O,Mt) is the result.


*** message queue
op noDealloc :         -> NatS  [ctor] .
*** op [_] : Nat       -> NatS  [ctor].
op _;_ : NatS NatS -> NatS [ctor comm assoc id: noDealloc] .

op noQu : -> Queue [ctor] .
op <_: Qu | Dealloc:_, Ev:_ > : Oid NatS MMsg -> Queue 
                          [format (nm! m o o o  m o o m o m! no)] . 

*** red noMsg .
*** red comp(5, noExpr) .
*** red invoc('object1, 5, 'method1, noExpr) .
*** red upTerm(comp(5, noExpr)) .
*** red downTerm(upTerm(comp(5, noExpr)), noMsg) .
*** red upTerm(invoc('object1, 5, 'method1, noExpr)) .
*** red downTerm(upTerm(invoc('object1, 5, 'method1, noExpr)), noMsg) .
*** red < 'Ob1 : Qu | Dealloc: noDealloc , Ev: noMsg > .
*** red upTerm(< 'Ob1 : Qu | Dealloc: noDealloc , Ev: noMsg >) .
*** red downTerm(upTerm(< 'Ob1 : Qu | Dealloc: noDealloc, Ev: noMsg >), noQu) .
endfm

*** STATE CONFIGURATION ***
fmod CONFIG is
protecting OBJECT .
protecting COMMUNICATION .

sort Configuration .

subsorts Object Msg Queue Class < Configuration .

op noConf : -> Configuration [ctor] .
op __ : Configuration Configuration -> Configuration
  [ctor assoc comm id: noConf format (d nn d) ] .
op main : Cid ExprList -> Configuration .

var C : Cid . var E : ExprList .

eq main(C,E) = < ob('main) : 'class | Att: noSub, 
                 Pr: (noSub, ('var ::= new C(E))) , PrQ: noProc, Lcnt: 0 > 
               < ob('main) : Qu | Dealloc: noDealloc,Ev: noMsg > .

endfm
