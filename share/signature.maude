***
*** Signature of Creol programs
***
*** Copyright (c) 2007
***
*** The purpose of this file is to create the files `prelude.creol'
*** and `modelcheck.creol'.  These files have to be processed with
*** m4, with either one of `CREOL' or `MODELCHECK' defined.
***
*** This program is free software; you can redistribute it and/or
*** modify it under the terms of the GNU General Public License as
*** published by the Free Software Foundation; either version 2 of the
*** License, or (at your option) any later version.
***
*** This program is distributed in the hope that it will be useful, but
*** WITHOUT ANY WARRANTY; without even the implied warranty of
*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*** General Public License for more details.
***
*** You should have received a copy of the GNU General Public License
*** along with this program; if not, write to the Free Software
*** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
*** 02111-1307, USA.
***

view Aid from TRIV to DATA is
   sort Elt to Aid .
endv

view Data from TRIV to DATA is
   sort Elt to Data .
endv


*** Bound variables ***
fmod SUBST is
  protecting DATATYPES .
  protecting MAP{Aid, Data} * (sort Map{Aid, Data} to Subst) .

  op noSub : -> Subst .
  eq noSub = (empty).Subst .

  op dom : Aid Subst -> Bool .

  *** Non-comm composition operator for substitutions
  op _#_ : Subst Subst -> Subst .


  vars A A' : Aid . var D : Data . vars S1 S2  : Subst .

  eq S1 # empty = S1 .
  eq S1 # ((A |-> D), S2) = insert(A,D,S1) # S2 .

  eq dom(A, empty) = false .
  eq dom(A, ((A' |-> D), S1)) = if A == A' then true else dom(A, S1) fi .
  eq dom(A, S1 # S2) = dom(A, S1) or dom(A, S2) .
endfm

fmod EVAL is
  protecting SUBST .

  op eval     : Data Subst     -> Data .
  op eval     : Expr Subst     -> Data .
  op evalB    : Expr Subst     -> Bool .
  op evalI    : Expr Subst     -> Int .
  op evalS    : Expr Subst     -> String .
  op evalList : ExprList Subst -> DataList .

  *** Variables
  vars E E' : Expr .    var EL : ExprList .     var D : Data .
  var A : Aid .         var S : Subst .         var Q : Qid .
  var I : Int .         var B : Bool .

  eq eval(D, S) = D .
  eq eval(A, S) = S [A] .

  eq evalI(E,S) = eval(E,S) asInt .
  eq evalB(E,S) = eval(E,S) asBool .
  eq evalS(E,S) = eval(E,S) asStr .

  *** standard evaluation of expression
  eq eval(pair(E,E'),S) = pair(eval(E,S),eval(E',S)) .
  eq eval(list(EL), S)  = list(evalList(EL, S)) .
  eq eval(setl(EL), S)  = setl(evalList(EL, S)) .
  eq eval(Q [[EL]], S)  = Q [[ evalList(EL, S) ]] .

  *** lists
  eq evalList(emp, S)   = emp .
  eq evalList(E # EL, S)= eval(E, S) # evalList(EL, S) .

endfm


fmod GUARDS is
  protecting EVAL .

  sorts     NoGuard Guard Wait Return PureGuard . 
  subsorts  Return Expr < PureGuard .
  subsorts  NoGuard Wait PureGuard < Guard .

  op noGuard : -> NoGuard [ctor] . 
  op wait :    -> Wait [ctor] .           *** suspension
  op _?  : Aid -> Return [ctor] .         *** reply guard
  op _?  : Nat -> Return [ctor] .         *** low level reply guard
  op _&_ : Guard Guard -> Guard [ctor id: noGuard assoc comm prec 55] .
  op _&_ : PureGuard PureGuard -> PureGuard [ditto] .

  *** reduction of guards to normalform: [wait &]? [bool &]? return ***
  vars E  E' : Expr . var PG : PureGuard .
  eq   wait & wait = wait .
  eq   PG   & PG   = PG .
  eq   E    & E'   = 'and[[E # E']] .

endfm

fmod STATEMENTS is
pr GUARDS .

sorts Mid Cid Stm .             *** Mid = method identifiers
subsort Qid < Mid Cid .         *** Cid = class identifiers

op _._   : Expr Mid -> Mid [ctor] . *** remote call
op _@_   : Qid  Cid -> Mid [ctor] . *** method qualified by class name (local)
*** op _@_   : Aid  Cid -> Aid [ctor] . *** attribute qualified by class name (local)

*** CREOL program syntax
op skip : -> Stm [ctor] .
op _::=_  : AidList ExprList -> Stm [ctor] .       *** simple assignment
op _::= new_(_) : Aid Cid ExprList -> Stm [ctor] . *** object creation
op _(_;_) : Mid ExprList AidList -> Stm [ctor] .   *** sync. call
op !_(_)  : Mid ExprList -> Stm [ctor] .           *** async. call (without label)
op _!_(_) : Aid Mid ExprList -> Stm [ctor] .       *** async. call (with label)
op _?(_)  : Aid AidList -> Stm [ctor] .            *** async. reply statement
op _?(_)  : Nat AidList -> Stm [ctor] .            *** sync reply
op cont : Nat -> Stm [ctor] .                      *** sync. scheduling
op await_ : Guard    -> Stm [ctor] .               *** guard statements
op return : ExprList -> Stm [ctor] .               *** method return
op free : AidList -> Stm [ctor] .                  *** deallocation for labels

endfm

view Stm from TRIV to STATEMENTS is
   sort Elt to Stm .
endv

fmod STM-LIST is
pr STATEMENTS .                
protecting LIST{Stm} * (sort List{Stm} to StmList,
                        sort NeList{Stm} to NeStmList) .

op if_th_el_fi : Expr StmList StmList -> Stm [ctor] . 
op if_th_fi    : Expr StmList -> Stm [ctor] . 
op while_do_od : Expr StmList -> Stm [ctor] .
op _[]_  : StmList StmList -> Stm [ctor comm assoc] .          *** choice
op _|||_ : StmList StmList -> Stm [ctor comm assoc] .          *** merge
op _MERGER_  : StmList StmList -> Stm [assoc] .                *** aux merge
op _;_ :   StmList StmList -> StmList [ctor assoc id: nil] . *** seq. comp.

var SL : StmList .  *** note: SL matches also empty
var NeSL : NeStmList .
var EL : ExprList .
var B : Expr .
var R : Return .
var PG : PureGuard .

*** Some simplifications:
eq await noGuard ; NeSL = NeSL . *** could be SL
***  eq skip ; SL = SL . *** may affect ||| order 
eq (nil []  SL)  = SL . 
eq (nil ||| SL)  = SL . 
eq (nil MERGER SL)      = SL .
eq (SL MERGER nil)      = SL .
*** eq (noAid ::= EL); SL   = SL .
eq (noAid ::= EL)  = skip .

eq await (wait & PG) = await wait ; await PG .
*** eq await (R & PG)= await R ; await PG . --- could be rule for confluence!

eq if B th SL fi = if B th SL el nil fi .  *** compiler stuff

sorts Process NeMProc MProc .
subsort Process < NeMProc < MProc .    *** Multiset of Processes
op noProc : -> MProc [ctor] .
op _++_ : NeMProc MProc -> NeMProc [ctor assoc comm id: noProc] .
op _++_ : MProc NeMProc -> NeMProc [ctor assoc comm id: noProc] .
op _++_ : MProc MProc   -> MProc   [ctor assoc comm id: noProc] .

*** A Process is a pair of Prog and bound variables ***
op idle : -> Process [format (!b o)] .  
op _,_ : Subst StmList -> Process [ctor format (o r nb o)] . 
var L : Subst .
eq (L, nil) = idle . *** if 'label is needed this is dangerous!
eq idle = (noSub, nil) [nonexec] .  *** may use in right hand sides, but not left.

endfm

*** CREOL classes ***
fmod CLASS is
protecting STM-LIST .

sorts    Class Mtd MMtd Inh InhList . *** inheritance list
subsorts Inh < Expr .  
subsorts Inh < InhList .

op  _<_> : Cid  ExprList -> Inh .     *** initialised superclass
op noInh : -> InhList [ctor] .
op  _##_   : InhList InhList -> InhList [ctor assoc id: noInh] .

var Ih : Inh . 
var IL : InhList .
var S : Subst . 
var SL : StmList . 
vars Q Q' : Qid . 
var MM : MMtd .
var EL : ExprList .
var O : Oid .
var N : Nat .
var AL : AidList .

eq  Ih ## IL ## Ih = Ih ## IL .

op <_: Mtdname | Param:_, Latt:_, Code:_> : 
    Qid AidList Subst StmList -> Mtd [ctor
      format (g! g o o o g o o g o o g o g o)] .

subsort Mtd < MMtd .    *** Multiset of methods

op noMtd : -> Mtd [ctor] .
op _*_  : MMtd MMtd -> MMtd [ctor assoc comm id: noMtd format (o o on o)] .

op <_: Cl | Inh:_, Par:_, Att:_, Mtds:_, Ocnt:_> : 
    Cid InhList AidList Subst MMtd Nat -> Class 
   [format (b! b o o o b o o  b o o  b o o  b on o  b o  b! o )] .

op emptyClass : -> Class .
eq emptyClass = < 'noClass : Cl | Inh: noInh , Par: noAid, Att: noSub , Mtds: noMtd , Ocnt: 0 > .

*** Class/method functions ***
op get : Qid MMtd Oid Nat ExprList -> Process .  *** fetches pair (code, vars)
op _in_ : Qid MMtd -> Bool .  *** checks if Q is a declared 
                              *** method in the method multiset

eq Q in noMtd = false .
eq Q in (< Q' : Mtdname | Param: AL, Latt: S, Code: SL > * MM) = 
     if (Q == Q') then true else (Q in MM) fi .

*** bind call to process
eq get(Q, noMtd, O, N, EL) = noProc . 
eq get(Q, < Q' : Mtdname | Param: AL, Latt: S, Code: SL > * MM, O, N, EL) = 
    if Q == Q' 
    then (insert('caller, O, insert('label, int(N), S)), (AL ::= EL) ; SL)
    else get(Q, MM, O, N, EL) fi .

*** insert('caller, O, insert('label, int(N), S))
*** 'caller |-> O, 'label |-> int(N))

endfm

*** CREOL objects ***
fmod OBJECT is
protecting CLASS .

sort Object .

op <_:_ | Att:_, Pr:_, PrQ:_, Lcnt:_> : 
       Oid Cid Subst Process MProc Nat -> Object 
         [ctor format (r! r o o o  r o r  r o r r o r r o r! o)] .

op noObj : -> Object [ctor] .

endfm

*** CREOL messages and queues ***
fmod COMMUNICATION is
protecting OBJECT .

sort NatS . *** list of nats
subsort Nat < NatS .

sorts Body Msg MMsg Kid Queue .
subsort Body < MMsg .

op noMsg : -> Body [ctor] .
op _+_ : MMsg MMsg -> MMsg [ctor assoc comm id: noMsg] . 

*** INVOCATION and REPLY
op invoc(_,_,_,_) : *** Nat Oid 
Oid Nat Mid ExprList -> Body [ctor                     *** invocation
      format (! o o o o o o o o o o)] .  
op comp(_,_) : Nat DataList -> Body [ctor              *** completion
      format (! o o o o o o)] .  

op _from_to_ : Body Oid Oid -> Msg [ctor format (o ! o ! o on)] .
op error(_) : String -> Msg [ctor format (nnr r o! or onn)] .     *** error 
op warning(_) : String -> Msg [ctor format (nnr! r! r! or onn)] .   *** warning 

*** Method binding messages
op bindMtd : Oid Oid Nat Qid ExprList InhList -> Msg [ctor] . 

*** Bind method request
*** Given: caller callee method params (list of classes to look in)

op boundMtd(_,_) : Oid Process -> Msg 
    [ctor format (!r r o o o !r on)] . *** binding result
*** CONSIDER the call O.Q(I). bindMtd(O,Q,I,C S) trie to find Q in
*** class C or superclasses, then in S. boundMtd(O,Mt) is the result.


*** message queue
op noDealloc :         -> NatS  [ctor] .
*** op [_] : Nat       -> NatS  [ctor].
op _;_ : NatS NatS -> NatS [ctor comm assoc id: noDealloc] .

op noQu : -> Queue [ctor] .
op <_: Qu | Dealloc:_, Ev:_ > : Oid NatS MMsg -> Queue 
                          [format (nm! m o o o  m o o m o m! no)] . 

endfm

*** STATE CONFIGURATION ***
fmod CONFIG is
protecting OBJECT .
protecting COMMUNICATION .

sort Configuration .

subsorts Object Msg Queue Class < Configuration .

op noConf : -> Configuration [ctor] .
op __ : Configuration Configuration -> Configuration
  [ctor assoc comm id: noConf format (d nn d) ] .
op main : Cid ExprList -> Configuration .

var C : Cid . var E : ExprList .

eq main(C,E) = < ob('main) : 'class | Att: noSub, 
                 Pr: (noSub, ('var ::= new C(E))) , PrQ: noProc, Lcnt: 0 > 
               < ob('main) : Qu | Dealloc: noDealloc,Ev: noMsg > .

endfm

*** AUXILIARY FUNCTIONS ***
fmod AUX-FUNCTIONS is

  protecting CONFIG .
  protecting CONVERSION .

  *** Check if a message is in the queue.
  op inqueue  : Nat MMsg -> Bool .

  op enabledGuard : Guard   Subst MMsg -> Bool .
  op enabled      : StmList Subst MMsg -> Bool . *** eval guard 
  op ready        : StmList Subst MMsg -> Bool . *** eval guard 

  vars N N' : Nat .
  vars E E' : Expr .
  var EL : ExprList .
  var A : Aid .
  var Q : Qid .
  vars G1 G2 : Guard .
  var S : Subst .
  var MM : MMsg .
  var C : Cid .

  *** Create a new fresh name for an object.
  op newId : Cid Nat -> Oid .
  eq newId(Q, N)  = ob(qid(string(Q) + string(N,10))) .

  eq inqueue(N, noMsg) = false .
  *** eq inqueue(N, comp(N', E)) = if N == N' then true else false fi .
  eq inqueue(N, comp(N', EL) + MM) = 
     if N == N' then true else inqueue(N, MM) fi .

  eq enabledGuard(noGuard, S, MM)   = true .
  eq enabledGuard(wait, S, MM)      = false .       *** Note: no wait in PrQ!
  eq enabledGuard(E, S, MM)         = evalB(E, S) .
  eq enabledGuard((A ?), S, MM)     = inqueue(evalN(A, S), MM) .
  eq enabledGuard((N ?), S, MM)     = inqueue(N, MM) .

  vars  ST ST' : Stm . 
  vars SL SL' : StmList . 
  var NeSL : NeStmList .

  eq enabled(SL [] SL',  S, MM) = enabled(SL, S, MM) or enabled(SL', S, MM) .
  eq enabled(SL ||| SL', S, MM) = enabled(SL, S, MM) or enabled(SL', S, MM) .
  eq enabled(await G1,   S, MM) = enabledGuard(G1,S,MM) .
  eq enabled((ST ; ST' ; SL),S, MM) = enabled(ST, S, MM) . 
  eq enabled(ST,    S, MM) = true [owise] . 

  eq ready(SL [] SL',  S, MM) = ready(SL, S, MM) or ready(SL', S, MM) .
  eq ready(SL ||| SL', S, MM) = ready(SL, S, MM) or ready(SL', S, MM) .
  eq ready(A ?(E),     S, MM) = inqueue(evalN(A, S), MM) . 
  eq ready(N ?(E),     S, MM) = inqueue(N, MM) . 
  eq ready((ST ; ST' ; SL), S, MM) = ready(ST, S, MM) . 
  eq ready(ST,         S, MM) = enabled(ST, S, MM) [owise] .

endfm

eof