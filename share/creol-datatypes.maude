***
*** Datatypes for Creol
***
*** Copyright (c) 2007
***
*** This program is free software; you can redistribute it and/or
*** modify it under the terms of the GNU General Public License as
*** published by the Free Software Foundation; either version 3 of the
*** License, or (at your option) any later version.
***
*** This program is distributed in the hope that it will be useful, but
*** WITHOUT ANY WARRANTY; without even the implied warranty of
*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*** General Public License for more details.
***
*** You should have received a copy of the GNU General Public License
*** along with this program.  If not, see <http://www.gnu.org/licenses/>.
***

fmod CREOL-DATA-SIG is

  protecting META-LEVEL .
  protecting STRING .
  protecting NAT .

  sorts   Expr Data Vid Oid .
  subsort Oid < Data < Expr .
  subsort String < Vid < Expr .

  op null : -> Data [ctor format (! o)] .

  *** The interpreter should extend this module with his own definition
  *** of label values.  For example, the model checker uses his own version
  *** of labels.  This definition is the one used in the interpreter.
  *** op label : Nat -> Label [ctor] .
  sort Label .
  subsort Label < Data .
  op noLabel : -> Label [ctor] .

  op caller : Label -> Oid .

  *** Needed in the model checker for tail recursion.
  op tag : Label -> Label [ctor format(c o)] .
  var L : Label .
  eq tag(tag(L)) = L .

  sorts   NeExprList ExprList NeDataList DataList .
  subsort Expr < NeExprList < ExprList .
  subsort Data < NeDataList < DataList .
  subsort DataList < ExprList .
  subsort NeDataList < NeExprList .

  op emp : -> DataList [ctor] .

  op _#_ : ExprList ExprList -> ExprList
	[ctor assoc id: emp prec 27 format (d r os d)] .
  op _#_ : NeExprList ExprList -> NeExprList [ctor ditto] .
  op _#_ : ExprList NeExprList -> NeExprList [ctor ditto] .
  op _#_ : DataList DataList  -> DataList [ctor ditto] .
  op _#_ : NeDataList DataList  -> NeDataList [ctor ditto] .
  op _#_ : DataList NeDataList  -> NeDataList [ctor ditto] .

  sorts NeVidList VidList .
  subsort Vid < NeVidList < VidList .

  op noVid : -> VidList [ctor] .

  op _,_ : VidList VidList -> VidList
	[ctor assoc id: noVid format (d r os d)] .
  op _,_ : NeVidList VidList -> NeVidList [ctor ditto] .
  op _,_ : VidList NeVidList -> NeVidList [ctor ditto] .

  op _(_) : String DataList -> Data [format (! o d d d) prec 12] .
  op _(_) : String ExprList -> Expr [ctor ditto] .
  op if_th_el_fi : Expr Expr Expr -> Expr [ctor] .
  op _??  : Vid -> Expr [ctor] .
  op _??  : Label -> Expr [ctor] .
  op _@@_ : String String -> Vid [ctor] .

  op ob(_) : String -> Oid [ctor] .

  vars B B' : Bool .
  op bool(_) : Bool      -> Data [ctor format(o o ! o o)] .

  op _asBool            : Data -> Bool .
  eq bool(B) asBool     = B .

  vars D D'     : Data .
  
  eq "=" (D # D') = bool(D == D') .
  eq "/=" (D # D') = bool(D =/= D') .

  var E : Expr . *** For short circuiting ||, &&, and =>

  eq "~" (bool(false)) = bool(true) .  
  eq "~" (bool(true)) = bool(false) . 
  eq "&&" (bool(false) # E) = bool(false) .
  eq "&&" (bool(true) #  D) = D .
  eq "||" (bool(true) # E) = bool(true) .
  eq "||" (bool(false) # D) = D .
  eq "=>" (bool(true) # D) = D .
  eq "=>" (bool(false) # E) = bool(true) .
  eq "^" (bool(B) # bool(B')) = bool(B xor B') .
  eq "<=>" (bool(B) # bool(B')) = bool(B == B') .
endfm

view Vid from TRIV to CREOL-DATA-SIG is
  sort Elt to Vid .
endv

view Data from TRIV to CREOL-DATA-SIG is
  sort Elt to Data .
endv

view Expr from TRIV to CREOL-DATA-SIG is
  sort Elt to Expr .
endv

fmod CREOL-DATA-INT is
  extending CREOL-DATA-SIG .

  protecting INT .

  op int(_)  : Int -> Data [ctor format(o o ! o o)] . 

  vars I I' : Int .
  var N : Nat .

  op _asInt : Data -> Int .
  eq int(I) asInt = I .

  op _asNat : Data -> Nat .
  eq int(N)  asNat      = N .

  eq "-" (int(I)) = int(-(I)) .
  eq "+" (int(I) # int(I')) = int(I + I') .
  eq "-" (int(I) # int(I')) = int( _-_(I, I')) .
  eq "*" (int(I) # int(I')) = int(I * I') .
  eq "/" (int(I) # int(I')) = int(I quo I') .
  eq "%" (int(I) # int(I')) = int(I rem I') .
  eq "**" (int(I) # int(I')) = int(I ^ I') .

  eq "<"  (int(I) # int(I')) = bool(I < I') .
  eq "<=" (int(I) # int(I')) = bool(I <= I') .
  eq ">"  (int(I) # int(I')) = bool(I > I') .
  eq ">=" (int(I) # int(I')) = bool(I >= I') .
endfm

fmod CREOL-DATA-FLOAT is
  extending CREOL-DATA-SIG .

  protecting FLOAT .

  op float(_): Float     -> Data [ctor format(o o ! o o)] . 

  vars F F' : Float .

  op _asFloat : Data -> Float .
  eq float(F) asFloat = F .

  eq "-" (float(F)) = float(-(F)) .
  eq "<"  (float(F) # float(F')) = bool(F < F') .
  eq "<=" (float(F) # float(F')) = bool(F <= F') .
  eq ">"  (float(F) # float(F')) = bool(F > F') .
  eq ">=" (float(F) # float(F')) = bool(F >= F') .
  eq "+" (float(F) # float(F')) = float(F + F') .
  eq "-" (float(F) # float(F')) = float( _-_(F, F')) .
  eq "*" (float(F) # float(F')) = float(F * F') .
  eq "/" (float(F) # float(F')) = float(F / F') .
  eq "**" (float(F) # float(F')) = float(F ^ F') .
endfm

fmod CREOL-DATA-STRING is
  extending CREOL-DATA-SIG .

  protecting STRING .

  op str(_) : String    -> Data [ctor format(o o ! o o)] .

  vars S S' : String .

  op _asString : Data -> String .
  eq str(S) asString = S .

  eq "-|" (str(S) # str(S')) = str(S + S') .
  eq "|-|" (str(S) # str(S')) = str(S + S') .
  eq "|-" (str(S) # str(S')) = str(S + S') .

  eq "<" (str(S)# str(S')) = bool(S < S') .
  eq "<=" (str(S)# str(S')) = bool(S <= S') .
  eq ">" (str(S)# str(S')) = bool(S > S') .
  eq ">=" (str(S)# str(S')) = bool(S >= S') .
endfm

fmod CREOL-DATA-LIST is
  extending CREOL-DATA-INT .

  op list : ExprList -> Expr .
  op list : DataList -> Data [ctor] .

  vars N M : Nat .
  vars D D' : Data .
  vars E E' : Expr .
  vars L L' L'' : ExprList .

  *** list-functions
  eq "head" (list(emp))	= null .
  eq "head" (list(E # L)) = E .
  eq "last" (list(emp))	= null .
  eq "last" (list(L # E)) = E .
  eq "rest" (list(emp))	= null .
  eq "rest" (list(L # E)) = list(L) .
  eq "tail" (list(emp))	= null .
  eq "tail" (list(E # L)) = list(L) .

  eq "length" (list(emp)) = int(0) .
  eq "length" (list(E # L)) = "+" (int(1) # ("length" (list(L)))) .
  
  eq "isempty" (list(emp))  = bool(true) .
  eq "isempty" (list(E # L))= bool(false) .
  
  eq "remove" (list(E) #   E')  = if  E == E' then list(emp) else list(E) fi .
  eq "remove" (list(emp) # E )  = list(emp) .
  eq "remove" (list(E # L) # E') =
    if E == E' then "remove" ((list(L))# E') 
      else "|-|" (list(E) # ("remove" (list(L) # E'))) fi .

  --- Compute a slice of a sequence.
  eq "sub" (list(L) # int(N) # int(M)) =
    ".sub" (list(L) # int(N) # int(M) # list(emp)) .
  ceq ".sub" (list(E # L) # int(N) # int(M) # list(L')) =
    ".sub" (list(L) # int(_-_(N, 1)) # int(_-_(M, 1)) # list(L')) if N > 1 .
  ceq ".sub" (list(E # L) # int(1) # int(M) # list(L')) =
    ".sub" (list(L) # int(1) # int(_-_(M, 1)) # list(L' # E)) if M >= 1 .
  eq ".sub" (list(L) # int(1) # int(0) # list(L')) = list(L') .

  eq "-|" (D # list(L)) = list(D # L) .
  eq "|-" (list(L) # D) = list(L # D) .

  eq "has" (list(emp)# E ) = bool(false) .
  eq "has" (list(E # L) # E) = bool(true) .
  eq "has" (list(E # L) # E') = "has" (list(L) # E') [otherwise] .

  ***index starts at 1
  eq "after" (list(emp) # int(N))    = null . 
  eq "after" (list(E # L) # int(0))  = list(E # L) .
  eq "after" (list(E # L) # int(N))  =
    "after" (list(L) # int(_-_(N, 1))) .

  eq "nth" ((list(L)) # int(0))  = null .
  eq "nth" ((list(emp)) # int(N))  = null .
  eq "nth" ((list(E # L)) # int(N)) =
    if (N == 1) then E else "nth" (list(L) # int(_-_(N, 1))) fi .

  eq "rnth" ((list(L)) # int(0))  = null .
  eq "rnth" ((list(emp)) # int(N))  = null .
  eq "rnth" ((list(L # E)) # int(N)) =
    if (N == 1) then E else "rnth" (list(L) # int(_-_(N, 1))) fi .

  eq "begwith" (list(E) # E') = bool("head" (list(E)) == E') .
  eq "begwith" (list(E # L)# E') = bool("head" (list(E # L)) == E') .
  eq "begwith" (list(E)# E') = bool("last" (list(E)) == E') .
  eq "begwith" (list(E # L)# E') = bool("last" (list(L)) == E') .

  --- If E is not in the list, these will fail with the term
  --- "+" (int(N) # null)
  eq "index" (list(emp) # E) = null .
  eq "index" (list(E # L) # E') =
    if E == E' then int(1) else "+" (int(1) # "index" (list(L) # E')) fi .

  --- If E is not in the list, these will fail with the term
  --- "-" (int(N) # null)
  eq "rindex" (list(L) # E) =
    "-" ("length" (list(L)) # ".rindex" (list(L) # E)) .
  eq ".rindex" (list(emp) # E') = null .
  eq ".rindex" (list(L # E) # E') =
    if E == E' then int(1) else "+" (int(1) # "rindex" (list(L) # E')) fi .

  eq "|-|" (list(L) # list(L'))   = list(L # L') .
endfm

fmod CREOL-DATA-SET is

  extending CREOL-DATA-SIG .
  extending CREOL-DATA-INT .

  sorts DataSet NeDataSet ExprSet NeExprSet .
  subsort NeDataSet < DataSet .
  subsort NeExprSet < ExprSet .
  subsort DataSet < ExprSet .
  subsort NeDataSet < NeExprSet .
  subsort Data < NeDataSet .
  subsort Expr < NeExprSet .

  op emptyset : -> DataSet [ctor] .
  op _:_ : DataSet DataSet -> DataSet [ctor comm assoc id: emp] .
  op _:_ : NeDataSet DataSet -> NeDataSet [ctor ditto] .
  op _:_ : DataSet NeDataSet -> DataSet [ctor ditto] .
  op _:_ : ExprSet ExprSet -> ExprSet [ctor ditto] .
  op _:_ : NeExprSet ExprSet -> NeExprSet [ctor ditto] .
  op _:_ : ExprSet NeExprSet -> ExprSet [ctor ditto] .

  op set : ExprSet -> Expr .
  op set : DataSet -> Data [ctor] .

  vars N        : Nat .
  vars D D'     : Data .
  vars E E'     : Expr .
  vars L L' L'' : ExprSet .

  eq D : D = D . --- Collapse multiple elements.

  eq "#" (set(emptyset)) = int(0) .
  eq "#" (set(L : E)) = "+" (int(1) # "#" (set(L))) .

  eq "remove" (set(emptyset) # E)  = set(emp) .
  eq "remove" (set(L : E) # E') =
    if E == E' then set(L) else "add" (set(E) # ("remove" (set(L) # E'))) fi .

  eq "add" (set(L) # E) =
    if "has" (set(L) # E) asBool then set(L) else set(L # E) fi .    

  eq "has" (set(emptyset) #  E ) = bool(false) .
  eq "has" (set(L # E) # E') =
    if E == E' then bool(true) else "has" (set(L) # E') fi .

  eq "union" (set(L) # set(L'))   = set(L # L') .

endfm

fmod CREOL-DATA-PAIR is
  extending CREOL-DATA-SIG .

  op pair : Data Data -> Data [ctor] .
  op pair : Expr Expr -> Expr .

  vars D D' : Data .

  eq "pair" (D # D') = pair(D, D') .
  eq "fst" (pair(D, D')) = D . 
  eq "snd" (pair(D, D')) = D' .
endfm

fmod CREOL-DATA-MAP is
  protecting CREOL-DATA-SIG .
  protecting MAP{Expr, Expr} * (sort Map{Expr, Expr} to ExprMap,
				op undefined to udef,
				op _|->_ to _|~>_ ) .

  op map : ExprMap -> Expr .

  var M : ExprMap .
  vars D D' : Data .

  eq "get" (map(M) # D) = M[D] .
  eq "insert" (map(M) # D # D') = map(insert(D, D', M)) .

  *** We have to carefully evaluate whether this makes things better or
  *** worse.
  sort DataMap .
  subsort DataMap < ExprMap .

  var DM : DataMap .

  mb empty : DataMap .
  mb (D |~> D') : DataMap .
  --- mb (DM, D |~> D') : DataMap .
  mb map(DM) : Data .

endfm

fmod CREOL-DATA-TIME is
  extending CREOL-DATA-SIG .
  extending CREOL-DATA-FLOAT .

  *** The central problem will be to evaluate this "expression", since the
  *** clock is floating around in the global state.  This problem will be
  *** solved later.
  op now : -> Expr [ctor] .

  op time : Float -> Data . 
  op duration : Float -> Data .

  vars T T' S : Float .

  *** Define the usual predicates on time.
  eq "<" ( time(T) # time(T') ) = bool(T < T') .
  eq "<=" ( time(T) # time(T') ) = bool(T <= T') .
  eq ">" ( time(T) # time(T') ) = bool(T > T') .
  eq ">=" ( time(T) # time(T') ) = bool(T >= T') .

  eq "<" ( duration(T) # duration(T') ) = bool(T < T') .
  eq "<=" ( duration(T) # duration(T') ) = bool(T <= T') .
  eq ">" ( duration(T) # duration(T') ) = bool(T > T') .
  eq ">=" ( duration(T) # duration(T') ) = bool(T >= T') .

  *** Arithmetic on time
  eq "+" ( time(T) # duration(T') ) = time(T + T') .
  eq "-" ( time(T) # time(T') ) = duration(T - T') .

  *** We can always multiply by a scalar.
  eq "*" ( float(S) # duration(T') ) = duration(S * T') .
  eq "*" ( float(S) # time(T') ) = time(S * T') .

  *** Division et al. does not make any sense in this domain.
endfm

fmod CREOL-DATATYPES is
  *** may easily keep various data types on separate file(s), 
  *** and plug in upon need.

  extending CREOL-DATA-SIG .
  extending CREOL-DATA-INT .
  extending CREOL-DATA-FLOAT .
  extending CREOL-DATA-STRING .
  extending CREOL-DATA-LIST .
  extending CREOL-DATA-SET .
  extending CREOL-DATA-MAP .
  extending CREOL-DATA-PAIR .
  extending CREOL-DATA-TIME .

endfm
