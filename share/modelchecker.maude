***
*** Adaption of the interpreter form model checking
***
*** Copyright (c) 2007
***
*** The purpose of this file is to create the files `prelude.creol'
*** and `modelcheck.creol'.  These files have to be processed with
*** m4, with either one of `CREOL' or `MODELCHECK' defined.
***
*** This program is free software; you can redistribute it and/or
*** modify it under the terms of the GNU General Public License as
*** published by the Free Software Foundation; either version 2 of the
*** License, or (at your option) any later version.
***
*** This program is distributed in the hope that it will be useful, but
*** WITHOUT ANY WARRANTY; without even the implied warranty of
*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*** General Public License for more details.
***
*** You should have received a copy of the GNU General Public License
*** along with this program; if not, write to the Free Software
*** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
*** 02111-1307, USA.
***

load datatypes

load signature

*** THE MACHINE ***
mod INTERPRETER is

  protecting AUX-FUNCTIONS .

  vars O O' : Oid .
  vars C C' : Cid .
  var A : Aid .
  var AL : AidList .
  var D : Data .
  var DL : DataList .
  vars E E' : Expr .
  vars EL EL' : ExprList .
  var ST : Stm .
  vars SL SL' SL'' : StmList .
  vars SL1 SL2 : NeStmList .
  var P : Process .
  var W : MProc .
  vars S S' L L' : Subst .
  vars N F : Nat .
  vars I I' : InhList .
  var MS : MMtd .
  var LS : Labels .
  vars Lab Lab' : Label .
  var MM : MMsg .
  var G : Guard .
  var M : Mid .
  var Q : Qid .
  var MsgBody : Body .

  *** Internal assignment, where the arguments have been evaluated.
  *** This is needed in order to keep confluence in the more synchronous
  *** rewrite system.
  op assign : AidList DataList -> Stm [ctor] .

  *** multiple assignment
  eq
    < O : C | Att: S, Pr: (L,(AL ::= EL); SL), PrQ: W, Lcnt: N >
    =
    < O : C | Att: S, Pr: (L, (assign(AL, evalList(EL, (S # L))); SL)), 
      PrQ: W, Lcnt: N >
  [label assign-multiple] .

eq [assign] :
  < O : C | Att: S, Pr: (L, assign((A ,, AL), (D # DL)); SL), PrQ: W, Lcnt: N >
  =
  if dom(A,S) then
    < O : C | Att: insert(A, D, S), Pr: (L, assign(AL, DL); SL), PrQ: W, Lcnt: N > 
  else
    < O : C | Att: S, Pr: (insert(A, D, L), assign(AL, DL); SL), PrQ: W, Lcnt: N > 
  fi .

eq [assign-skip] :
  < O : C | Att: S, Pr: (L, assign(noAid, emp); SL), PrQ: W, Lcnt: N >
  =
  < O : C | Att: S, Pr: (L, SL), PrQ: W, Lcnt: N > .

eq [skip] :
  < O : C | Att: S, Pr: (L, skip ; SL), PrQ: W, Lcnt: N >
  =
  < O : C | Att: S, Pr: (L, SL), PrQ: W, Lcnt: N > .


eq [if-el] :
  < O : C | Att: S, Pr: (L, if E th SL' el SL'' fi ; SL), PrQ: W, Lcnt: N >
  =
  if eval(E, (S # L)) asBool then
    < O : C | Att: S, Pr: (L, SL' ; SL), PrQ: W, Lcnt: N >
  else
    < O : C | Att: S, Pr: (L, SL'' ; SL), PrQ: W, Lcnt: N >
  fi .


***(
  We want to be able to observe what happens here in an infinite loop.
  therefore, each expansion of a while body is done by a rule. )

rl [while] :
  < O : C | Att: S, Pr: (L, while E do SL1 od ; SL2), PrQ: W, Lcnt: N >
  =>
  < O : C | Att: S, 
      Pr: (L, (if E th (SL1 ; while E do SL1 od) el skip fi); SL2),
      PrQ: W, Lcnt: N > .


eq [new-object] :
  < O : C | Att: S,Pr: (L, (A ::= new C' (EL)); SL),PrQ: W, Lcnt: N > 
  < C' : Cl | Inh: I , Par: AL, Att: S' , Mtds: MS , Ocnt: F >
  =
  < O : C | Att: S, Pr: (L, (A ::= newId(C', F)); SL), PrQ: W, Lcnt: N >
  < C' : Cl | Inh: I , Par: AL, Att: S' , Mtds: MS , Ocnt: (F + 1) >
  < newId(C',F) : C' | Att: S, Pr: idle, PrQ: noProc, Lcnt: 1 >
  < newId(C',F) : Qu | Dealloc: noDealloc, Ev: noMsg > 
  findAttr(newId(C',F), I, S', 
  (AL ::= evalList(EL, (S # L))), ('init (emp : noAid)) ; ('run (emp : noAid))) .

*** ATTRIBUTE inheritance with multiple inheritance
*** CMC assumes that all attributes names are (globally) different

op findAttr  : Oid InhList Subst StmList StmList -> Msg [ctor] . *** collect attributes
op foundAttr : Oid Subst  StmList StmList        -> Msg [ctor] . *** resulting Subst
*** look in InhList, collect attributes in Subst, give result to Oid
*** SL SL' SL''

eq findAttr(O, noInh, S, SL, SL')  *** collection completed.
       = foundAttr(O, S, SL, SL') .

eq findAttr(O,((C < EL >) ## I),S, SL, SL') 
< C : Cl | Inh: I', Par: AL, Att: L, Mtds: MS, Ocnt: F >
 = findAttr(O, I ## I',(L # S), (AL ::= EL) ; SL, 
              ('init @ C(emp : noAid)) ; SL') 
   < C : Cl | Inh: I', Par: AL, Att: L, Mtds: MS, Ocnt: F > .

eq foundAttr(O, S', SL, SL') 
< O : C | Att: S, Pr: idle, PrQ: W, Lcnt: N >
 = < O : C | Att: ('this |-> O, S'), Pr: (noSubst, SL ; SL'), PrQ: W, Lcnt: N > .

*** Non-deterministic choice ***
*** Choice is comm, so [nondet] considers both SL1 and SL2.
crl [nondet] :
< O : C | Att: S, Pr: (L, (SL1 [] SL2); SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
=>
< O : C | Att: S, Pr: (L, (SL1 ; SL)), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
if ready(SL1, (S # L), MM) .  

*** Merge ***
*** Merge is comm, so [merge] considers both SL1 and SL2.
crl [merge] :
< O : C | Att: S, Pr: (L, (SL1 ||| SL2); SL), PrQ: W, Lcnt: N >  
< O : Qu | Dealloc: LS, Ev: MM >
=>
< O : C | Att: S, Pr: (L, (SL1 MERGER SL2); SL), PrQ: W, Lcnt: N >  
< O : Qu | Dealloc: LS, Ev: MM >
if ready(SL1,(S # L), MM) . 

eq [merge-aux] :
< O : C | Att: S,  Pr:  (L, ((ST ; SL') MERGER SL2); SL), PrQ: W, Lcnt: N >   
< O : Qu | Dealloc: LS, Ev: MM >
=
< O : Qu | Dealloc: LS, Ev: MM >
if enabled(ST,(S # L), MM) then
< O : C | Att: S, Pr: (L, ((ST ; (SL' MERGER SL2)); SL)), PrQ: W, Lcnt: N >   
else
< O : C | Att: S, Pr: (L, ((ST ; SL') ||| SL2); SL), PrQ: W, Lcnt: N >   
fi .

eq [continue2] :
< O : C | Att: S, Pr: (L, (cont(Lab) MERGER SL'); SL''), 
          PrQ: (L', ((Lab ?(A)); SL)) ++ W, Lcnt: F >
=
< O : C | Att: S, Pr: (L',((((Lab ?(A)) ; SL) MERGER SL'); SL'')), 
          PrQ: W, Lcnt: F > .

*** local call 
ceq boundMtd(O, (L', SL')) 
< O : C | Att: S,Pr: (L, ((Lab ?(EL)); SL)),PrQ: W,Lcnt: F >
= 
< O : C | Att: S,Pr: (L', SL' ; cont(Lab)),PrQ: (L,((await Lab ?) ; (Lab ?(EL)); SL)) ++ W,
          Lcnt: F > 
if (L'['label] == Lab) .

*** local call within merge
ceq boundMtd(O, (L', SL')) 
< O : C | Att: S,Pr: (L,(((Lab ?(EL)); SL) MERGER SL'')),PrQ: W,Lcnt: F >
= 
< O : C | Att: S,Pr: (L', SL'),
          PrQ: (L, (((await Lab ?) ; (Lab ?(EL)); SL) MERGER SL'')) ++ W,Lcnt: F > 
if (L'['label] == Lab) .

*** Suspension ***

ceq [suspend] :  *** all kinds of code P 
< O : C | Att: S, Pr: (L,SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
=
< O : C | Att: S, Pr: idle, PrQ: W ++ (L, SL), Lcnt: N > *** clear(SL)
< O : Qu | Dealloc: LS, Ev: MM >
if not enabled(SL, (S # L), MM) . 

*** Guards ***

ceq [guard] :
< O : C | Att: S, Pr: (L, await G ; SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
=
< O : C | Att: S, Pr: (L,SL) , PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM > 
if enabledGuard(G, (S # L), MM) .

*** Evaluate guards in suspended processes ***

crl [PrQ-ready] :
< O : C | Att: S, Pr: idle, PrQ: (L,SL) ++ W, Lcnt: N > 
< O : Qu | Dealloc: LS, Ev: MM >
=>
< O : C | Att: S, Pr: (L,SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
if ready(SL, (S # L), MM) .


*** Evaluation of wait in PrQ *** (avoiding clear)

*** rl [wait] :
eq [wait] :
< O : C | Att: S, Pr: idle, PrQ: (L, await wait ; SL) ++ W, Lcnt: N >  
 =
< O : C | Att: S, Pr: idle, PrQ: (L, SL) ++ W, Lcnt: N > .

eq [wait-nondet] :
< O : C | Att: S, Pr: idle, PrQ: (L, ((await wait ; SL)[] SL'); SL'')++ W,  
   Lcnt: N >  
 = < O : C | Att: S, Pr: idle, PrQ: (L, (SL [] SL'); SL'') ++ W, Lcnt: N > .

eq [wait-merge] : < O : C | Att: S, Pr: idle, PrQ: (L,((await wait ; SL)||| SL'); SL'')++ W,  
   Lcnt: N >  
 = < O : C | Att: S, Pr: idle, PrQ: (L, (SL ||| SL'); SL'') ++ W, Lcnt: N > .

*** Optimization to avoid muiltiple lookups in the message queue for
*** the same guard
eq 
< O : C | Att: S, Pr: P, PrQ: (L, await (Lab ? & G); SL) ++ W, Lcnt: F > 
< O : Qu | Dealloc: LS, Ev: MM + comp(Lab, EL) >  
=
< O : C | Att: S,  Pr: P, PrQ: (L, await G ; SL) ++ W, Lcnt: F >    
< O : Qu | Dealloc: LS, Ev: MM + comp(Lab, EL) > .


*** METHOD CALLS ***

eq   ! Q(EL) =   ! 'this . Q(EL) . *** could alternatively use X@ this class

*** receive invocation message ***
rl [receive-call-req] :
< O : C | Att: S, Pr: P, PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM + invoc(O', Lab, Q, EL) >
=>
< O : C | Att: S, Pr: P, PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM > bindMtd(O, O', Lab, Q, EL, C < emp >) .

*** Method binding with multiple inheritance
ceq bindMtd(O, O',Lab,Q, EL,noInh) = 
boundMtd(O,(('caller |-> O', 'label |-> Lab), return(emp)))
if Q == 'run .


eq bindMtd(O,O', Lab, M,EL,(C < EL' >) ## I') 
< C : Cl | Inh: I , Par: AL, Att: S , Mtds: MS , Ocnt: F >
   =  if (M in MS) then boundMtd(O,get(M,MS,O',  Lab, EL)) 
                   else bindMtd(O,O', Lab,M,EL, I ## I') fi 
< C : Cl | Inh: I , Par: AL, Att: S , Mtds: MS , Ocnt: F > .

rl [receive-call-req] :
< O : Qu | Dealloc: LS, Ev: MM + invoc(O', Lab, Q @ C, EL) >
=>
< O : Qu | Dealloc: LS, Ev: MM >  bindMtd(O, O', Lab, Q, EL, C < emp >) .

eq [receive-call-bound] : 
boundMtd(O, P) < O : C | Att: S, Pr: idle, PrQ: W, Lcnt: N >
=
< O : C | Att: S, Pr: P, PrQ: W, Lcnt: N >
.

eq [continue] :
< O : C | Att: S, Pr: (L,cont(Lab)), PrQ: (L',((Lab ?(EL)); SL)) ++ W, Lcnt: F >
=
< O : C | Att: S, Pr: (L',((Lab ?(EL)); SL)), PrQ: W, Lcnt: F > .

eq [local-async-qualified-req] :
< O : C | Att: S, Pr: (L, ( ! Q @ C'(EL)); SL),PrQ: W, Lcnt: N >
= 
< O : C | Att: S, Pr: (L, SL), PrQ: W, Lcnt: N + 1 >
invoc(O, label(N), Q @ C', evalList(EL, (S # L))) from O to O .

*** REMOTE METHOD CALLS ***
eq [remote-call] :
  < O : C | Att: S, Pr: (L, (Q ! M(EL)); SL), PrQ: W, Lcnt: N >
  =
  < O : C | Att: S, Pr: (L, (Q ::= int(N)); (! M (EL));  SL),
    PrQ: W,  Lcnt: N > .


eq [remote-async-reply] : 
< O : C | Att: S, Pr: (L, ( ! E . M(EL)); SL), PrQ: W, Lcnt: N >
=
< O : C | Att: S, Pr: (L,SL), PrQ: W, Lcnt: N + 1 >
invoc(O, label(N), M , evalList(EL, (S # L))) from O to eval(E, (S # L)) .

*** Reduce sync. call  to async. call with reply 
eq < O : C | Att: S, Pr: (L, (M(EL : EL')); SL), PrQ: W, Lcnt: N >
  =
< O : C | Att: S, Pr: (L, (! M(EL)); (label(N) ?(EL')); SL), PrQ: W,  Lcnt: N >  .

*** emit reply message ***
eq [return] :
< O : C |  Att: S, Pr: (L, (return(EL)); SL), PrQ: W, Lcnt: N >
=
< O : C |  Att: S, Pr: (L, SL), PrQ: W, Lcnt: N > 
comp(L['label], evalList(EL, (S # L))) from O to L['caller] .

*** Optimization: reduce label to value only once
eq < O : C |  Att: S, Pr: (L, (A ?(EL)); SL), PrQ: W, Lcnt: N > 
= < O : C |  Att: S, Pr: (L, ((L[A]) ?(EL)); SL), PrQ: W, Lcnt: N > .

*** blocking reply sentence ***
eq [block-sync-reply] :
< O : C |  Att: S, Pr: (L, (Lab ? (EL)); SL), PrQ: W, Lcnt: F > 
< O : Qu | Dealloc: LS, Ev: MM + comp(Lab, EL') >
= 
< O : C |  Att: S, Pr: (L, (EL ::= EL'); SL), PrQ: W, Lcnt: F > 
< O : Qu | Dealloc: LS, Ev: MM > .

*** We may here get (emp ::= emp), which should be reduced to skip .
eq (emp ::= emp) = skip .

*** Transport rule: include new message in queue
eq [invoc-msg] :
< O : Qu | Dealloc: LS, Ev: MM > (MsgBody from O' to O)
=
< O : Qu | Dealloc: LS, Ev: MM + MsgBody > .

*** generalize to lists of labels AL:
eq [free] :
< O : C | Att: S, Pr: (L, free(A) ; SL), PrQ: W, Lcnt: N >
< O : Qu | Dealloc: LS, Ev: MM >
=
< O : C | Att: S, Pr: (L,SL), PrQ: W, Lcnt: N > 
< O : Qu | Dealloc: (eval(A, (S # L)) ^ LS), Ev: MM > .

*** Deallocate
eq < O : Qu | Dealloc: (Lab ^ LS), Ev: comp(Lab, EL) + MM >
= < O : Qu | Dealloc: LS, Ev: MM > .
endm

eof
